
C:\STM32F4\MyProjects\R7_FrequencyCounter\stm32f4xx_rcc.o:     file format elf32-littlearm
C:\STM32F4\MyProjects\R7_FrequencyCounter\stm32f4xx_rcc.o


Disassembly of section .text.RCC_DeInit:

00000000 <RCC_DeInit>:
RCC_DeInit():
C:\STM32F4\MyProjects\R7_FrequencyCounter/stm32f4xx_rcc.c:199
  * @retval None
  */
void RCC_DeInit(void)
{
  /* Set HSION bit */
  RCC->CR |= (uint32_t)0x00000001;
   0:	f44f 5360 	mov.w	r3, #14336	; 0x3800
   4:	f2c4 0302 	movt	r3, #16386	; 0x4002
   8:	681a      	ldr	r2, [r3, #0]
   a:	f042 0201 	orr.w	r2, r2, #1
   e:	601a      	str	r2, [r3, #0]
C:\STM32F4\MyProjects\R7_FrequencyCounter/stm32f4xx_rcc.c:202

  /* Reset CFGR register */
  RCC->CFGR = 0x00000000;
  10:	f04f 0200 	mov.w	r2, #0
  14:	609a      	str	r2, [r3, #8]
C:\STM32F4\MyProjects\R7_FrequencyCounter/stm32f4xx_rcc.c:205

  /* Reset HSEON, CSSON and PLLON bits */
  RCC->CR &= (uint32_t)0xFEF6FFFF;
  16:	6819      	ldr	r1, [r3, #0]
  18:	f021 7184 	bic.w	r1, r1, #17301504	; 0x1080000
  1c:	f421 3180 	bic.w	r1, r1, #65536	; 0x10000
  20:	6019      	str	r1, [r3, #0]
C:\STM32F4\MyProjects\R7_FrequencyCounter/stm32f4xx_rcc.c:208

  /* Reset PLLCFGR register */
  RCC->PLLCFGR = 0x24003010;
  22:	f243 0110 	movw	r1, #12304	; 0x3010
  26:	f2c2 4100 	movt	r1, #9216	; 0x2400
  2a:	6059      	str	r1, [r3, #4]
C:\STM32F4\MyProjects\R7_FrequencyCounter/stm32f4xx_rcc.c:211

  /* Reset HSEBYP bit */
  RCC->CR &= (uint32_t)0xFFFBFFFF;
  2c:	6819      	ldr	r1, [r3, #0]
  2e:	f421 2180 	bic.w	r1, r1, #262144	; 0x40000
  32:	6019      	str	r1, [r3, #0]
C:\STM32F4\MyProjects\R7_FrequencyCounter/stm32f4xx_rcc.c:214

  /* Disable all interrupts */
  RCC->CIR = 0x00000000;
  34:	60da      	str	r2, [r3, #12]
C:\STM32F4\MyProjects\R7_FrequencyCounter/stm32f4xx_rcc.c:215
}
  36:	4770      	bx	lr

Disassembly of section .text.RCC_HSEConfig:

00000000 <RCC_HSEConfig>:
RCC_HSEConfig():
C:\STM32F4\MyProjects\R7_FrequencyCounter/stm32f4xx_rcc.c:243
{
  /* Check the parameters */
  assert_param(IS_RCC_HSE(RCC_HSE));

  /* Reset HSEON and HSEBYP bits before configuring the HSE ------------------*/
  *(__IO uint8_t *) CR_BYTE3_ADDRESS = RCC_HSE_OFF;
   0:	f643 0302 	movw	r3, #14338	; 0x3802
   4:	f2c4 0302 	movt	r3, #16386	; 0x4002
   8:	f04f 0200 	mov.w	r2, #0
   c:	701a      	strb	r2, [r3, #0]
C:\STM32F4\MyProjects\R7_FrequencyCounter/stm32f4xx_rcc.c:246

  /* Set the new HSE configuration -------------------------------------------*/
  *(__IO uint8_t *) CR_BYTE3_ADDRESS = RCC_HSE;
   e:	7018      	strb	r0, [r3, #0]
C:\STM32F4\MyProjects\R7_FrequencyCounter/stm32f4xx_rcc.c:247
}
  10:	4770      	bx	lr
  12:	bf00      	nop

Disassembly of section .text.RCC_AdjustHSICalibrationValue:

00000000 <RCC_AdjustHSICalibrationValue>:
RCC_AdjustHSICalibrationValue():
C:\STM32F4\MyProjects\R7_FrequencyCounter/stm32f4xx_rcc.c:298
{
  uint32_t tmpreg = 0;
  /* Check the parameters */
  assert_param(IS_RCC_CALIBRATION_VALUE(HSICalibrationValue));

  tmpreg = RCC->CR;
   0:	f44f 5360 	mov.w	r3, #14336	; 0x3800
   4:	f2c4 0302 	movt	r3, #16386	; 0x4002
   8:	681a      	ldr	r2, [r3, #0]
C:\STM32F4\MyProjects\R7_FrequencyCounter/stm32f4xx_rcc.c:301

  /* Clear HSITRIM[4:0] bits */
  tmpreg &= ~RCC_CR_HSITRIM;
   a:	f022 02f8 	bic.w	r2, r2, #248	; 0xf8
C:\STM32F4\MyProjects\R7_FrequencyCounter/stm32f4xx_rcc.c:304

  /* Set the HSITRIM[4:0] bits according to HSICalibrationValue value */
  tmpreg |= (uint32_t)HSICalibrationValue << 3;
   e:	ea42 02c0 	orr.w	r2, r2, r0, lsl #3
C:\STM32F4\MyProjects\R7_FrequencyCounter/stm32f4xx_rcc.c:307

  /* Store the new value */
  RCC->CR = tmpreg;
  12:	601a      	str	r2, [r3, #0]
C:\STM32F4\MyProjects\R7_FrequencyCounter/stm32f4xx_rcc.c:308
}
  14:	4770      	bx	lr
  16:	bf00      	nop

Disassembly of section .text.RCC_HSICmd:

00000000 <RCC_HSICmd>:
RCC_HSICmd():
C:\STM32F4\MyProjects\R7_FrequencyCounter/stm32f4xx_rcc.c:333
void RCC_HSICmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  *(__IO uint32_t *) CR_HSION_BB = (uint32_t)NewState;
   0:	f04f 0300 	mov.w	r3, #0
   4:	f2c4 2347 	movt	r3, #16967	; 0x4247
   8:	6018      	str	r0, [r3, #0]
C:\STM32F4\MyProjects\R7_FrequencyCounter/stm32f4xx_rcc.c:334
}
   a:	4770      	bx	lr

Disassembly of section .text.RCC_LSEConfig:

00000000 <RCC_LSEConfig>:
RCC_LSEConfig():
C:\STM32F4\MyProjects\R7_FrequencyCounter/stm32f4xx_rcc.c:360
  /* Check the parameters */
  assert_param(IS_RCC_LSE(RCC_LSE));

  /* Reset LSEON and LSEBYP bits before configuring the LSE ------------------*/
  /* Reset LSEON bit */
  *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_OFF;
   0:	f643 0370 	movw	r3, #14448	; 0x3870
   4:	f2c4 0302 	movt	r3, #16386	; 0x4002
   8:	f04f 0200 	mov.w	r2, #0
   c:	701a      	strb	r2, [r3, #0]
C:\STM32F4\MyProjects\R7_FrequencyCounter/stm32f4xx_rcc.c:363

  /* Reset LSEBYP bit */
  *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_OFF;
   e:	701a      	strb	r2, [r3, #0]
C:\STM32F4\MyProjects\R7_FrequencyCounter/stm32f4xx_rcc.c:366

  /* Configure LSE (RCC_LSE_OFF is already covered by the code section above) */
  switch (RCC_LSE)
  10:	2801      	cmp	r0, #1
  12:	d002      	beq.n	1a <RCC_LSEConfig+0x1a>
  14:	2804      	cmp	r0, #4
  16:	d10f      	bne.n	38 <RCC_LSEConfig+0x38>
  18:	e007      	b.n	2a <RCC_LSEConfig+0x2a>
C:\STM32F4\MyProjects\R7_FrequencyCounter/stm32f4xx_rcc.c:370
  {
    case RCC_LSE_ON:
      /* Set LSEON bit */
      *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_ON;
  1a:	f643 0370 	movw	r3, #14448	; 0x3870
  1e:	f2c4 0302 	movt	r3, #16386	; 0x4002
  22:	f04f 0201 	mov.w	r2, #1
  26:	701a      	strb	r2, [r3, #0]
C:\STM32F4\MyProjects\R7_FrequencyCounter/stm32f4xx_rcc.c:371
      break;
  28:	4770      	bx	lr
C:\STM32F4\MyProjects\R7_FrequencyCounter/stm32f4xx_rcc.c:374
    case RCC_LSE_Bypass:
      /* Set LSEBYP and LSEON bits */
      *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_Bypass | RCC_LSE_ON;
  2a:	f643 0370 	movw	r3, #14448	; 0x3870
  2e:	f2c4 0302 	movt	r3, #16386	; 0x4002
  32:	f04f 0205 	mov.w	r2, #5
  36:	701a      	strb	r2, [r3, #0]
  38:	4770      	bx	lr
  3a:	bf00      	nop

Disassembly of section .text.RCC_LSICmd:

00000000 <RCC_LSICmd>:
RCC_LSICmd():
C:\STM32F4\MyProjects\R7_FrequencyCounter/stm32f4xx_rcc.c:398
void RCC_LSICmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  *(__IO uint32_t *) CSR_LSION_BB = (uint32_t)NewState;
   0:	f44f 6368 	mov.w	r3, #3712	; 0xe80
   4:	f2c4 2347 	movt	r3, #16967	; 0x4247
   8:	6018      	str	r0, [r3, #0]
C:\STM32F4\MyProjects\R7_FrequencyCounter/stm32f4xx_rcc.c:399
}
   a:	4770      	bx	lr

Disassembly of section .text.RCC_PLLConfig:

00000000 <RCC_PLLConfig>:
RCC_PLLConfig():
C:\STM32F4\MyProjects\R7_FrequencyCounter/stm32f4xx_rcc.c:445
  assert_param(IS_RCC_PLLM_VALUE(PLLM));
  assert_param(IS_RCC_PLLN_VALUE(PLLN));
  assert_param(IS_RCC_PLLP_VALUE(PLLP));
  assert_param(IS_RCC_PLLQ_VALUE(PLLQ));

  RCC->PLLCFGR = PLLM | (PLLN << 6) | (((PLLP >> 1) -1) << 16) | (RCC_PLLSource) |
   0:	4301      	orrs	r1, r0
   2:	ea41 1282 	orr.w	r2, r1, r2, lsl #6
   6:	9900      	ldr	r1, [sp, #0]
   8:	ea42 6101 	orr.w	r1, r2, r1, lsl #24
   c:	ea4f 0353 	mov.w	r3, r3, lsr #1
  10:	f103 33ff 	add.w	r3, r3, #4294967295
  14:	ea41 4103 	orr.w	r1, r1, r3, lsl #16
  18:	f44f 5360 	mov.w	r3, #14336	; 0x3800
  1c:	f2c4 0302 	movt	r3, #16386	; 0x4002
  20:	6059      	str	r1, [r3, #4]
C:\STM32F4\MyProjects\R7_FrequencyCounter/stm32f4xx_rcc.c:447
                 (PLLQ << 24);
}
  22:	4770      	bx	lr

Disassembly of section .text.RCC_PLLCmd:

00000000 <RCC_PLLCmd>:
RCC_PLLCmd():
C:\STM32F4\MyProjects\R7_FrequencyCounter/stm32f4xx_rcc.c:463
  */
void RCC_PLLCmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  *(__IO uint32_t *) CR_PLLON_BB = (uint32_t)NewState;
   0:	f04f 0360 	mov.w	r3, #96	; 0x60
   4:	f2c4 2347 	movt	r3, #16967	; 0x4247
   8:	6018      	str	r0, [r3, #0]
C:\STM32F4\MyProjects\R7_FrequencyCounter/stm32f4xx_rcc.c:464
}
   a:	4770      	bx	lr

Disassembly of section .text.RCC_PLLI2SConfig:

00000000 <RCC_PLLI2SConfig>:
RCC_PLLI2SConfig():
C:\STM32F4\MyProjects\R7_FrequencyCounter/stm32f4xx_rcc.c:491
{
  /* Check the parameters */
  assert_param(IS_RCC_PLLI2SN_VALUE(PLLI2SN));
  assert_param(IS_RCC_PLLI2SR_VALUE(PLLI2SR));

  RCC->PLLI2SCFGR = (PLLI2SN << 6) | (PLLI2SR << 28);
   0:	ea4f 1080 	mov.w	r0, r0, lsl #6
   4:	ea40 7101 	orr.w	r1, r0, r1, lsl #28
   8:	f44f 5360 	mov.w	r3, #14336	; 0x3800
   c:	f2c4 0302 	movt	r3, #16386	; 0x4002
  10:	f8c3 1084 	str.w	r1, [r3, #132]	; 0x84
C:\STM32F4\MyProjects\R7_FrequencyCounter/stm32f4xx_rcc.c:492
}
  14:	4770      	bx	lr
  16:	bf00      	nop

Disassembly of section .text.RCC_PLLI2SCmd:

00000000 <RCC_PLLI2SCmd>:
RCC_PLLI2SCmd():
C:\STM32F4\MyProjects\R7_FrequencyCounter/stm32f4xx_rcc.c:504
  */
void RCC_PLLI2SCmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  *(__IO uint32_t *) CR_PLLI2SON_BB = (uint32_t)NewState;
   0:	f04f 0368 	mov.w	r3, #104	; 0x68
   4:	f2c4 2347 	movt	r3, #16967	; 0x4247
   8:	6018      	str	r0, [r3, #0]
C:\STM32F4\MyProjects\R7_FrequencyCounter/stm32f4xx_rcc.c:505
}
   a:	4770      	bx	lr

Disassembly of section .text.RCC_ClockSecuritySystemCmd:

00000000 <RCC_ClockSecuritySystemCmd>:
RCC_ClockSecuritySystemCmd():
C:\STM32F4\MyProjects\R7_FrequencyCounter/stm32f4xx_rcc.c:522
  */
void RCC_ClockSecuritySystemCmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  *(__IO uint32_t *) CR_CSSON_BB = (uint32_t)NewState;
   0:	f04f 034c 	mov.w	r3, #76	; 0x4c
   4:	f2c4 2347 	movt	r3, #16967	; 0x4247
   8:	6018      	str	r0, [r3, #0]
C:\STM32F4\MyProjects\R7_FrequencyCounter/stm32f4xx_rcc.c:523
}
   a:	4770      	bx	lr

Disassembly of section .text.RCC_MCO1Config:

00000000 <RCC_MCO1Config>:
RCC_MCO1Config():
C:\STM32F4\MyProjects\R7_FrequencyCounter/stm32f4xx_rcc.c:551
  
  /* Check the parameters */
  assert_param(IS_RCC_MCO1SOURCE(RCC_MCO1Source));
  assert_param(IS_RCC_MCO1DIV(RCC_MCO1Div));  

  tmpreg = RCC->CFGR;
   0:	f44f 5360 	mov.w	r3, #14336	; 0x3800
   4:	f2c4 0302 	movt	r3, #16386	; 0x4002
   8:	689a      	ldr	r2, [r3, #8]
C:\STM32F4\MyProjects\R7_FrequencyCounter/stm32f4xx_rcc.c:554

  /* Clear MCO1[1:0] and MCO1PRE[2:0] bits */
  tmpreg &= CFGR_MCO1_RESET_MASK;
   a:	f022 62ec 	bic.w	r2, r2, #123731968	; 0x7600000
C:\STM32F4\MyProjects\R7_FrequencyCounter/stm32f4xx_rcc.c:557

  /* Select MCO1 clock source and prescaler */
  tmpreg |= RCC_MCO1Source | RCC_MCO1Div;
   e:	ea40 0202 	orr.w	r2, r0, r2
  12:	430a      	orrs	r2, r1
C:\STM32F4\MyProjects\R7_FrequencyCounter/stm32f4xx_rcc.c:560

  /* Store the new value */
  RCC->CFGR = tmpreg;  
  14:	609a      	str	r2, [r3, #8]
C:\STM32F4\MyProjects\R7_FrequencyCounter/stm32f4xx_rcc.c:561
}
  16:	4770      	bx	lr

Disassembly of section .text.RCC_MCO2Config:

00000000 <RCC_MCO2Config>:
RCC_MCO2Config():
C:\STM32F4\MyProjects\R7_FrequencyCounter/stm32f4xx_rcc.c:589
  
  /* Check the parameters */
  assert_param(IS_RCC_MCO2SOURCE(RCC_MCO2Source));
  assert_param(IS_RCC_MCO2DIV(RCC_MCO2Div));
  
  tmpreg = RCC->CFGR;
   0:	f44f 5360 	mov.w	r3, #14336	; 0x3800
   4:	f2c4 0302 	movt	r3, #16386	; 0x4002
   8:	689a      	ldr	r2, [r3, #8]
C:\STM32F4\MyProjects\R7_FrequencyCounter/stm32f4xx_rcc.c:592
  
  /* Clear MCO2 and MCO2PRE[2:0] bits */
  tmpreg &= CFGR_MCO2_RESET_MASK;
   a:	f022 4278 	bic.w	r2, r2, #4160749568	; 0xf8000000
C:\STM32F4\MyProjects\R7_FrequencyCounter/stm32f4xx_rcc.c:595

  /* Select MCO2 clock source and prescaler */
  tmpreg |= RCC_MCO2Source | RCC_MCO2Div;
   e:	ea40 0202 	orr.w	r2, r0, r2
  12:	430a      	orrs	r2, r1
C:\STM32F4\MyProjects\R7_FrequencyCounter/stm32f4xx_rcc.c:598

  /* Store the new value */
  RCC->CFGR = tmpreg;  
  14:	609a      	str	r2, [r3, #8]
C:\STM32F4\MyProjects\R7_FrequencyCounter/stm32f4xx_rcc.c:599
}
  16:	4770      	bx	lr

Disassembly of section .text.RCC_SYSCLKConfig:

00000000 <RCC_SYSCLKConfig>:
RCC_SYSCLKConfig():
C:\STM32F4\MyProjects\R7_FrequencyCounter/stm32f4xx_rcc.c:694
  uint32_t tmpreg = 0;

  /* Check the parameters */
  assert_param(IS_RCC_SYSCLK_SOURCE(RCC_SYSCLKSource));

  tmpreg = RCC->CFGR;
   0:	f44f 5360 	mov.w	r3, #14336	; 0x3800
   4:	f2c4 0302 	movt	r3, #16386	; 0x4002
   8:	689a      	ldr	r2, [r3, #8]
C:\STM32F4\MyProjects\R7_FrequencyCounter/stm32f4xx_rcc.c:697

  /* Clear SW[1:0] bits */
  tmpreg &= ~RCC_CFGR_SW;
   a:	f022 0203 	bic.w	r2, r2, #3
C:\STM32F4\MyProjects\R7_FrequencyCounter/stm32f4xx_rcc.c:700

  /* Set SW[1:0] bits according to RCC_SYSCLKSource value */
  tmpreg |= RCC_SYSCLKSource;
   e:	ea40 0202 	orr.w	r2, r0, r2
C:\STM32F4\MyProjects\R7_FrequencyCounter/stm32f4xx_rcc.c:703

  /* Store the new value */
  RCC->CFGR = tmpreg;
  12:	609a      	str	r2, [r3, #8]
C:\STM32F4\MyProjects\R7_FrequencyCounter/stm32f4xx_rcc.c:704
}
  14:	4770      	bx	lr
  16:	bf00      	nop

Disassembly of section .text.RCC_GetSYSCLKSource:

00000000 <RCC_GetSYSCLKSource>:
RCC_GetSYSCLKSource():
C:\STM32F4\MyProjects\R7_FrequencyCounter/stm32f4xx_rcc.c:717
  *              - 0x04: HSE used as system clock
  *              - 0x08: PLL used as system clock
  */
uint8_t RCC_GetSYSCLKSource(void)
{
  return ((uint8_t)(RCC->CFGR & RCC_CFGR_SWS));
   0:	f44f 5360 	mov.w	r3, #14336	; 0x3800
   4:	f2c4 0302 	movt	r3, #16386	; 0x4002
   8:	6898      	ldr	r0, [r3, #8]
C:\STM32F4\MyProjects\R7_FrequencyCounter/stm32f4xx_rcc.c:718
}
   a:	f000 000c 	and.w	r0, r0, #12
   e:	4770      	bx	lr

Disassembly of section .text.RCC_HCLKConfig:

00000000 <RCC_HCLKConfig>:
RCC_HCLKConfig():
C:\STM32F4\MyProjects\R7_FrequencyCounter/stm32f4xx_rcc.c:747
  uint32_t tmpreg = 0;
  
  /* Check the parameters */
  assert_param(IS_RCC_HCLK(RCC_SYSCLK));

  tmpreg = RCC->CFGR;
   0:	f44f 5360 	mov.w	r3, #14336	; 0x3800
   4:	f2c4 0302 	movt	r3, #16386	; 0x4002
   8:	689a      	ldr	r2, [r3, #8]
C:\STM32F4\MyProjects\R7_FrequencyCounter/stm32f4xx_rcc.c:750

  /* Clear HPRE[3:0] bits */
  tmpreg &= ~RCC_CFGR_HPRE;
   a:	f022 02f0 	bic.w	r2, r2, #240	; 0xf0
C:\STM32F4\MyProjects\R7_FrequencyCounter/stm32f4xx_rcc.c:753

  /* Set HPRE[3:0] bits according to RCC_SYSCLK value */
  tmpreg |= RCC_SYSCLK;
   e:	ea40 0202 	orr.w	r2, r0, r2
C:\STM32F4\MyProjects\R7_FrequencyCounter/stm32f4xx_rcc.c:756

  /* Store the new value */
  RCC->CFGR = tmpreg;
  12:	609a      	str	r2, [r3, #8]
C:\STM32F4\MyProjects\R7_FrequencyCounter/stm32f4xx_rcc.c:757
}
  14:	4770      	bx	lr
  16:	bf00      	nop

Disassembly of section .text.RCC_PCLK1Config:

00000000 <RCC_PCLK1Config>:
RCC_PCLK1Config():
C:\STM32F4\MyProjects\R7_FrequencyCounter/stm32f4xx_rcc.c:779
  uint32_t tmpreg = 0;

  /* Check the parameters */
  assert_param(IS_RCC_PCLK(RCC_HCLK));

  tmpreg = RCC->CFGR;
   0:	f44f 5360 	mov.w	r3, #14336	; 0x3800
   4:	f2c4 0302 	movt	r3, #16386	; 0x4002
   8:	689a      	ldr	r2, [r3, #8]
C:\STM32F4\MyProjects\R7_FrequencyCounter/stm32f4xx_rcc.c:782

  /* Clear PPRE1[2:0] bits */
  tmpreg &= ~RCC_CFGR_PPRE1;
   a:	f422 52e0 	bic.w	r2, r2, #7168	; 0x1c00
C:\STM32F4\MyProjects\R7_FrequencyCounter/stm32f4xx_rcc.c:785

  /* Set PPRE1[2:0] bits according to RCC_HCLK value */
  tmpreg |= RCC_HCLK;
   e:	ea40 0202 	orr.w	r2, r0, r2
C:\STM32F4\MyProjects\R7_FrequencyCounter/stm32f4xx_rcc.c:788

  /* Store the new value */
  RCC->CFGR = tmpreg;
  12:	609a      	str	r2, [r3, #8]
C:\STM32F4\MyProjects\R7_FrequencyCounter/stm32f4xx_rcc.c:789
}
  14:	4770      	bx	lr
  16:	bf00      	nop

Disassembly of section .text.RCC_PCLK2Config:

00000000 <RCC_PCLK2Config>:
RCC_PCLK2Config():
C:\STM32F4\MyProjects\R7_FrequencyCounter/stm32f4xx_rcc.c:810
  uint32_t tmpreg = 0;

  /* Check the parameters */
  assert_param(IS_RCC_PCLK(RCC_HCLK));

  tmpreg = RCC->CFGR;
   0:	f44f 5360 	mov.w	r3, #14336	; 0x3800
   4:	f2c4 0302 	movt	r3, #16386	; 0x4002
   8:	689a      	ldr	r2, [r3, #8]
C:\STM32F4\MyProjects\R7_FrequencyCounter/stm32f4xx_rcc.c:813

  /* Clear PPRE2[2:0] bits */
  tmpreg &= ~RCC_CFGR_PPRE2;
   a:	f422 4260 	bic.w	r2, r2, #57344	; 0xe000
C:\STM32F4\MyProjects\R7_FrequencyCounter/stm32f4xx_rcc.c:816

  /* Set PPRE2[2:0] bits according to RCC_HCLK value */
  tmpreg |= RCC_HCLK << 3;
   e:	ea42 02c0 	orr.w	r2, r2, r0, lsl #3
C:\STM32F4\MyProjects\R7_FrequencyCounter/stm32f4xx_rcc.c:819

  /* Store the new value */
  RCC->CFGR = tmpreg;
  12:	609a      	str	r2, [r3, #8]
C:\STM32F4\MyProjects\R7_FrequencyCounter/stm32f4xx_rcc.c:820
}
  14:	4770      	bx	lr
  16:	bf00      	nop

Disassembly of section .text.RCC_GetClocksFreq:

00000000 <RCC_GetClocksFreq>:
RCC_GetClocksFreq():
C:\STM32F4\MyProjects\R7_FrequencyCounter/stm32f4xx_rcc.c:856
  *         configuration based on this function will be incorrect.
  *    
  * @retval None
  */
void RCC_GetClocksFreq(RCC_ClocksTypeDef* RCC_Clocks)
{
   0:	b410      	push	{r4}
C:\STM32F4\MyProjects\R7_FrequencyCounter/stm32f4xx_rcc.c:860
  uint32_t tmp = 0, presc = 0, pllvco = 0, pllp = 2, pllsource = 0, pllm = 2;

  /* Get SYSCLK source -------------------------------------------------------*/
  tmp = RCC->CFGR & RCC_CFGR_SWS;
   2:	f44f 5360 	mov.w	r3, #14336	; 0x3800
   6:	f2c4 0302 	movt	r3, #16386	; 0x4002
   a:	689b      	ldr	r3, [r3, #8]
   c:	f003 030c 	and.w	r3, r3, #12
C:\STM32F4\MyProjects\R7_FrequencyCounter/stm32f4xx_rcc.c:862

  switch (tmp)
  10:	2b04      	cmp	r3, #4
C:\STM32F4\MyProjects\R7_FrequencyCounter/stm32f4xx_rcc.c:868
  {
    case 0x00:  /* HSI used as system clock source */
      RCC_Clocks->SYSCLK_Frequency = HSI_VALUE;
      break;
    case 0x04:  /* HSE used as system clock  source */
      RCC_Clocks->SYSCLK_Frequency = HSE_VALUE;
  12:	bf02      	ittt	eq
  14:	f44f 5390 	moveq.w	r3, #4608	; 0x1200
  18:	f2c0 037a 	movteq	r3, #122	; 0x7a
  1c:	6003      	streq	r3, [r0, #0]
C:\STM32F4\MyProjects\R7_FrequencyCounter/stm32f4xx_rcc.c:862
  uint32_t tmp = 0, presc = 0, pllvco = 0, pllp = 2, pllsource = 0, pllm = 2;

  /* Get SYSCLK source -------------------------------------------------------*/
  tmp = RCC->CFGR & RCC_CFGR_SWS;

  switch (tmp)
  1e:	d03a      	beq.n	96 <RCC_GetClocksFreq+0x96>
  20:	2b08      	cmp	r3, #8
  22:	d006      	beq.n	32 <RCC_GetClocksFreq+0x32>
  24:	bb93      	cbnz	r3, 8c <RCC_GetClocksFreq+0x8c>
C:\STM32F4\MyProjects\R7_FrequencyCounter/stm32f4xx_rcc.c:865
  {
    case 0x00:  /* HSI used as system clock source */
      RCC_Clocks->SYSCLK_Frequency = HSI_VALUE;
  26:	f44f 5310 	mov.w	r3, #9216	; 0x2400
  2a:	f2c0 03f4 	movt	r3, #244	; 0xf4
  2e:	6003      	str	r3, [r0, #0]
C:\STM32F4\MyProjects\R7_FrequencyCounter/stm32f4xx_rcc.c:866
      break;
  30:	e031      	b.n	96 <RCC_GetClocksFreq+0x96>
C:\STM32F4\MyProjects\R7_FrequencyCounter/stm32f4xx_rcc.c:875
    case 0x08:  /* PLL used as system clock  source */

      /* PLL_VCO = (HSE_VALUE or HSI_VALUE / PLLM) * PLLN
         SYSCLK = PLL_VCO / PLLP
         */    
      pllsource = (RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) >> 22;
  32:	f44f 5360 	mov.w	r3, #14336	; 0x3800
  36:	f2c4 0302 	movt	r3, #16386	; 0x4002
  3a:	685c      	ldr	r4, [r3, #4]
C:\STM32F4\MyProjects\R7_FrequencyCounter/stm32f4xx_rcc.c:876
      pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
  3c:	685a      	ldr	r2, [r3, #4]
  3e:	f002 023f 	and.w	r2, r2, #63	; 0x3f
C:\STM32F4\MyProjects\R7_FrequencyCounter/stm32f4xx_rcc.c:878
      
      if (pllsource != 0)
  42:	f414 0f80 	tst.w	r4, #4194304	; 0x400000
C:\STM32F4\MyProjects\R7_FrequencyCounter/stm32f4xx_rcc.c:881
      {
        /* HSE used as PLL clock source */
        pllvco = (HSE_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6);
  46:	f44f 5360 	mov.w	r3, #14336	; 0x3800
  4a:	f2c4 0302 	movt	r3, #16386	; 0x4002
  4e:	685b      	ldr	r3, [r3, #4]
  50:	f3c3 1388 	ubfx	r3, r3, #6, #9
  54:	bf19      	ittee	ne
  56:	f44f 5490 	movne.w	r4, #4608	; 0x1200
  5a:	f2c0 047a 	movtne	r4, #122	; 0x7a
C:\STM32F4\MyProjects\R7_FrequencyCounter/stm32f4xx_rcc.c:886
      }
      else
      {
        /* HSI used as PLL clock source */
        pllvco = (HSI_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6);      
  5e:	f44f 5410 	moveq.w	r4, #9216	; 0x2400
  62:	f2c0 04f4 	movteq	r4, #244	; 0xf4
  66:	fbb4 f1f2 	udiv	r1, r4, r2
  6a:	fb01 f103 	mul.w	r1, r1, r3
C:\STM32F4\MyProjects\R7_FrequencyCounter/stm32f4xx_rcc.c:889
      }

      pllp = (((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) >>16) + 1 ) *2;
  6e:	f44f 5360 	mov.w	r3, #14336	; 0x3800
  72:	f2c4 0302 	movt	r3, #16386	; 0x4002
  76:	685a      	ldr	r2, [r3, #4]
  78:	f3c2 4201 	ubfx	r2, r2, #16, #2
  7c:	f102 0201 	add.w	r2, r2, #1
  80:	ea4f 0242 	mov.w	r2, r2, lsl #1
C:\STM32F4\MyProjects\R7_FrequencyCounter/stm32f4xx_rcc.c:890
      RCC_Clocks->SYSCLK_Frequency = pllvco/pllp;
  84:	fbb1 f3f2 	udiv	r3, r1, r2
  88:	6003      	str	r3, [r0, #0]
C:\STM32F4\MyProjects\R7_FrequencyCounter/stm32f4xx_rcc.c:891
      break;
  8a:	e004      	b.n	96 <RCC_GetClocksFreq+0x96>
C:\STM32F4\MyProjects\R7_FrequencyCounter/stm32f4xx_rcc.c:893
    default:
      RCC_Clocks->SYSCLK_Frequency = HSI_VALUE;
  8c:	f44f 5310 	mov.w	r3, #9216	; 0x2400
  90:	f2c0 03f4 	movt	r3, #244	; 0xf4
  94:	6003      	str	r3, [r0, #0]
C:\STM32F4\MyProjects\R7_FrequencyCounter/stm32f4xx_rcc.c:899
      break;
  }
  /* Compute HCLK, PCLK1 and PCLK2 clocks frequencies ------------------------*/

  /* Get HCLK prescaler */
  tmp = RCC->CFGR & RCC_CFGR_HPRE;
  96:	f44f 5260 	mov.w	r2, #14336	; 0x3800
  9a:	f2c4 0202 	movt	r2, #16386	; 0x4002
  9e:	6891      	ldr	r1, [r2, #8]
C:\STM32F4\MyProjects\R7_FrequencyCounter/stm32f4xx_rcc.c:900
  tmp = tmp >> 4;
  a0:	f3c1 1103 	ubfx	r1, r1, #4, #4
C:\STM32F4\MyProjects\R7_FrequencyCounter/stm32f4xx_rcc.c:901
  presc = APBAHBPrescTable[tmp];
  a4:	f240 0300 	movw	r3, #0
  a8:	f2c0 0300 	movt	r3, #0
  ac:	5c59      	ldrb	r1, [r3, r1]
C:\STM32F4\MyProjects\R7_FrequencyCounter/stm32f4xx_rcc.c:903
  /* HCLK clock frequency */
  RCC_Clocks->HCLK_Frequency = RCC_Clocks->SYSCLK_Frequency >> presc;
  ae:	6804      	ldr	r4, [r0, #0]
  b0:	fa24 f101 	lsr.w	r1, r4, r1
  b4:	6041      	str	r1, [r0, #4]
C:\STM32F4\MyProjects\R7_FrequencyCounter/stm32f4xx_rcc.c:906

  /* Get PCLK1 prescaler */
  tmp = RCC->CFGR & RCC_CFGR_PPRE1;
  b6:	6894      	ldr	r4, [r2, #8]
C:\STM32F4\MyProjects\R7_FrequencyCounter/stm32f4xx_rcc.c:907
  tmp = tmp >> 10;
  b8:	f3c4 2482 	ubfx	r4, r4, #10, #3
C:\STM32F4\MyProjects\R7_FrequencyCounter/stm32f4xx_rcc.c:908
  presc = APBAHBPrescTable[tmp];
  bc:	5d1c      	ldrb	r4, [r3, r4]
C:\STM32F4\MyProjects\R7_FrequencyCounter/stm32f4xx_rcc.c:910
  /* PCLK1 clock frequency */
  RCC_Clocks->PCLK1_Frequency = RCC_Clocks->HCLK_Frequency >> presc;
  be:	fa21 f404 	lsr.w	r4, r1, r4
  c2:	6084      	str	r4, [r0, #8]
C:\STM32F4\MyProjects\R7_FrequencyCounter/stm32f4xx_rcc.c:913

  /* Get PCLK2 prescaler */
  tmp = RCC->CFGR & RCC_CFGR_PPRE2;
  c4:	6892      	ldr	r2, [r2, #8]
C:\STM32F4\MyProjects\R7_FrequencyCounter/stm32f4xx_rcc.c:914
  tmp = tmp >> 13;
  c6:	f3c2 3242 	ubfx	r2, r2, #13, #3
C:\STM32F4\MyProjects\R7_FrequencyCounter/stm32f4xx_rcc.c:915
  presc = APBAHBPrescTable[tmp];
  ca:	5c9b      	ldrb	r3, [r3, r2]
C:\STM32F4\MyProjects\R7_FrequencyCounter/stm32f4xx_rcc.c:917
  /* PCLK2 clock frequency */
  RCC_Clocks->PCLK2_Frequency = RCC_Clocks->HCLK_Frequency >> presc;
  cc:	fa21 f103 	lsr.w	r1, r1, r3
  d0:	60c1      	str	r1, [r0, #12]
C:\STM32F4\MyProjects\R7_FrequencyCounter/stm32f4xx_rcc.c:918
}
  d2:	bc10      	pop	{r4}
  d4:	4770      	bx	lr
  d6:	bf00      	nop

Disassembly of section .text.RCC_RTCCLKConfig:

00000000 <RCC_RTCCLKConfig>:
RCC_RTCCLKConfig():
C:\STM32F4\MyProjects\R7_FrequencyCounter/stm32f4xx_rcc.c:987
  uint32_t tmpreg = 0;

  /* Check the parameters */
  assert_param(IS_RCC_RTCCLK_SOURCE(RCC_RTCCLKSource));

  if ((RCC_RTCCLKSource & 0x00000300) == 0x00000300)
   0:	f400 7340 	and.w	r3, r0, #768	; 0x300
   4:	f5b3 7f40 	cmp.w	r3, #768	; 0x300
   8:	d10c      	bne.n	24 <RCC_RTCCLKConfig+0x24>
C:\STM32F4\MyProjects\R7_FrequencyCounter/stm32f4xx_rcc.c:989
  { /* If HSE is selected as RTC clock source, configure HSE division factor for RTC clock */
    tmpreg = RCC->CFGR;
   a:	f44f 5360 	mov.w	r3, #14336	; 0x3800
   e:	f2c4 0302 	movt	r3, #16386	; 0x4002
  12:	6899      	ldr	r1, [r3, #8]
C:\STM32F4\MyProjects\R7_FrequencyCounter/stm32f4xx_rcc.c:992

    /* Clear RTCPRE[4:0] bits */
    tmpreg &= ~RCC_CFGR_RTCPRE;
  14:	f421 11f8 	bic.w	r1, r1, #2031616	; 0x1f0000
C:\STM32F4\MyProjects\R7_FrequencyCounter/stm32f4xx_rcc.c:995

    /* Configure HSE division factor for RTC clock */
    tmpreg |= (RCC_RTCCLKSource & 0xFFFFCFF);
  18:	f020 4270 	bic.w	r2, r0, #4026531840	; 0xf0000000
  1c:	f422 7240 	bic.w	r2, r2, #768	; 0x300
  20:	430a      	orrs	r2, r1
C:\STM32F4\MyProjects\R7_FrequencyCounter/stm32f4xx_rcc.c:998

    /* Store the new value */
    RCC->CFGR = tmpreg;
  22:	609a      	str	r2, [r3, #8]
C:\STM32F4\MyProjects\R7_FrequencyCounter/stm32f4xx_rcc.c:1002
  }
    
  /* Select the RTC clock source */
  RCC->BDCR |= (RCC_RTCCLKSource & 0x00000FFF);
  24:	f44f 5360 	mov.w	r3, #14336	; 0x3800
  28:	f2c4 0302 	movt	r3, #16386	; 0x4002
  2c:	6f1a      	ldr	r2, [r3, #112]	; 0x70
  2e:	ea4f 5000 	mov.w	r0, r0, lsl #20
  32:	ea4f 5010 	mov.w	r0, r0, lsr #20
  36:	4310      	orrs	r0, r2
  38:	6718      	str	r0, [r3, #112]	; 0x70
C:\STM32F4\MyProjects\R7_FrequencyCounter/stm32f4xx_rcc.c:1003
}
  3a:	4770      	bx	lr

Disassembly of section .text.RCC_RTCCLKCmd:

00000000 <RCC_RTCCLKCmd>:
RCC_RTCCLKCmd():
C:\STM32F4\MyProjects\R7_FrequencyCounter/stm32f4xx_rcc.c:1017
void RCC_RTCCLKCmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  *(__IO uint32_t *) BDCR_RTCEN_BB = (uint32_t)NewState;
   0:	f640 633c 	movw	r3, #3644	; 0xe3c
   4:	f2c4 2347 	movt	r3, #16967	; 0x4247
   8:	6018      	str	r0, [r3, #0]
C:\STM32F4\MyProjects\R7_FrequencyCounter/stm32f4xx_rcc.c:1018
}
   a:	4770      	bx	lr

Disassembly of section .text.RCC_BackupResetCmd:

00000000 <RCC_BackupResetCmd>:
RCC_BackupResetCmd():
C:\STM32F4\MyProjects\R7_FrequencyCounter/stm32f4xx_rcc.c:1033
  */
void RCC_BackupResetCmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  *(__IO uint32_t *) BDCR_BDRST_BB = (uint32_t)NewState;
   0:	f44f 6364 	mov.w	r3, #3648	; 0xe40
   4:	f2c4 2347 	movt	r3, #16967	; 0x4247
   8:	6018      	str	r0, [r3, #0]
C:\STM32F4\MyProjects\R7_FrequencyCounter/stm32f4xx_rcc.c:1034
}
   a:	4770      	bx	lr

Disassembly of section .text.RCC_I2SCLKConfig:

00000000 <RCC_I2SCLKConfig>:
RCC_I2SCLKConfig():
C:\STM32F4\MyProjects\R7_FrequencyCounter/stm32f4xx_rcc.c:1051
void RCC_I2SCLKConfig(uint32_t RCC_I2SCLKSource)
{
  /* Check the parameters */
  assert_param(IS_RCC_I2SCLK_SOURCE(RCC_I2SCLKSource));

  *(__IO uint32_t *) CFGR_I2SSRC_BB = RCC_I2SCLKSource;
   0:	f44f 73ae 	mov.w	r3, #348	; 0x15c
   4:	f2c4 2347 	movt	r3, #16967	; 0x4247
   8:	6018      	str	r0, [r3, #0]
C:\STM32F4\MyProjects\R7_FrequencyCounter/stm32f4xx_rcc.c:1052
}
   a:	4770      	bx	lr

Disassembly of section .text.RCC_AHB1PeriphClockCmd:

00000000 <RCC_AHB1PeriphClockCmd>:
RCC_AHB1PeriphClockCmd():
C:\STM32F4\MyProjects\R7_FrequencyCounter/stm32f4xx_rcc.c:1091
{
  /* Check the parameters */
  assert_param(IS_RCC_AHB1_CLOCK_PERIPH(RCC_AHB1Periph));

  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
   0:	b139      	cbz	r1, 12 <RCC_AHB1PeriphClockCmd+0x12>
C:\STM32F4\MyProjects\R7_FrequencyCounter/stm32f4xx_rcc.c:1093
  {
    RCC->AHB1ENR |= RCC_AHB1Periph;
   2:	f44f 5360 	mov.w	r3, #14336	; 0x3800
   6:	f2c4 0302 	movt	r3, #16386	; 0x4002
   a:	6b1a      	ldr	r2, [r3, #48]	; 0x30
   c:	4310      	orrs	r0, r2
   e:	6318      	str	r0, [r3, #48]	; 0x30
  10:	4770      	bx	lr
C:\STM32F4\MyProjects\R7_FrequencyCounter/stm32f4xx_rcc.c:1097
  }
  else
  {
    RCC->AHB1ENR &= ~RCC_AHB1Periph;
  12:	f44f 5360 	mov.w	r3, #14336	; 0x3800
  16:	f2c4 0302 	movt	r3, #16386	; 0x4002
  1a:	6b1a      	ldr	r2, [r3, #48]	; 0x30
  1c:	ea22 0000 	bic.w	r0, r2, r0
  20:	6318      	str	r0, [r3, #48]	; 0x30
  22:	4770      	bx	lr

Disassembly of section .text.RCC_AHB2PeriphClockCmd:

00000000 <RCC_AHB2PeriphClockCmd>:
RCC_AHB2PeriphClockCmd():
C:\STM32F4\MyProjects\R7_FrequencyCounter/stm32f4xx_rcc.c:1123
{
  /* Check the parameters */
  assert_param(IS_RCC_AHB2_PERIPH(RCC_AHB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
   0:	b139      	cbz	r1, 12 <RCC_AHB2PeriphClockCmd+0x12>
C:\STM32F4\MyProjects\R7_FrequencyCounter/stm32f4xx_rcc.c:1125
  {
    RCC->AHB2ENR |= RCC_AHB2Periph;
   2:	f44f 5360 	mov.w	r3, #14336	; 0x3800
   6:	f2c4 0302 	movt	r3, #16386	; 0x4002
   a:	6b5a      	ldr	r2, [r3, #52]	; 0x34
   c:	4310      	orrs	r0, r2
   e:	6358      	str	r0, [r3, #52]	; 0x34
  10:	4770      	bx	lr
C:\STM32F4\MyProjects\R7_FrequencyCounter/stm32f4xx_rcc.c:1129
  }
  else
  {
    RCC->AHB2ENR &= ~RCC_AHB2Periph;
  12:	f44f 5360 	mov.w	r3, #14336	; 0x3800
  16:	f2c4 0302 	movt	r3, #16386	; 0x4002
  1a:	6b5a      	ldr	r2, [r3, #52]	; 0x34
  1c:	ea22 0000 	bic.w	r0, r2, r0
  20:	6358      	str	r0, [r3, #52]	; 0x34
  22:	4770      	bx	lr

Disassembly of section .text.RCC_AHB3PeriphClockCmd:

00000000 <RCC_AHB3PeriphClockCmd>:
RCC_AHB3PeriphClockCmd():
C:\STM32F4\MyProjects\R7_FrequencyCounter/stm32f4xx_rcc.c:1150
{
  /* Check the parameters */
  assert_param(IS_RCC_AHB3_PERIPH(RCC_AHB3Periph));  
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
   0:	b139      	cbz	r1, 12 <RCC_AHB3PeriphClockCmd+0x12>
C:\STM32F4\MyProjects\R7_FrequencyCounter/stm32f4xx_rcc.c:1152
  {
    RCC->AHB3ENR |= RCC_AHB3Periph;
   2:	f44f 5360 	mov.w	r3, #14336	; 0x3800
   6:	f2c4 0302 	movt	r3, #16386	; 0x4002
   a:	6b9a      	ldr	r2, [r3, #56]	; 0x38
   c:	4310      	orrs	r0, r2
   e:	6398      	str	r0, [r3, #56]	; 0x38
  10:	4770      	bx	lr
C:\STM32F4\MyProjects\R7_FrequencyCounter/stm32f4xx_rcc.c:1156
  }
  else
  {
    RCC->AHB3ENR &= ~RCC_AHB3Periph;
  12:	f44f 5360 	mov.w	r3, #14336	; 0x3800
  16:	f2c4 0302 	movt	r3, #16386	; 0x4002
  1a:	6b9a      	ldr	r2, [r3, #56]	; 0x38
  1c:	ea22 0000 	bic.w	r0, r2, r0
  20:	6398      	str	r0, [r3, #56]	; 0x38
  22:	4770      	bx	lr

Disassembly of section .text.RCC_APB1PeriphClockCmd:

00000000 <RCC_APB1PeriphClockCmd>:
RCC_APB1PeriphClockCmd():
C:\STM32F4\MyProjects\R7_FrequencyCounter/stm32f4xx_rcc.c:1200
{
  /* Check the parameters */
  assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));  
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
   0:	b139      	cbz	r1, 12 <RCC_APB1PeriphClockCmd+0x12>
C:\STM32F4\MyProjects\R7_FrequencyCounter/stm32f4xx_rcc.c:1202
  {
    RCC->APB1ENR |= RCC_APB1Periph;
   2:	f44f 5360 	mov.w	r3, #14336	; 0x3800
   6:	f2c4 0302 	movt	r3, #16386	; 0x4002
   a:	6c1a      	ldr	r2, [r3, #64]	; 0x40
   c:	4310      	orrs	r0, r2
   e:	6418      	str	r0, [r3, #64]	; 0x40
  10:	4770      	bx	lr
C:\STM32F4\MyProjects\R7_FrequencyCounter/stm32f4xx_rcc.c:1206
  }
  else
  {
    RCC->APB1ENR &= ~RCC_APB1Periph;
  12:	f44f 5360 	mov.w	r3, #14336	; 0x3800
  16:	f2c4 0302 	movt	r3, #16386	; 0x4002
  1a:	6c1a      	ldr	r2, [r3, #64]	; 0x40
  1c:	ea22 0000 	bic.w	r0, r2, r0
  20:	6418      	str	r0, [r3, #64]	; 0x40
  22:	4770      	bx	lr

Disassembly of section .text.RCC_APB2PeriphClockCmd:

00000000 <RCC_APB2PeriphClockCmd>:
RCC_APB2PeriphClockCmd():
C:\STM32F4\MyProjects\R7_FrequencyCounter/stm32f4xx_rcc.c:1240
{
  /* Check the parameters */
  assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
   0:	b139      	cbz	r1, 12 <RCC_APB2PeriphClockCmd+0x12>
C:\STM32F4\MyProjects\R7_FrequencyCounter/stm32f4xx_rcc.c:1242
  {
    RCC->APB2ENR |= RCC_APB2Periph;
   2:	f44f 5360 	mov.w	r3, #14336	; 0x3800
   6:	f2c4 0302 	movt	r3, #16386	; 0x4002
   a:	6c5a      	ldr	r2, [r3, #68]	; 0x44
   c:	4310      	orrs	r0, r2
   e:	6458      	str	r0, [r3, #68]	; 0x44
  10:	4770      	bx	lr
C:\STM32F4\MyProjects\R7_FrequencyCounter/stm32f4xx_rcc.c:1246
  }
  else
  {
    RCC->APB2ENR &= ~RCC_APB2Periph;
  12:	f44f 5360 	mov.w	r3, #14336	; 0x3800
  16:	f2c4 0302 	movt	r3, #16386	; 0x4002
  1a:	6c5a      	ldr	r2, [r3, #68]	; 0x44
  1c:	ea22 0000 	bic.w	r0, r2, r0
  20:	6458      	str	r0, [r3, #68]	; 0x44
  22:	4770      	bx	lr

Disassembly of section .text.RCC_AHB1PeriphResetCmd:

00000000 <RCC_AHB1PeriphResetCmd>:
RCC_AHB1PeriphResetCmd():
C:\STM32F4\MyProjects\R7_FrequencyCounter/stm32f4xx_rcc.c:1279
{
  /* Check the parameters */
  assert_param(IS_RCC_AHB1_RESET_PERIPH(RCC_AHB1Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
   0:	b139      	cbz	r1, 12 <RCC_AHB1PeriphResetCmd+0x12>
C:\STM32F4\MyProjects\R7_FrequencyCounter/stm32f4xx_rcc.c:1281
  {
    RCC->AHB1RSTR |= RCC_AHB1Periph;
   2:	f44f 5360 	mov.w	r3, #14336	; 0x3800
   6:	f2c4 0302 	movt	r3, #16386	; 0x4002
   a:	691a      	ldr	r2, [r3, #16]
   c:	4310      	orrs	r0, r2
   e:	6118      	str	r0, [r3, #16]
  10:	4770      	bx	lr
C:\STM32F4\MyProjects\R7_FrequencyCounter/stm32f4xx_rcc.c:1285
  }
  else
  {
    RCC->AHB1RSTR &= ~RCC_AHB1Periph;
  12:	f44f 5360 	mov.w	r3, #14336	; 0x3800
  16:	f2c4 0302 	movt	r3, #16386	; 0x4002
  1a:	691a      	ldr	r2, [r3, #16]
  1c:	ea22 0000 	bic.w	r0, r2, r0
  20:	6118      	str	r0, [r3, #16]
  22:	4770      	bx	lr

Disassembly of section .text.RCC_AHB2PeriphResetCmd:

00000000 <RCC_AHB2PeriphResetCmd>:
RCC_AHB2PeriphResetCmd():
C:\STM32F4\MyProjects\R7_FrequencyCounter/stm32f4xx_rcc.c:1308
{
  /* Check the parameters */
  assert_param(IS_RCC_AHB2_PERIPH(RCC_AHB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
   0:	b139      	cbz	r1, 12 <RCC_AHB2PeriphResetCmd+0x12>
C:\STM32F4\MyProjects\R7_FrequencyCounter/stm32f4xx_rcc.c:1310
  {
    RCC->AHB2RSTR |= RCC_AHB2Periph;
   2:	f44f 5360 	mov.w	r3, #14336	; 0x3800
   6:	f2c4 0302 	movt	r3, #16386	; 0x4002
   a:	695a      	ldr	r2, [r3, #20]
   c:	4310      	orrs	r0, r2
   e:	6158      	str	r0, [r3, #20]
  10:	4770      	bx	lr
C:\STM32F4\MyProjects\R7_FrequencyCounter/stm32f4xx_rcc.c:1314
  }
  else
  {
    RCC->AHB2RSTR &= ~RCC_AHB2Periph;
  12:	f44f 5360 	mov.w	r3, #14336	; 0x3800
  16:	f2c4 0302 	movt	r3, #16386	; 0x4002
  1a:	695a      	ldr	r2, [r3, #20]
  1c:	ea22 0000 	bic.w	r0, r2, r0
  20:	6158      	str	r0, [r3, #20]
  22:	4770      	bx	lr

Disassembly of section .text.RCC_AHB3PeriphResetCmd:

00000000 <RCC_AHB3PeriphResetCmd>:
RCC_AHB3PeriphResetCmd():
C:\STM32F4\MyProjects\R7_FrequencyCounter/stm32f4xx_rcc.c:1332
{
  /* Check the parameters */
  assert_param(IS_RCC_AHB3_PERIPH(RCC_AHB3Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
   0:	b139      	cbz	r1, 12 <RCC_AHB3PeriphResetCmd+0x12>
C:\STM32F4\MyProjects\R7_FrequencyCounter/stm32f4xx_rcc.c:1334
  {
    RCC->AHB3RSTR |= RCC_AHB3Periph;
   2:	f44f 5360 	mov.w	r3, #14336	; 0x3800
   6:	f2c4 0302 	movt	r3, #16386	; 0x4002
   a:	699a      	ldr	r2, [r3, #24]
   c:	4310      	orrs	r0, r2
   e:	6198      	str	r0, [r3, #24]
  10:	4770      	bx	lr
C:\STM32F4\MyProjects\R7_FrequencyCounter/stm32f4xx_rcc.c:1338
  }
  else
  {
    RCC->AHB3RSTR &= ~RCC_AHB3Periph;
  12:	f44f 5360 	mov.w	r3, #14336	; 0x3800
  16:	f2c4 0302 	movt	r3, #16386	; 0x4002
  1a:	699a      	ldr	r2, [r3, #24]
  1c:	ea22 0000 	bic.w	r0, r2, r0
  20:	6198      	str	r0, [r3, #24]
  22:	4770      	bx	lr

Disassembly of section .text.RCC_APB1PeriphResetCmd:

00000000 <RCC_APB1PeriphResetCmd>:
RCC_APB1PeriphResetCmd():
C:\STM32F4\MyProjects\R7_FrequencyCounter/stm32f4xx_rcc.c:1378
void RCC_APB1PeriphResetCmd(uint32_t RCC_APB1Periph, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
   0:	b139      	cbz	r1, 12 <RCC_APB1PeriphResetCmd+0x12>
C:\STM32F4\MyProjects\R7_FrequencyCounter/stm32f4xx_rcc.c:1380
  {
    RCC->APB1RSTR |= RCC_APB1Periph;
   2:	f44f 5360 	mov.w	r3, #14336	; 0x3800
   6:	f2c4 0302 	movt	r3, #16386	; 0x4002
   a:	6a1a      	ldr	r2, [r3, #32]
   c:	4310      	orrs	r0, r2
   e:	6218      	str	r0, [r3, #32]
  10:	4770      	bx	lr
C:\STM32F4\MyProjects\R7_FrequencyCounter/stm32f4xx_rcc.c:1384
  }
  else
  {
    RCC->APB1RSTR &= ~RCC_APB1Periph;
  12:	f44f 5360 	mov.w	r3, #14336	; 0x3800
  16:	f2c4 0302 	movt	r3, #16386	; 0x4002
  1a:	6a1a      	ldr	r2, [r3, #32]
  1c:	ea22 0000 	bic.w	r0, r2, r0
  20:	6218      	str	r0, [r3, #32]
  22:	4770      	bx	lr

Disassembly of section .text.RCC_APB2PeriphResetCmd:

00000000 <RCC_APB2PeriphResetCmd>:
RCC_APB2PeriphResetCmd():
C:\STM32F4\MyProjects\R7_FrequencyCounter/stm32f4xx_rcc.c:1414
void RCC_APB2PeriphResetCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_RCC_APB2_RESET_PERIPH(RCC_APB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
   0:	b139      	cbz	r1, 12 <RCC_APB2PeriphResetCmd+0x12>
C:\STM32F4\MyProjects\R7_FrequencyCounter/stm32f4xx_rcc.c:1416
  {
    RCC->APB2RSTR |= RCC_APB2Periph;
   2:	f44f 5360 	mov.w	r3, #14336	; 0x3800
   6:	f2c4 0302 	movt	r3, #16386	; 0x4002
   a:	6a5a      	ldr	r2, [r3, #36]	; 0x24
   c:	4310      	orrs	r0, r2
   e:	6258      	str	r0, [r3, #36]	; 0x24
  10:	4770      	bx	lr
C:\STM32F4\MyProjects\R7_FrequencyCounter/stm32f4xx_rcc.c:1420
  }
  else
  {
    RCC->APB2RSTR &= ~RCC_APB2Periph;
  12:	f44f 5360 	mov.w	r3, #14336	; 0x3800
  16:	f2c4 0302 	movt	r3, #16386	; 0x4002
  1a:	6a5a      	ldr	r2, [r3, #36]	; 0x24
  1c:	ea22 0000 	bic.w	r0, r2, r0
  20:	6258      	str	r0, [r3, #36]	; 0x24
  22:	4770      	bx	lr

Disassembly of section .text.RCC_AHB1PeriphClockLPModeCmd:

00000000 <RCC_AHB1PeriphClockLPModeCmd>:
RCC_AHB1PeriphClockLPModeCmd():
C:\STM32F4\MyProjects\R7_FrequencyCounter/stm32f4xx_rcc.c:1460
void RCC_AHB1PeriphClockLPModeCmd(uint32_t RCC_AHB1Periph, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_RCC_AHB1_LPMODE_PERIPH(RCC_AHB1Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
   0:	b139      	cbz	r1, 12 <RCC_AHB1PeriphClockLPModeCmd+0x12>
C:\STM32F4\MyProjects\R7_FrequencyCounter/stm32f4xx_rcc.c:1462
  {
    RCC->AHB1LPENR |= RCC_AHB1Periph;
   2:	f44f 5360 	mov.w	r3, #14336	; 0x3800
   6:	f2c4 0302 	movt	r3, #16386	; 0x4002
   a:	6d1a      	ldr	r2, [r3, #80]	; 0x50
   c:	4310      	orrs	r0, r2
   e:	6518      	str	r0, [r3, #80]	; 0x50
  10:	4770      	bx	lr
C:\STM32F4\MyProjects\R7_FrequencyCounter/stm32f4xx_rcc.c:1466
  }
  else
  {
    RCC->AHB1LPENR &= ~RCC_AHB1Periph;
  12:	f44f 5360 	mov.w	r3, #14336	; 0x3800
  16:	f2c4 0302 	movt	r3, #16386	; 0x4002
  1a:	6d1a      	ldr	r2, [r3, #80]	; 0x50
  1c:	ea22 0000 	bic.w	r0, r2, r0
  20:	6518      	str	r0, [r3, #80]	; 0x50
  22:	4770      	bx	lr

Disassembly of section .text.RCC_AHB2PeriphClockLPModeCmd:

00000000 <RCC_AHB2PeriphClockLPModeCmd>:
RCC_AHB2PeriphClockLPModeCmd():
C:\STM32F4\MyProjects\R7_FrequencyCounter/stm32f4xx_rcc.c:1492
void RCC_AHB2PeriphClockLPModeCmd(uint32_t RCC_AHB2Periph, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_RCC_AHB2_PERIPH(RCC_AHB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
   0:	b139      	cbz	r1, 12 <RCC_AHB2PeriphClockLPModeCmd+0x12>
C:\STM32F4\MyProjects\R7_FrequencyCounter/stm32f4xx_rcc.c:1494
  {
    RCC->AHB2LPENR |= RCC_AHB2Periph;
   2:	f44f 5360 	mov.w	r3, #14336	; 0x3800
   6:	f2c4 0302 	movt	r3, #16386	; 0x4002
   a:	6d5a      	ldr	r2, [r3, #84]	; 0x54
   c:	4310      	orrs	r0, r2
   e:	6558      	str	r0, [r3, #84]	; 0x54
  10:	4770      	bx	lr
C:\STM32F4\MyProjects\R7_FrequencyCounter/stm32f4xx_rcc.c:1498
  }
  else
  {
    RCC->AHB2LPENR &= ~RCC_AHB2Periph;
  12:	f44f 5360 	mov.w	r3, #14336	; 0x3800
  16:	f2c4 0302 	movt	r3, #16386	; 0x4002
  1a:	6d5a      	ldr	r2, [r3, #84]	; 0x54
  1c:	ea22 0000 	bic.w	r0, r2, r0
  20:	6558      	str	r0, [r3, #84]	; 0x54
  22:	4770      	bx	lr

Disassembly of section .text.RCC_AHB3PeriphClockLPModeCmd:

00000000 <RCC_AHB3PeriphClockLPModeCmd>:
RCC_AHB3PeriphClockLPModeCmd():
C:\STM32F4\MyProjects\R7_FrequencyCounter/stm32f4xx_rcc.c:1519
void RCC_AHB3PeriphClockLPModeCmd(uint32_t RCC_AHB3Periph, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_RCC_AHB3_PERIPH(RCC_AHB3Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
   0:	b139      	cbz	r1, 12 <RCC_AHB3PeriphClockLPModeCmd+0x12>
C:\STM32F4\MyProjects\R7_FrequencyCounter/stm32f4xx_rcc.c:1521
  {
    RCC->AHB3LPENR |= RCC_AHB3Periph;
   2:	f44f 5360 	mov.w	r3, #14336	; 0x3800
   6:	f2c4 0302 	movt	r3, #16386	; 0x4002
   a:	6d9a      	ldr	r2, [r3, #88]	; 0x58
   c:	4310      	orrs	r0, r2
   e:	6598      	str	r0, [r3, #88]	; 0x58
  10:	4770      	bx	lr
C:\STM32F4\MyProjects\R7_FrequencyCounter/stm32f4xx_rcc.c:1525
  }
  else
  {
    RCC->AHB3LPENR &= ~RCC_AHB3Periph;
  12:	f44f 5360 	mov.w	r3, #14336	; 0x3800
  16:	f2c4 0302 	movt	r3, #16386	; 0x4002
  1a:	6d9a      	ldr	r2, [r3, #88]	; 0x58
  1c:	ea22 0000 	bic.w	r0, r2, r0
  20:	6598      	str	r0, [r3, #88]	; 0x58
  22:	4770      	bx	lr

Disassembly of section .text.RCC_APB1PeriphClockLPModeCmd:

00000000 <RCC_APB1PeriphClockLPModeCmd>:
RCC_APB1PeriphClockLPModeCmd():
C:\STM32F4\MyProjects\R7_FrequencyCounter/stm32f4xx_rcc.c:1569
void RCC_APB1PeriphClockLPModeCmd(uint32_t RCC_APB1Periph, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
   0:	b139      	cbz	r1, 12 <RCC_APB1PeriphClockLPModeCmd+0x12>
C:\STM32F4\MyProjects\R7_FrequencyCounter/stm32f4xx_rcc.c:1571
  {
    RCC->APB1LPENR |= RCC_APB1Periph;
   2:	f44f 5360 	mov.w	r3, #14336	; 0x3800
   6:	f2c4 0302 	movt	r3, #16386	; 0x4002
   a:	6e1a      	ldr	r2, [r3, #96]	; 0x60
   c:	4310      	orrs	r0, r2
   e:	6618      	str	r0, [r3, #96]	; 0x60
  10:	4770      	bx	lr
C:\STM32F4\MyProjects\R7_FrequencyCounter/stm32f4xx_rcc.c:1575
  }
  else
  {
    RCC->APB1LPENR &= ~RCC_APB1Periph;
  12:	f44f 5360 	mov.w	r3, #14336	; 0x3800
  16:	f2c4 0302 	movt	r3, #16386	; 0x4002
  1a:	6e1a      	ldr	r2, [r3, #96]	; 0x60
  1c:	ea22 0000 	bic.w	r0, r2, r0
  20:	6618      	str	r0, [r3, #96]	; 0x60
  22:	4770      	bx	lr

Disassembly of section .text.RCC_APB2PeriphClockLPModeCmd:

00000000 <RCC_APB2PeriphClockLPModeCmd>:
RCC_APB2PeriphClockLPModeCmd():
C:\STM32F4\MyProjects\R7_FrequencyCounter/stm32f4xx_rcc.c:1609
void RCC_APB2PeriphClockLPModeCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
   0:	b139      	cbz	r1, 12 <RCC_APB2PeriphClockLPModeCmd+0x12>
C:\STM32F4\MyProjects\R7_FrequencyCounter/stm32f4xx_rcc.c:1611
  {
    RCC->APB2LPENR |= RCC_APB2Periph;
   2:	f44f 5360 	mov.w	r3, #14336	; 0x3800
   6:	f2c4 0302 	movt	r3, #16386	; 0x4002
   a:	6e5a      	ldr	r2, [r3, #100]	; 0x64
   c:	4310      	orrs	r0, r2
   e:	6658      	str	r0, [r3, #100]	; 0x64
  10:	4770      	bx	lr
C:\STM32F4\MyProjects\R7_FrequencyCounter/stm32f4xx_rcc.c:1615
  }
  else
  {
    RCC->APB2LPENR &= ~RCC_APB2Periph;
  12:	f44f 5360 	mov.w	r3, #14336	; 0x3800
  16:	f2c4 0302 	movt	r3, #16386	; 0x4002
  1a:	6e5a      	ldr	r2, [r3, #100]	; 0x64
  1c:	ea22 0000 	bic.w	r0, r2, r0
  20:	6658      	str	r0, [r3, #100]	; 0x64
  22:	4770      	bx	lr

Disassembly of section .text.RCC_ITConfig:

00000000 <RCC_ITConfig>:
RCC_ITConfig():
C:\STM32F4\MyProjects\R7_FrequencyCounter/stm32f4xx_rcc.c:1654
void RCC_ITConfig(uint8_t RCC_IT, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_RCC_IT(RCC_IT));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
   0:	b139      	cbz	r1, 12 <RCC_ITConfig+0x12>
C:\STM32F4\MyProjects\R7_FrequencyCounter/stm32f4xx_rcc.c:1657
  {
    /* Perform Byte access to RCC_CIR[14:8] bits to enable the selected interrupts */
    *(__IO uint8_t *) CIR_BYTE2_ADDRESS |= RCC_IT;
   2:	f643 030d 	movw	r3, #14349	; 0x380d
   6:	f2c4 0302 	movt	r3, #16386	; 0x4002
   a:	781a      	ldrb	r2, [r3, #0]
   c:	4310      	orrs	r0, r2
   e:	7018      	strb	r0, [r3, #0]
  10:	4770      	bx	lr
C:\STM32F4\MyProjects\R7_FrequencyCounter/stm32f4xx_rcc.c:1662
  }
  else
  {
    /* Perform Byte access to RCC_CIR[14:8] bits to disable the selected interrupts */
    *(__IO uint8_t *) CIR_BYTE2_ADDRESS &= (uint8_t)~RCC_IT;
  12:	f643 030d 	movw	r3, #14349	; 0x380d
  16:	f2c4 0302 	movt	r3, #16386	; 0x4002
  1a:	781a      	ldrb	r2, [r3, #0]
  1c:	ea22 0000 	bic.w	r0, r2, r0
  20:	7018      	strb	r0, [r3, #0]
  22:	4770      	bx	lr

Disassembly of section .text.RCC_GetFlagStatus:

00000000 <RCC_GetFlagStatus>:
RCC_GetFlagStatus():
C:\STM32F4\MyProjects\R7_FrequencyCounter/stm32f4xx_rcc.c:1695

  /* Check the parameters */
  assert_param(IS_RCC_FLAG(RCC_FLAG));

  /* Get the RCC register index */
  tmp = RCC_FLAG >> 5;
   0:	ea4f 1350 	mov.w	r3, r0, lsr #5
C:\STM32F4\MyProjects\R7_FrequencyCounter/stm32f4xx_rcc.c:1696
  if (tmp == 1)               /* The flag to check is in CR register */
   4:	2b01      	cmp	r3, #1
   6:	d105      	bne.n	14 <RCC_GetFlagStatus+0x14>
C:\STM32F4\MyProjects\R7_FrequencyCounter/stm32f4xx_rcc.c:1698
  {
    statusreg = RCC->CR;
   8:	f44f 5360 	mov.w	r3, #14336	; 0x3800
   c:	f2c4 0302 	movt	r3, #16386	; 0x4002
  10:	681b      	ldr	r3, [r3, #0]
  12:	e007      	b.n	24 <RCC_GetFlagStatus+0x24>
C:\STM32F4\MyProjects\R7_FrequencyCounter/stm32f4xx_rcc.c:1700
  }
  else if (tmp == 2)          /* The flag to check is in BDCR register */
  14:	2b02      	cmp	r3, #2
C:\STM32F4\MyProjects\R7_FrequencyCounter/stm32f4xx_rcc.c:1702
  {
    statusreg = RCC->BDCR;
  16:	f44f 5360 	mov.w	r3, #14336	; 0x3800
  1a:	f2c4 0302 	movt	r3, #16386	; 0x4002
  1e:	bf0c      	ite	eq
  20:	6f1b      	ldreq	r3, [r3, #112]	; 0x70
C:\STM32F4\MyProjects\R7_FrequencyCounter/stm32f4xx_rcc.c:1706
  }
  else                       /* The flag to check is in CSR register */
  {
    statusreg = RCC->CSR;
  22:	6f5b      	ldrne	r3, [r3, #116]	; 0x74
C:\STM32F4\MyProjects\R7_FrequencyCounter/stm32f4xx_rcc.c:1710
  }

  /* Get the flag position */
  tmp = RCC_FLAG & FLAG_MASK;
  24:	f000 001f 	and.w	r0, r0, #31
C:\STM32F4\MyProjects\R7_FrequencyCounter/stm32f4xx_rcc.c:1711
  if ((statusreg & ((uint32_t)1 << tmp)) != (uint32_t)RESET)
  28:	fa23 f000 	lsr.w	r0, r3, r0
C:\STM32F4\MyProjects\R7_FrequencyCounter/stm32f4xx_rcc.c:1721
  {
    bitstatus = RESET;
  }
  /* Return the flag status */
  return bitstatus;
}
  2c:	f000 0001 	and.w	r0, r0, #1
  30:	4770      	bx	lr
  32:	bf00      	nop

Disassembly of section .text.RCC_WaitForHSEStartUp:

00000000 <RCC_WaitForHSEStartUp>:
RCC_WaitForHSEStartUp():
C:\STM32F4\MyProjects\R7_FrequencyCounter/stm32f4xx_rcc.c:262
  * @retval An ErrorStatus enumeration value:
  *          - SUCCESS: HSE oscillator is stable and ready to use
  *          - ERROR: HSE oscillator not yet ready
  */
ErrorStatus RCC_WaitForHSEStartUp(void)
{
   0:	b510      	push	{r4, lr}
   2:	b082      	sub	sp, #8
C:\STM32F4\MyProjects\R7_FrequencyCounter/stm32f4xx_rcc.c:263
  __IO uint32_t startupcounter = 0;
   4:	f04f 0300 	mov.w	r3, #0
   8:	9301      	str	r3, [sp, #4]
C:\STM32F4\MyProjects\R7_FrequencyCounter/stm32f4xx_rcc.c:269
  ErrorStatus status = ERROR;
  FlagStatus hsestatus = RESET;
  /* Wait till HSE is ready and if Time out is reached exit */
  do
  {
    hsestatus = RCC_GetFlagStatus(RCC_FLAG_HSERDY);
   a:	f04f 0431 	mov.w	r4, #49	; 0x31
   e:	4620      	mov	r0, r4
  10:	f7ff fffe 	bl	0 <RCC_WaitForHSEStartUp>
C:\STM32F4\MyProjects\R7_FrequencyCounter/stm32f4xx_rcc.c:270
    startupcounter++;
  14:	9b01      	ldr	r3, [sp, #4]
  16:	f103 0301 	add.w	r3, r3, #1
  1a:	9301      	str	r3, [sp, #4]
C:\STM32F4\MyProjects\R7_FrequencyCounter/stm32f4xx_rcc.c:271
  } while((startupcounter != HSE_STARTUP_TIMEOUT) && (hsestatus == RESET));
  1c:	9b01      	ldr	r3, [sp, #4]
  1e:	f5b3 6fa0 	cmp.w	r3, #1280	; 0x500
  22:	d001      	beq.n	28 <RCC_WaitForHSEStartUp+0x28>
  24:	2800      	cmp	r0, #0
  26:	d0f2      	beq.n	e <RCC_WaitForHSEStartUp+0xe>
C:\STM32F4\MyProjects\R7_FrequencyCounter/stm32f4xx_rcc.c:273

  if (RCC_GetFlagStatus(RCC_FLAG_HSERDY) != RESET)
  28:	f04f 0031 	mov.w	r0, #49	; 0x31
  2c:	f7ff fffe 	bl	0 <RCC_WaitForHSEStartUp>
C:\STM32F4\MyProjects\R7_FrequencyCounter/stm32f4xx_rcc.c:282
  else
  {
    status = ERROR;
  }
  return (status);
}
  30:	3800      	subs	r0, #0
  32:	bf18      	it	ne
  34:	2001      	movne	r0, #1
  36:	b002      	add	sp, #8
  38:	bd10      	pop	{r4, pc}
  3a:	bf00      	nop

Disassembly of section .text.RCC_ClearFlag:

00000000 <RCC_ClearFlag>:
RCC_ClearFlag():
C:\STM32F4\MyProjects\R7_FrequencyCounter/stm32f4xx_rcc.c:1733
  * @retval None
  */
void RCC_ClearFlag(void)
{
  /* Set RMVF bit to clear the reset flags */
  RCC->CSR |= RCC_CSR_RMVF;
   0:	f44f 5360 	mov.w	r3, #14336	; 0x3800
   4:	f2c4 0302 	movt	r3, #16386	; 0x4002
   8:	6f5a      	ldr	r2, [r3, #116]	; 0x74
   a:	f042 7280 	orr.w	r2, r2, #16777216	; 0x1000000
   e:	675a      	str	r2, [r3, #116]	; 0x74
C:\STM32F4\MyProjects\R7_FrequencyCounter/stm32f4xx_rcc.c:1734
}
  10:	4770      	bx	lr
  12:	bf00      	nop

Disassembly of section .text.RCC_GetITStatus:

00000000 <RCC_GetITStatus>:
RCC_GetITStatus():
C:\STM32F4\MyProjects\R7_FrequencyCounter/stm32f4xx_rcc.c:1757

  /* Check the parameters */
  assert_param(IS_RCC_GET_IT(RCC_IT));

  /* Check the status of the specified RCC interrupt */
  if ((RCC->CIR & RCC_IT) != (uint32_t)RESET)
   0:	f44f 5360 	mov.w	r3, #14336	; 0x3800
   4:	f2c4 0302 	movt	r3, #16386	; 0x4002
   8:	68db      	ldr	r3, [r3, #12]
C:\STM32F4\MyProjects\R7_FrequencyCounter/stm32f4xx_rcc.c:1759
  {
    bitstatus = SET;
   a:	4218      	tst	r0, r3
C:\STM32F4\MyProjects\R7_FrequencyCounter/stm32f4xx_rcc.c:1767
  {
    bitstatus = RESET;
  }
  /* Return the RCC_IT status */
  return  bitstatus;
}
   c:	bf0c      	ite	eq
   e:	2000      	moveq	r0, #0
  10:	2001      	movne	r0, #1
  12:	4770      	bx	lr

Disassembly of section .text.RCC_ClearITPendingBit:

00000000 <RCC_ClearITPendingBit>:
RCC_ClearITPendingBit():
C:\STM32F4\MyProjects\R7_FrequencyCounter/stm32f4xx_rcc.c:1789
  /* Check the parameters */
  assert_param(IS_RCC_CLEAR_IT(RCC_IT));

  /* Perform Byte access to RCC_CIR[23:16] bits to clear the selected interrupt
     pending bits */
  *(__IO uint8_t *) CIR_BYTE3_ADDRESS = RCC_IT;
   0:	f643 030e 	movw	r3, #14350	; 0x380e
   4:	f2c4 0302 	movt	r3, #16386	; 0x4002
   8:	7018      	strb	r0, [r3, #0]
C:\STM32F4\MyProjects\R7_FrequencyCounter/stm32f4xx_rcc.c:1790
}
   a:	4770      	bx	lr
