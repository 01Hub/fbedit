
	GY-272 3-Axis HMC5883L Compass Module (component side up).
	---------------------------------------------------------


	 -------------------------------------------
	|                                           |
	|                                           |
	|                                           |
	|                                           |
	|                                           |
	|                                           |
	|                                           |
	|                     Y                     |
	|                     |                     |
	|                     |                     |
	|                     |                     |
	|                     |                     |
	|                     |                     |
	|                     |                     |
	|                     O ---------- X        |
	|                   Z                       |
	|                                           |
	|                                           |
	|                                           |
	|                                           |
	|                                           |
	|                                           |
	|                                           |
	|                                           |
	|                                           |
	|                                           |
	|                                           |
	|     o       o       o       o       o     |
	|     1       2       3       4       5     |
	|                                           |
	 -------------------------------------------

	1. DRDY			PB5
	2. SDA			PB9
	3. SCL			PB8
	4. GND
	5. +5V

	Heading = (180 * (atan2(-1 * y, x) / pi) + 180

	STM32F4 Discovery Accelerometer LIS302DL
	---------------------------------------------------------

	 ------------------------
	|                         |
	|   o                     |
	|             X           |
	|             |           |
	|             |           |
	|             |           |
	|             |           |
	|     Y ------o           |
	|              Z          |
	|                         |
	|                         |
	|                         |
	|                         |
	|                         |
	|                         |
	|                         |
	|                         |
	 ------------------------

	Pitch (O-) = arctan(Ax / sqrt(Ay^2+Az^2))
	Roll (O|)  = arctan(Ay / sqrt(Ax^2+Az^2))

	From :
	http://diy.powet.eu/2011/03/19/tilt-compensation-azimuth-pitch-le-roll/?lang=en

	Horizontal vector :
	xh = x*cos(theta) + y*sin(phi) - z*cos(theta)*sin(theta)

	Vertical vector :
	yh = y*cos(phi) + z*sin(phi)

	Heading :
	arctan(-yh / xh)

KetilO



/* LSM303DLH Example Code
    LSM303 Breakout ---------- Arduino
         Vin                   5V
         GND                   GND
         SDA                   A4
         SCL                   A5
*/#include <Wire.h>
#include <math.h>

#define SCALE 2  // accel full-scale, should be 2, 4, or 8

/* LSM303 Address definitions */
#define LSM303_MAG  0x1E  // assuming SA0 grounded
#define LSM303_ACC  0x18  // assuming SA0 grounded

#define X 0
#define Y 1
#define Z 2

/* LSM303 Register definitions */
#define CTRL_REG1_A 0x20
#define CTRL_REG2_A 0x21
#define CTRL_REG3_A 0x22
#define CTRL_REG4_A 0x23
#define CTRL_REG5_A 0x24
#define HP_FILTER_RESET_A 0x25
#define REFERENCE_A 0x26
#define STATUS_REG_A 0x27
#define OUT_X_L_A 0x28
#define OUT_X_H_A 0x29
#define OUT_Y_L_A 0x2A
#define OUT_Y_H_A 0x2B
#define OUT_Z_L_A 0x2C
#define OUT_Z_H_A 0x2D
#define INT1_CFG_A 0x30
#define INT1_SOURCE_A 0x31
#define INT1_THS_A 0x32
#define INT1_DURATION_A 0x33
#define CRA_REG_M 0x00
#define CRB_REG_M 0x01
#define MR_REG_M 0x02
#define OUT_X_H_M 0x03
#define OUT_X_L_M 0x04
#define OUT_Y_H_M 0x05
#define OUT_Y_L_M 0x06
#define OUT_Z_H_M 0x07
#define OUT_Z_L_M 0x08
#define SR_REG_M 0x09
#define IRA_REG_M 0x0A
#define IRB_REG_M 0x0B
#define IRC_REG_M 0x0C

/* Global variables */
int accel[3];  // we'll store the raw acceleration values here
int mag[3];  // raw magnetometer values stored here
float realAccel[3];  // calculated acceleration values here

void setup()
{
  Serial.begin(9600);  // Serial is used for debugging
  Wire.begin();  // Start up I2C, required for LSM303 communication
  initLSM303(SCALE);  // Initialize the LSM303, using a SCALE full-scale range
}
void loop()
{
  getLSM303_accel(accel);  // get the acceleration values and store them in the accel array
  while(!(LSM303_read(SR_REG_M) & 0x01))
    ;  // wait for the magnetometer readings to be ready
  getLSM303_mag(mag);  // get the magnetometer values, store them in mag
  //printValues(mag, accel);  // print the raw accel and mag values, good debugging
  for (int i=0; i<3; i++)
    realAccel[i] = accel[i] / pow(2, 15) * SCALE;  // calculate real acceleration values, in units of g

  /* print both the level, and tilt-compensated headings below to compare */
  Serial.print(getHeading(mag), 3);  // this only works if the sensor is level
  Serial.print("\t\t");  // print some tabs
  Serial.println(getTiltHeading(mag, realAccel), 3);  // see how awesome tilt compensation is?!
  delay(100);  // delay for serial readability
}
  
void initLSM303(int fs)
{
  LSM303_write(0x27, CTRL_REG1_A);  // 0x27 = normal power mode, all accel axes on
  if ((fs==8)||(fs==4))
    LSM303_write((0x00 | (fs-fs/2-1)<<4), CTRL_REG4_A);  // set full-scale
  else
    LSM303_write(0x00, CTRL_REG4_A);
  LSM303_write(0x14, CRA_REG_M);  // 0x14 = mag 30Hz output rate
  LSM303_write(0x00, MR_REG_M);  // 0x00 = continouous conversion mode}

void printValues(int * magArray, int * accelArray)
{
  /* print out mag and accel arrays all pretty-like */
  Serial.print(accelArray[X], DEC);
  Serial.print("\t");
  Serial.print(accelArray[Y], DEC);
  Serial.print("\t");
  Serial.print(accelArray[Z], DEC);
  Serial.print("\t\t");

  Serial.print(magArray[X], DEC);
  Serial.print("\t");
  Serial.print(magArray[Y], DEC);
  Serial.print("\t");
  Serial.print(magArray[Z], DEC);
  Serial.println();
}

float getHeading(int * magValue)
{
  // see section 1.2 in app note AN3192
  float heading = 180*atan2(magValue[Y], magValue[X])/PI;  // assume pitch, roll are 0

  if (heading <0)
    heading += 360;

   return heading;
}

float getTiltHeading(int * magValue, float * accelValue)
{  // see appendix A in app note AN3192
  float pitch = asin(-accelValue[X]);
  float roll = asin(accelValue[Y]/cos(pitch));

  float xh = magValue[X] * cos(pitch) + magValue[Z] * sin(pitch);
  float yh = magValue[X] * sin(roll) * sin(pitch) + magValue[Y] * cos(roll) - magValue[Z] * sin(roll) * cos(pitch);
  float zh = -magValue[X] * cos(roll) * sin(pitch) + magValue[Y] * sin(roll) + magValue[Z] * cos(roll) * cos(pitch);

  float heading = 180 * atan2(yh, xh)/PI;
  if (yh >= 0)
    return heading;
  else
    return (360 + heading);
}

void getLSM303_mag(int * rawValues)
{
  Wire.beginTransmission(LSM303_MAG);
  Wire.send(OUT_X_H_M);
  Wire.endTransmission();
  Wire.requestFrom(LSM303_MAG, 6);
  for (int i=0; i<3; i++)
    rawValues[i] = (Wire.receive() << 8) | Wire.receive();
}

void getLSM303_accel(int * rawValues)
{
  rawValues[Z] = ((int)LSM303_read(OUT_X_L_A) << 8) | (LSM303_read(OUT_X_H_A));
  rawValues[X] = ((int)LSM303_read(OUT_Y_L_A) << 8) | (LSM303_read(OUT_Y_H_A));
  rawValues[Y] = ((int)LSM303_read(OUT_Z_L_A) << 8) | (LSM303_read(OUT_Z_H_A));
  // had to swap those to right the data with the proper axis
}

byte LSM303_read(byte address)
{
  byte temp;

  if (address >= 0x20)
    Wire.beginTransmission(LSM303_ACC);
  else
    Wire.beginTransmission(LSM303_MAG);

  Wire.send(address);

  if (address >= 0x20)
    Wire.requestFrom(LSM303_ACC, 1);
  else
    Wire.requestFrom(LSM303_MAG, 1);
  while(!Wire.available())
    ;
  temp = Wire.receive();
  Wire.endTransmission();

  return temp;
}

void LSM303_write(byte data, byte address)
{
  if (address >= 0x20)
    Wire.beginTransmission(LSM303_ACC);
  else
    Wire.beginTransmission(LSM303_MAG);

  Wire.send(address);
  Wire.send(data);
  Wire.endTransmission();
} 

**************************************************************************************************************************


/*
HMC5883L_Example.pde - Example sketch for integration with an HMC5883L triple axis magnetomerwe.
Copyright (C) 2011 Love Electronics (loveelectronics.co.uk)

Modified to compensate for nearby ferrous materials that may distort the earth's magnetic field.
Using this appnote from Honeywell for the principle and math
http://www.ssec.honeywell.com/position-sensors/datasheets/sae.pdf
Modified by: Richard Heiliger

This program is free software: you can redistribute it and/or modify
it under the terms of the version 3 GNU General Public License as
published by the Free Software Foundation.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.

*/

// Reference the I2C Library
#include <Wire.h>
// Reference the HMC5883L Compass Library
#include <HMC5883L.h>
#include <EEPROM.h>

// Store our compass as a variable.
HMC5883L compass;
// Record any errors that may occur in the compass.
int error = 0;
MagnetometerRaw magraw;
MagnetometerScaled scaled;
int xScaleFactor;
int yScaleFactor;
int compassXOffset;
int compassYOffset;
float headingDegrees;
int xMax;
int yMax;
int xMin;
int yMin;

// Out setup routine, here we will configure the microcontroller and compass.
void setup()
{
  // Initialize the serial port.
  Serial.begin(9600);

  Serial.println("Starting the I2C interface.");
  Wire.begin(); // Start the I2C interface.

  Serial.println("Constructing new HMC5883L");
  compass = HMC5883L(); // Construct a new HMC5883 compass.
    
  Serial.println("Setting scale to +/- 1.3 Ga");
  error = compass.SetScale(1.3); // Set the scale of the compass.
  if(error != 0) // If there is an error, print it out.
    Serial.println(compass.GetErrorText(error));
  
  Serial.println("Setting measurement mode to continous.");
  error = compass.SetMeasurementMode(Measurement_Continuous); // Set the measurement mode to Continuous
  if(error != 0) // If there is an error, print it out.
    Serial.println(compass.GetErrorText(error));

//run the compensation    
getFerrousCompensation();   
    
}

// Our main program loop.
void loop()
{
    // Retrived the scaled values from the compass (scaled to the configured scale).
  magraw = compass.ReadRawAxis();
  scaled = compass.ReadScaledAxis();
  
  //compensate for compass location, using stored calibration data
  scaled.XAxis = (xScaleFactor * scaled.XAxis) + compassXOffset;
  scaled.YAxis = (yScaleFactor * scaled.YAxis) + compassYOffset;
  
   // Calculate heading when the magnetometer is level, then correct for signs of axis.
  float heading = atan2(scaled.YAxis, scaled.XAxis);
  
  // Once you have your heading, you must then add your 'Declination Angle', which is the 'Error' of the magnetic field in your location.
  // Find yours here: http://www.magnetic-declination.com/
  // Mine is: 2� 37' W, which is 2.617 Degrees, or (which we need) 0.0456752665 radians, I will use 0.0457
  // If you cannot find your Declination, comment out these two lines, your compass will be slightly off.
  
  float declinationAngle = 0.0457;  
  heading += declinationAngle;
  
  // Correct for when signs are reversed.
  if(heading < 0)
    heading += 2*PI;
    
  // Check for wrap due to addition of declination.
  if(heading > 2*PI)
    heading -= 2*PI;
   
  // Convert radians to degrees for readability.
  headingDegrees = heading * 180/M_PI; 
  
  // Output the data via the serial port.
  Output(magraw, scaled, heading, headingDegrees);
  // Normally we would delay the application by 66ms to allow the loop
  // to run at 15Hz (default bandwidth for the HMC5883L).
  // However since we have a long serial out (104ms at 9600) we will let
  // it run at its natural speed.
  // delay(66);
}

// Output the data down the serial port.
void Output(MagnetometerRaw raw, MagnetometerScaled scaled, float heading, float headingDegrees)
{
   Serial.print("Raw:\t");
   Serial.print(raw.XAxis);
   Serial.print("   ");   
   Serial.print(raw.YAxis);
   Serial.print("   ");   
   Serial.print(raw.ZAxis);
   Serial.print("   \tScaled:\t");
   
   Serial.print(scaled.XAxis);
   Serial.print("   ");   
   Serial.print(scaled.YAxis);
   Serial.print("   ");   
   Serial.print(scaled.ZAxis);

   Serial.print("   \tHeading:\t");
   Serial.print(heading);
   Serial.print(" Radians   \t");
   Serial.print(headingDegrees);
   Serial.println(" Degrees   \t");
}


//*********************************************
//output of data, to check raw mag values, scaled mag values, x&y max/min , x&y offsets & scale factor
void calibrationOutput()
{
  //raw magnetometer x&y values
  Serial.print("RawMag x=");
  Serial.print(magraw.XAxis);
  Serial.print(",y=");
  Serial.print(magraw.YAxis);
  Serial.print(" ");
  //mag values scled with gause gain setting  
  Serial.print("ScaledMag x=");
  Serial.print(scaled.XAxis);
  Serial.print(",y=");
  Serial.print(scaled.YAxis);
  Serial.print(" ");  
  //current max min value as calibration proceeds
  Serial.print(" xMax=");
  Serial.print(xMax);
  Serial.print(",yMax=");
  Serial.print(yMax);
  Serial.print(", xMin=");
  Serial.print(xMin);
  Serial.print(", yMin=");
  Serial.println(yMin);

}

//********************************
//calibration data after completed
void calibrationComplete()
{
  //min/max values found
  Serial.print("MaxMin xMax=");
  Serial.print(xMax);
  Serial.print(",yMax=");
  Serial.print(yMax);
  Serial.print(", xMin=");
  Serial.print(xMin);
  Serial.print(", yMin=");
  Serial.print(yMin);
  //calculated offset and scale factors
  Serial.print("xScale=");
  Serial.print(xScaleFactor);
  Serial.print(",yScale=");
  Serial.print(yScaleFactor);
  Serial.print(", XOffset=");
  Serial.print(compassXOffset);
  Serial.print(", YOffset=");
  Serial.print(compassYOffset);  

  

}

/**********************************************************
* Calibrate
*  Performs a chip calibration
*
* @return bool - The calibration result
**********************************************************/
void getFerrousCompensation(void) {
     
      for (int index = 0; index < 16; index++)
      {
          
          Serial.println("SLOWLY ROTATE COMPASS THRU AT LEAST 360 DEGREES");
          Serial.println("COMPENSATION FUNCTION WILL END IN 20 SECONDS");
                 
          //delay(5000);  //wait a couple seconds for operator to get arrow ponted north
          //delayMillis = millis() + 2000;
          for(int x=0;x<100;x++)  //continualy read the raw axis data while waiting for operator to slowly rotate compass to next position
          {
            magraw = compass.ReadRawAxis();
            scaled = compass.ReadScaledAxis();
            compassMaxMin(scaled.XAxis,scaled.YAxis);  //look for max and min values
            calibrationOutput();  //output current data as calibration proceeds
            delay(20);
          }
          
      } 
    calcScaleFactor_Offset();
    calibrationComplete();  //output the resulting values from calibration    
    storeCal();    //save the calculated x & y offset and scale factor
    Serial.println("OFFSET AND SCALE FACTOR STORED IN EEPROM");   
    Serial.println("COMPENSATION FUNCTION COMPLETED");
    
}

//used calibrating hmc5883l compass
//*******************************************************
void compassMaxMin(int xRaw, int yRaw)
{
  if(xRaw>500 || xRaw<-500 || yRaw>500 || yRaw<-500)
    return; //prevent extraneous high readings from messing with calibration
    
  if(xRaw > xMax)
    xMax = xRaw;

  if(xRaw < xMin)
    xMin = xRaw;
  
  if(yRaw > yMax)
    yMax = yRaw;
  
  if(yRaw < yMin)
    yMin = yRaw;
   
}

//*******************************************************************
//calculate the x&y scale factor and offsets for hmc5883l
//compensates for objects around sensor distorting magnetometer values
void calcScaleFactor_Offset()
{
  xScaleFactor = (yMax - yMin)/(xMax - xMin);
  if(xScaleFactor < 1)
    xScaleFactor = 1;

  yScaleFactor = (xMax - xMin)/(yMax - yMin);
  if(yScaleFactor < 1)
    yScaleFactor = 1;

  compassXOffset = ((xMax - xMin)/2 - xMax) * xScaleFactor;
  compassYOffset = ((yMax - yMin)/2 - yMax) * yScaleFactor;
   
}

/*************************************************************************/  
//save calibration data to eeprom
void storeCal(){ 
  //write x & y scale factors and offsets to eeprom  
    EEPROM.write(0,lowByte(compassXOffset));    
    EEPROM.write(1,highByte(compassXOffset));
    
    EEPROM.write(2,lowByte(compassYOffset));    
    EEPROM.write(3,highByte(compassYOffset));
    
    EEPROM.write(4,lowByte(xScaleFactor));    
    EEPROM.write(5,highByte(xScaleFactor));
    
    EEPROM.write(6,lowByte(yScaleFactor));    
    EEPROM.write(7,highByte(yScaleFactor));
     
}

/*************************************************************************/  
//read calibration data from eeprom
void readCal(){
  
  compassXOffset = (EEPROM.read(1) * 256) + EEPROM.read(0);
  compassYOffset = (EEPROM.read(3) * 256) + EEPROM.read(2);
  xScaleFactor = (EEPROM.read(5) * 256) + EEPROM.read(4);
  yScaleFactor = (EEPROM.read(7) * 256) + EEPROM.read(6);
  
}

*************************************************************************************************************************

// Reference the I2C Library
#include <Wire.h>
// Reference the HMC5883L Compass Library
#include <HMC5883L.h>

// Store our compass as a variable.
HMC5883L compass;
// Record any errors that may occur in the compass.
int error = 0;

int accelResult[3];
float timeStep = 0.02;          //20ms. Need a time step value for integration of gyro angle from angle/sec
float biasAccelX, biasAccelY, biasAccelZ;
float pitchAccel = 0;
float rollAccel = 0;

float Xh;
float Yh;
float realHeading;
float pitchAccelXh;
float rollAccelYh;
float XM;
float YM;
float ZM;

unsigned long timer;

//Penjabaran fungsi writeTo sebagai Fungsi untuk writing byte ke alamat device pada I2C
void writeTo(byte device, byte toAddress, byte val) {
  Wire.beginTransmission(device);  
  Wire.write(toAddress);        
  Wire.write(val);        
  Wire.endTransmission();
}

//Penjabaran fungsi readFrom sebagai Fungsi untuk membaca num bytes dari alamat pada device I2C
void readFrom(byte device, byte fromAddress, int num, byte result[]) {
  Wire.beginTransmission(device);
  Wire.write(fromAddress);
  Wire.endTransmission();
  Wire.requestFrom((int)device, num);
  int i = 0;
  while(Wire.available()) {
    result[i] = Wire.read();
    i++;
  }
}


//Fungsi untuk mmebaca nilai Accelerometer
void getAccelerometerReadings(int accelResult[]) {
  byte buffer[6];
  readFrom(0x40,0x02,6,buffer);
  accelResult[0] = (((int)buffer[1]) << 8 ) | buffer[0]; //Yes, byte order different from gyros'
  accelResult[1] = (((int)buffer[3]) << 8 ) | buffer[2];
  accelResult[2] = (((int)buffer[5]) << 8 ) | buffer[4];
}


// Out setup routine, here we will configure the microcontroller and compass.
void setup()
{
  
  int totalAccelXValues = 0;
  int totalAccelYValues = 0;
  int totalAccelZValues = 0;
  int i;
  
  // Initialize the serial port.
  Serial.begin(115200);

  Serial.println("Starting the I2C interface.");
  Wire.begin(); // Start the I2C interface.

  Serial.println("Constructing new HMC5883L");
  compass = HMC5883L(); // Construct a new HMC5883 compass.
    
  Serial.println("Setting scale to +/- 1.3 Ga");
  error = compass.SetScale(1.3); // Set the scale of the compass.
  if(error != 0) // If there is an error, print it out.
    Serial.println(compass.GetErrorText(error));
  
  Serial.println("Setting measurement mode to continous.");
  error = compass.SetMeasurementMode(Measurement_Continuous); // Set the measurement mode to Continuous
  if(error != 0) // If there is an error, print it out.
    Serial.println(compass.GetErrorText(error));
  
  writeTo(0x40,0x10,0xB6); //Soft_reset accelerometer BMA180
  writeTo(0x40,0x0D,0x10); //set fungsi ee_w 
  
  // Determine zero bias for all axes of both sensors by averaging 50 measurements
  delay(100); //wait for gyro to "spin" up
  for (i = 0; i < 50; i += 1) {
    getAccelerometerReadings(accelResult);
    totalAccelXValues += accelResult[0];
    totalAccelYValues += accelResult[1];
    totalAccelZValues += accelResult[2];
    delay(50);
   }
   
  biasAccelX = totalAccelXValues / 50;
  biasAccelY = totalAccelYValues / 50;
  biasAccelZ = (totalAccelZValues / 50) - 256; //Don't compensate gravity away! We would all (float)!
    
}

// Our main program loop.
void loop()
{
  // Retrive the raw values from the compass (not scaled).
  MagnetometerRaw raw = compass.ReadRawAxis();
  // Retrived the scaled values from the compass (scaled to the configured scale).
  MagnetometerScaled scaled = compass.ReadScaledAxis();
  
  // Values are accessed like so:
  int MilliGauss_OnThe_XAxis = scaled.XAxis;// (or YAxis, or ZAxis)

  // Calculate heading when the magnetometer is level, then correct for signs of axis.
  float heading = atan2(scaled.YAxis, scaled.XAxis);
  
  // Once you have your heading, you must then add your 'Declination Angle', which is the 'Error' of the magnetic field in your location.
  // Find yours here: http://www.magnetic-declination.com/
  // Mine is: 2ï¿½ 37' W, which is 2.617 Degrees, or (which we need) 0.0456752665 radians, I will use 0.0457
  // If you cannot find your Declination, comment out these two lines, your compass will be slightly off.
  float declinationAngle = 0.55;
  heading += declinationAngle;
  
  // Correct for when signs are reversed.
  if(heading < 0)
    heading += 2*PI;
    
  // Check for wrap due to addition of declination.
  if(heading > 2*PI)
    heading -= 2*PI;
   
  // Convert radians to degrees for readability.
  float headingDegrees = heading * 180/M_PI; 

  // Output the data via the serial port.
  //Output(raw, scaled, heading, headingDegrees);

  // Normally we would delay the application by 66ms to allow the loop
  // to run at 15Hz (default bandwidth for the HMC5883L).
  // However since we have a long serial out (104ms at 9600) we will let
  // it run at its natural speed.
  // delay(66);
  
  timer = millis(); //get a start value to determine the time the loop takes
  getAccelerometerReadings(accelResult);
  
  pitchAccel = atan2((accelResult[1] - biasAccelY) / 1024, (accelResult[2] - biasAccelZ) / 1024) * 360.0 / (2*PI);
  rollAccel = atan2((accelResult[0] - biasAccelX) / 1024, (accelResult[2] - biasAccelZ) / 1024) * 360.0 / (2*PI);
  
  //---------------Tilt Compensated Begin----------------------------------------
  
  pitchAccelXh = atan2((accelResult[1] - biasAccelY) / 1024, (accelResult[2] - biasAccelZ) / 1024);
  rollAccelYh = atan2((accelResult[0] - biasAccelX) / 1024, (accelResult[2] - biasAccelZ) / 1024);
  
  //pitchAccelXh = constrain(pitchAccelXh, -1.57, 1.57);
  //pitchAccelXh = map(pitchAccelXh, -3.14, 3.14, 0, 6.28);
  
  //rollAccelYh = constrain(rollAccelYh, -1.57, 1.57);
  //rollAccelYh = map(rollAccelYh, -3.14, 3.14, 0, 6.28);
  
  float cos_roll= cos(rollAccelYh);
  float sin_roll = sin(rollAccelYh);
  float cos_pitch = cos(pitchAccelXh);
  float sin_pitch = sin(pitchAccelXh);
  
  XM = scaled.XAxis;
  YM = scaled.YAxis;
  ZM = scaled.ZAxis;
 
  // The tilt compensation algorithem.
  Yh = YM * cos_roll - ZM * sin_roll;
  Xh = XM * cos_pitch + YM * sin_roll * sin_pitch + ZM * cos_roll * sin_pitch;
  
  realHeading = atan2(-Yh, Xh) * 360.0 / (2*PI);
  
  //--------------------Tilt Compensated End--------------------------------------
  
   Serial.print(pitchAccel);
   Serial.print("  pitch \t");   
   Serial.print(rollAccel);
   Serial.print("  roll \t");
   
   //Serial.print(pitchAccelXh);
   //Serial.print("  pitchXH ");   
   //Serial.print(rollAccelYh);
   //Serial.print("  rollYH");
   
   //Serial.print(raw.XAxis);
   //Serial.print("RawX:\t");
   //Serial.print("   ");   
   //Serial.print(raw.YAxis);
   //Serial.print("   ");   
   //Serial.print(raw.ZAxis);
   //Serial.print("   \tScaled:\t");
   
   //Serial.print(scaled.XAxis);
   //Serial.print("  X ");   
   //Serial.print(scaled.YAxis);
   //Serial.print("  Y ");   
   //Serial.print(scaled.ZAxis);
   //Serial.print("  Z ");

   Serial.print(realHeading);
   Serial.print(" DegreeReal  \t");
   
   Serial.print(headingDegrees);
   Serial.println(" Degrees   \t");
   
   delay(200);
   
  //timer = millis() - timer;          //how long did the loop take?
  //timer = (timeStep * 1000) - timer; //how much time to add to the loop to make it last time step msec
  //delay(timer);                                    //make one loop last time step msec
  
}

