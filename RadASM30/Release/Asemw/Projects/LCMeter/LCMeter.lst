
ASEM-51 V1.3                                         Copyright (c) 2002 by W.W. Heinz                                         PAGE 1





       MCS-51 Family Macro Assembler   A S E M - 5 1   V 1.3
       =====================================================



	Source File:	LCMeter.a51
	Object File:	LCMeter.hex
	List File:	LCMeter.lst



 Line  I  Addr  Code            Source

    1:
    2:		N      0040	LCDLINE		EQU	40h				;16 Bytes
    3:		N      0050	FPCHR_OUT	EQU	50h				;Holds addrss to next byte during FP number
				convertion
    4:		N      0051	MODE		EQU	51h
    5:		N      0060	LCF1		EQU	60H				;LC Meter F1
    6:		N      0068	LCF2		EQU	68h				;LC Meter F2
    7:		N      0070	LCF3		EQU	70h				;LC Meter F3
    8:		N      0078	LCCA		EQU	78h				;((F1/F2)^2)-1
    9:		N      0080	LCCB		EQU	80h				;((1/2*Pi*F1)^2)*LCCA
   10:		N      0088	LCCT		EQU	88h				;Temp
   11:		N      0090	MCUSTACK	EQU	90h
   12:		N      00FF	FPSTACK		EQU	0FFh
   13:
   14:		N      0004	MODEMAX		EQU	4
   15:
   16:		N      0000			ORG	0000h
   17:
   18:				;RESET:***********************************************
   19:		N      0000			ORG	0000h
   20:
   21:	  0000	02 08 00			LJMP	START0
   22:				;IE0IRQ:**********************************************
   23:		N      0003			ORG	0003h
   24:	  0003	01 05				AJMP	IE0IRQ
   25:
   26:	  0005	05 51		IE0IRQ:		INC	MODE
   27:	  0007	11 1C				ACALL	SETMODE
   28:	  0009	11 0E				ACALL	DEBOUNCEINT0
   29:	  000B	02 08 2D			LJMP	START
   30:
   31:	  000E	7E 00		DEBOUNCEINT0:	MOV	R6,#00h
   32:	  0010	7F 00				MOV	R7,#00h
   33:	  0012	30 B2 F9	DEBOUNCEINT01:	JNB	P3.2,DEBOUNCEINT0
   34:	  0015	DE FB				DJNZ	R6,DEBOUNCEINT01
   35:	  0017	DF F9				DJNZ	R7,DEBOUNCEINT01
   36:	  0019	C2 89				CLR	IE0
   37:	  001B	32				RETI
   38:
   39:	  001C	E5 51		SETMODE:	MOV	A,MODE
   40:	  001E	B4 05 01			CJNE	A,#MODEMAX+1,SETMODE1
   41:	  0021	E4				CLR	A
   42:	  0022	F5 51		SETMODE1:	MOV	MODE,A

ASEM-51 V1.3                                         Copyright (c) 2002 by W.W. Heinz                                         PAGE 2



 Line  I  Addr  Code            Source

   43:	  0024	FF				MOV	R7,A
   44:	  0025	90 00 43			MOV	DPTR,#MODE0
   45:	  0028	DF 03				DJNZ	R7,SETMODE2
   46:	  002A	90 00 4D			MOV	DPTR,#MODE1
   47:	  002D	DF 03		SETMODE2:	DJNZ	R7,SETMODE3
   48:	  002F	90 00 55			MOV	DPTR,#MODE2
   49:	  0032	DF 03		SETMODE3:	DJNZ	R7,SETMODE4
   50:	  0034	90 00 5D			MOV	DPTR,#MODE3
   51:	  0037	DF 03		SETMODE4:	DJNZ	R7,SETMODE5
   52:	  0039	90 00 67			MOV	DPTR,#MODE4
   53:	  003C	12 0B 84	SETMODE5:	LCALL	LCDCLEAR
   54:	  003F	12 0B AD			LCALL	PRNTCDPTRLCD
   55:	  0042	22				RET
   56:
   57:	  0043	43 61 6C 69	MODE0:		DB	'Calibrate',0
	  0047	62 72 61 74
	  004B	65 00
   58:	  004D	43 20 4D 65	MODE1:		DB	'C Meter',0
	  0051	74 65 72 00
   59:	  0055	4C 20 4D 65	MODE2:		DB 	'L Meter',0
	  0059	74 65 72 00
   60:	  005D	46 72 71 20	MODE3:		DB	'Frq Count',0
	  0061	43 6F 75 6E
	  0065	74 00
   61:	  0067	46 72 71 20	MODE4:		DB	'Frq Count 1GHz',0
	  006B	43 6F 75 6E
	  006F	74 20 31 47
	  0073	48 7A 00
   62:
   63:				$INCLUDE	(FP52INT.a51)
   64: 1			; This is a complete BCD floating point package for the 8051 micro-
   65: 1			; controller. It provides 8 digits of accuracy with exponents that
   66: 1			; range from +127 to -127. The mantissa is in packed BCD, while the
   67: 1			; exponent is expressed in pseudo-twos complement. A ZERO exponent
   68: 1			; is used to express the number ZERO. An exponent value of 80H or
   69: 1			; greater than means the exponent is positive, i.e. 80H = E 0,
   70: 1			; 81H = E+1, 82H = E+2 and so on. If the exponent is 7FH or less,
   71: 1			; the exponent is negative, 7FH = E-1, 7EH = E-2, and so on.
   72: 1			; ALL NUMBERS ARE ASSUMED TO BE NORMALIZED and all results are
   73: 1			; normalized after calculation. A normalized mantissa is >=.10 and
   74: 1			; <=.99999999.
   75: 1			;
   76: 1			; The numbers in memory assumed to be stored as follows:
   77: 1			;
   78: 1			; EXPONENT OF ARGUMENT 2   =   VALUE OF ARG_STACK+FP_NUMBER_SIZE
   79: 1			; SIGN OF ARGUMENT 2       =   VALUE OF ARG_STACK+FP_NUMBER_SIZE-1
   80: 1			; DIGIT 78 OF ARGUMENT 2   =   VALUE OF ARG_STACK+FP_NUMBER_SIZE-2
   81: 1			; DIGIT 56 OF ARGUMENT 2   =   VALUE OF ARG_STACK+FP_NUMBER_SIZE-3
   82: 1			; DIGIT 34 OF ARGUMENT 2   =   VALUE OF ARG_STACK+FP_NUMBER_SIZE-4
   83: 1			; DIGIT 12 OF ARGUMENT 2   =   VALUE OF ARG_STACK+FP_NUMBER_SIZE-5
   84: 1			;
   85: 1			; EXPONENT OF ARGUMENT 1   =   VALUE OF ARG_STACK
   86: 1			; SIGN OF ARGUMENT 1       =   VALUE OF ARG_STACK-1
   87: 1			; DIGIT 78 OF ARGUMENT 1   =   VALUE OF ARG_STACK-2
   88: 1			; DIGIT 56 OF ARGUMENT 1   =   VALUE OF ARG_STACK-3
   89: 1			; DIGIT 34 OF ARGUMENT 1   =   VALUE OF ARG_STACK-4

ASEM-51 V1.3                                         Copyright (c) 2002 by W.W. Heinz                                         PAGE 3



 Line  I  Addr  Code            Source

   90: 1			; DIGIT 12 OF ARGUMENT 1   =   VALUE OF ARG_STACK-5
   91: 1			;
   92: 1			; The operations are performed thusly:
   93: 1			;
   94: 1			; ARG_STACK+FP_NUMBER_SIZE = ARG_STACK+FP_NUMBER_SIZE # ARG_STACK
   95: 1			;
   96: 1			; Which is ARGUMENT 2 = ARGUMENT 2 # ARGUMENT 1
   97: 1			;
   98: 1			; Where # can be ADD, SUBTRACT, MULTIPLY OR DIVIDE.
   99: 1			;
  100: 1			; Note that the stack gets popped after an operation.
  101: 1			;
  102: 1			; The FP_COMP instruction POPS the ARG_STACK TWICE and returns status.
  103: 1			;
  104: 1			;**********************************************************************
  105: 1			;
  106: 1			;**********************************************************************
  107: 1			;
  108: 1			; STATUS ON RETURN - After performing an operation (+, -, *, /)
  109: 1			;                    the accumulator contains the following status
  110: 1			;
  111: 1			; ACCUMULATOR - BIT 0 - FLOATING POINT UNDERFLOW OCCURED
  112: 1			;
  113: 1			;             - BIT 1 - FLOATING POINT OVERFLOW OCCURED
  114: 1			;
  115: 1			;             - BIT 2 - RESULT WAS ZER0
  116: 1			;
  117: 1			;             - BIT 3 - DIVIDE BY ZERO ATTEMPTED
  118: 1			;
  119: 1			;             - BIT 4 - NOT USED, 0 RETURNED
  120: 1			;
  121: 1			;             - BIT 5 - NOT USED, 0 RETURNED
  122: 1			;
  123: 1			;             - BIT 6 - NOT USED, 0 RETURNED
  124: 1			;
  125: 1			;             - BIT 7 - NOT USED, 0 RETURNED
  126: 1			;
  127: 1			; NOTE: When underflow occures, a ZERO result is returned.
  128: 1			;       When overflow or divide by zero occures, a result of
  129: 1			;       .99999999 E+127 is returned and it is up to the user
  130: 1			;       to handle these conditions as needed in the program.
  131: 1			;
  132: 1			; NOTE: The Compare instruction returns F0 = 0 if ARG 1 = ARG 2
  133: 1			;       and returns a CARRY FLAG = 1 if ARG 1 is > ARG 2
  134: 1			;
  135: 1			;***********************************************************************
  136: 1			;
  137: 1
  138: 1			;$NOTABS                  ;expand tabs
  139: 1
  140: 1
  141: 1			CMP MACRO REGISTER,CONSTANT
  142: 1			CJNE	REGISTER,CONSTANT,$+3
  143: 1			ENDM
  144: 1			;***********************************************************************
  145: 1			;

ASEM-51 V1.3                                         Copyright (c) 2002 by W.W. Heinz                                         PAGE 4



 Line  I  Addr  Code            Source

  146: 1			; The following values MUST be provided by the user
  147: 1			;
  148: 1			;***********************************************************************
  149: 1			;
  150: 1	N      0024	ARG_STACK		EQU	24H				;ARGUMENT STACK POINTER
  151: 1	N      0025	FORMAT			EQU	25H				;LOCATION OF OUTPUT FORMAT BYTE
  152: 1	B	 31	INTGRC			BIT	26H.1				;BIT SET IF INTEGER ERROR
  153: 1	B	 33	ADD_IN			BIT	26H.3				;DCMPXZ IN BASIC BACKAGE
  154: 1	B	 36	ZSURP			BIT	26H.6				;ZERO SUPRESSION FOR HEX PRINT
  155: 1	N      0027	CONVT			EQU	27H				;String addr TO CONVERT NUMBERS
  156: 1			;
  157: 1			;***********************************************************************
  158: 1			;
  159: 1			; The following equates are used internally
  160: 1			;
  161: 1			;***********************************************************************
  162: 1			;
  163: 1	N      0006	FP_NUMBER_SIZE		EQU	6
  164: 1	N      0004	DIGIT			EQU	4
  165: 1	N      0000	R0B0			EQU	0
  166: 1	N      0001	R1B0			EQU	1
  167: 1	N      0000	UNDERFLOW		EQU	0
  168: 1	N      0001	OVERFLOW		EQU	1
  169: 1	N      0002	ZERO			EQU	2
  170: 1	N      0003	ZERO_DIVIDE		EQU	3
  171: 1			;
  172: 1			;***********************************************************************
  173: 1				;**************************************************************
  174: 1				;
  175: 1				; The following internal locations are used by the math pack
  176: 1				; ordering is important and the FP_DIGITS must be bit
  177: 1				; addressable
  178: 1				;
  179: 1				;***************************************************************
  180: 1				;
  181: 1	N      0028	FP_STATUS		EQU	28H				;28 NOT used data pointer me
  182: 1	N      0029	FP_TEMP			EQU	FP_STATUS+1			;29 NOT USED
  183: 1	N      002A	FP_CARRY		EQU	FP_STATUS+2			;2A USED FOR BITS
  184: 1	N      002B	FP_DIG12		EQU	FP_CARRY+1			;2B
  185: 1	N      002C	FP_DIG34		EQU	FP_CARRY+2			;2C
  186: 1	N      002D	FP_DIG56		EQU	FP_CARRY+3			;2D
  187: 1	N      002E	FP_DIG78		EQU	FP_CARRY+4			;2E
  188: 1	N      002F	FP_SIGN			EQU	FP_CARRY+5			;2F
  189: 1	N      0030	FP_EXP			EQU	FP_CARRY+6			;30
  190: 1	B	 78	MSIGN			BIT	FP_SIGN.0			;2F.0
  191: 1	B	 50	XSIGN			BIT	FP_CARRY.0			;2A.0
  192: 1	B	 51	FOUND_RADIX		BIT	FP_CARRY.1			;2A.1
  193: 1	B	 52	FIRST_RADIX		BIT	FP_CARRY.2			;2A.2
  194: 1	B	 53	DONE_LOAD		BIT	FP_CARRY.3			;2A.3
  195: 1	N      002B	FP_NIB1			EQU	FP_DIG12			;2B
  196: 1	N      002C	FP_NIB2			EQU	FP_NIB1+1			;2C
  197: 1	N      002D	FP_NIB3			EQU	FP_NIB1+2			;2D
  198: 1	N      002E	FP_NIB4			EQU	FP_NIB1+3			;2E
  199: 1	N      002F	FP_NIB5			EQU	FP_NIB1+4			;2F
  200: 1	N      0030	FP_NIB6			EQU	FP_NIB1+5			;30
  201: 1	N      0031	FP_NIB7			EQU	FP_NIB1+6			;31

ASEM-51 V1.3                                         Copyright (c) 2002 by W.W. Heinz                                         PAGE 5



 Line  I  Addr  Code            Source

  202: 1	N      0032	FP_NIB8			EQU	FP_NIB1+7			;32
  203: 1	N      0033	FP_ACCX			EQU	FP_NIB1+8			;33
  204: 1	N      0034	FP_ACCC			EQU	FP_NIB1+9			;34
  205: 1	N      0035	FP_ACC1			EQU	FP_NIB1+10			;35
  206: 1	N      0036	FP_ACC2			EQU	FP_NIB1+11			;36
  207: 1	N      0037	FP_ACC3			EQU	FP_NIB1+12			;37
  208: 1	N      0038	FP_ACC4			EQU	FP_NIB1+13			;38
  209: 1	N      0039	FP_ACC5			EQU	FP_NIB1+14			;39
  210: 1	N      003A	FP_ACC6			EQU	FP_NIB1+15			;3A
  211: 1	N      003B	FP_ACC7			EQU	FP_NIB1+16			;3B
  212: 1	N      003C	FP_ACC8			EQU	FP_NIB1+17			;3C
  213: 1	N      003D	FP_ACCS			EQU	FP_NIB1+18			;3D
  214: 1
  215: 1
  216: 1			;			MOV	SP,#50H
  217: 1			;			MOV	24H,#07FH
  218: 1			;			MOV	25H,#044H
  219: 1			;
  220: 1			;			MOV	DPTR,#FPONE
  221: 1			;			ACALL	PUSHC
  222: 1			;			MOV	DPTR,#FPTWO
  223: 1			;			ACALL	PUSHC
  224: 1			;			ACALL	FLOATING_ADD
  225: 1			;
  226: 1			;
  227: 1			;			MOV	24H,#07FH
  228: 1			;			MOV	DPTR,#FPTHREE
  229: 1			;			ACALL	PUSHC
  230: 1			;			MOV	DPTR,#FPTWO
  231: 1			;			ACALL	PUSHC
  232: 1			;			ACALL	FLOATING_MUL
  233: 1			;			ACALL	FLOATING_POINT_OUTPUT
  234: 1			;			SJMP	$
  235: 1			;
  236: 1			;FP_BASE			EQU	$
  237: 1
  238: 1				;**************************************************************
  239: 1				;
  240: 1				; The floating point entry points and jump table
  241: 1				;
  242: 1				;**************************************************************
  243: 1				;
  244: 1			;			AJMP	FLOATING_ADD
  245: 1			;			AJMP	FLOATING_SUB
  246: 1			;			AJMP	FLOATING_COMP
  247: 1			;			AJMP	FLOATING_MUL
  248: 1			;			AJMP	FLOATING_DIV
  249: 1			;			AJMP	HEXSCAN
  250: 1			;			AJMP	FLOATING_POINT_INPUT
  251: 1			;			AJMP	FLOATING_POINT_OUTPUT
  252: 1			;			AJMP	MULNUM10
  253: 1			;			AJMP	HEXOUT
  254: 1			;			AJMP	PUSHAS				;PUSH R0 TO ARGUMENT
  255: 1			;			AJMP	POPAS				;POP ARGUMENT TO R1
  256: 1			;			AJMP	MOVAS				;COPY ARGUMENT TO R1
  257: 1			;			AJMP	AINT				;INT FUNCTION

ASEM-51 V1.3                                         Copyright (c) 2002 by W.W. Heinz                                         PAGE 6



 Line  I  Addr  Code            Source

  258: 1			;			AJMP	PUSHC				;PUSH ARG IN CODE MEM POINTED TO BY
       1			DPTR TO STACK
  259: 1
  260: 1				;
  261: 1				;IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII
  262: 1				;
  263: 1  0076			FLOATING_INIT:
  264: 1				;
  265: 1				;IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII
  266: 1				;
  267: 1  0076	75 24 FF				MOV	ARG_STACK,#FPSTACK
  268: 1  0079	22					RET
  269: 1
  270: 1  007A	22		PRTERR:			RET
  271: 1  007B	22		BADPRM:			RET
  272: 1
  273: 1				;
  274: 1				;
  275: 1  007C			FLOATING_SUB:
  276: 1				;
  277: 1  007C	A8 24					MOV	R0,ARG_STACK
  278: 1  007E	18					DEC	R0				;POINT TO SIGN
  279: 1  007F	E6					MOV	A,@R0				;READ SIGN
  280: 1  0080	B2 E0					CPL	ACC.0
  281: 1  0082	F6					MOV	@R0,A
  282: 1				;
  283: 1				;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
  284: 1				;
  285: 1  0083			FLOATING_ADD:
  286: 1				;
  287: 1				;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
  288: 1				;
  289: 1				;
  290: 1  0083	71 41					ACALL 	MDES1				;R7=TOS EXP, R6=TOS-1 EXP, R4=TOS SI
       1			GN
  291: 1											;R3=TOS-1 SIGN, OPERATION IS R1 # R0
  292: 1				;
  293: 1  0085	EF					MOV	A,R7				;GET TOS EXPONENT
  294: 1  0086	60 0D					JZ	POP_AND_EXIT			;IF TOS=0 THEN POP AND EXIT
  295: 1  0088	BE 00 12				CJNE	R6,#0,LOAD1			;CLEAR CARRY EXIT IF ZERO
  296: 1				;
  297: 1				;**************************************************************
  298: 1				;
  299: 1  008B			SWAP_AND_EXIT:							; Swap external args and return
  300: 1				;
  301: 1				;**************************************************************
  302: 1				;
  303: 1  008B	71 38					ACALL	LOAD_POINTERS
  304: 1  008D	7F 06					MOV	R7,#FP_NUMBER_SIZE
  305: 1				;
  306: 1  008F	E6		SE1:			MOV	A,@R0				;SWAP THE ARGUMENTS
  307: 1  0090	F7					MOV	@R1,A
  308: 1  0091	18					DEC	R0
  309: 1  0092	19					DEC	R1
  310: 1  0093	DF FA					DJNZ	R7,SE1
  311: 1				;

ASEM-51 V1.3                                         Copyright (c) 2002 by W.W. Heinz                                         PAGE 7



 Line  I  Addr  Code            Source

  312: 1  0095			POP_AND_EXIT:
  313: 1				;
  314: 1  0095	E5 24					MOV	A,ARG_STACK			;POP THE STACK
  315: 1  0097	24 06					ADD	A,#FP_NUMBER_SIZE
  316: 1  0099	F5 24					MOV	ARG_STACK,A
  317: 1  009B	E4					CLR	A
  318: 1  009C	22					RET
  319: 1				;
  320: 1				;
  321: 1  009D	9E		LOAD1:			SUBB	A,R6				;A = ARG 1 EXP - ARG 2 EXP
  322: 1  009E	8F 30					MOV	FP_EXP,R7			;SAVE EXPONENT AND SIGN
  323: 1  00A0	8C 2F					MOV	FP_SIGN,R4
  324: 1  00A2	50 09					JNC	LOAD2				;ARG1 EXPONENT IS LARGER OR SAME
  325: 1  00A4	8E 30					MOV	FP_EXP,R6
  326: 1  00A6	8B 2F					MOV	FP_SIGN,R3
  327: 1  00A8	F4					CPL	A
  328: 1  00A9	04					INC	A				;COMPENSATE FOR EXP DELTA
  329: 1  00AA	C8					XCH	A,R0				;FORCE R0 TO POINT AT THE LARGEST
  330: 1  00AB	C9					XCH	A,R1				;EXPONENT
  331: 1  00AC	C8					XCH	A,R0
  332: 1				;
  333: 1  00AD	FF		LOAD2:			MOV	R7,A				;SAVE THE EXPONENT DELTA IN R7
  334: 1  00AE	C2 33					CLR	ADD_IN
  335: 1  00B0	BD 00 02				CJNE	R5,#0,LOAD3
  336: 1  00B3	D2 33					SETB	ADD_IN
  337: 1				;
  338: 1				; Load the R1 mantissa
  339: 1				;
  340: 1  00B5	71 52		LOAD3:			ACALL	LOADR1_MANTISSA			;LOAD THE SMALLEST NUMBER
  341: 1				;
  342: 1				; Now align the number to the delta exponent
  343: 1				; R4 points to the string of the last digits lost
  344: 1				;
  345: 1						CMP	R7,#DIGIT+DIGIT+3
  346+ 2  00B7	BF 0B 00	CJNE	R7,#DIGIT+DIGIT+3,$+3
  347: 1  00BA	40 02					JC	LOAD4
  348: 1  00BC	7F 0A					MOV	R7,#DIGIT+DIGIT+2
  349: 1				;
  350: 1  00BE	75 2A 00	LOAD4:			MOV	FP_CARRY,#00			;CLEAR THE CARRY
  351: 1  00C1	51 95					ACALL	RIGHT				;SHIFT THE NUMBER
  352: 1				;
  353: 1				; Set up for addition and subtraction
  354: 1				;
  355: 1  00C3	7F 04					MOV	R7,#DIGIT			;LOOP COUNT
  356: 1  00C5	79 2E					MOV	R1,#FP_DIG78
  357: 1  00C7	74 9E					MOV	A,#9EH
  358: 1  00C9	C3					CLR	C
  359: 1  00CA	9C					SUBB	A,R4
  360: 1  00CB	D4					DA	A
  361: 1  00CC	CC					XCH	A,R4
  362: 1  00CD	70 01					JNZ	LOAD5
  363: 1  00CF	FC					MOV	R4,A
  364: 1  00D0			LOAD5:			CMP	A,#50H				;TEST FOR SUBTRACTION
  365+ 2  00D0	B4 50 00	CJNE	A,#50H,$+3
  366: 1  00D3	30 33 18				JNB	ADD_IN,SUBLP			;DO SUBTRACTION IF NO ADD_IN
  367: 1  00D6	B3					CPL	C				;FLIP CARRY FOR ADDITION

ASEM-51 V1.3                                         Copyright (c) 2002 by W.W. Heinz                                         PAGE 8



 Line  I  Addr  Code            Source

  368: 1  00D7	11 E5					ACALL	ADDLP				;DO ADDITION
  369: 1				;
  370: 1  00D9	50 08					JNC	ADD_R
  371: 1  00DB	05 2A					INC	FP_CARRY
  372: 1  00DD	7F 01					MOV	R7,#1
  373: 1  00DF	51 95					ACALL	RIGHT
  374: 1  00E1	51 4C					ACALL	INC_FP_EXP			;SHIFT AND BUMP EXPONENT
  375: 1				;
  376: 1  00E3	41 3D		ADD_R:			AJMP	STORE_ALIGN_TEST_AND_EXIT
  377: 1				;
  378: 1  00E5	E6		ADDLP:			MOV	A,@R0
  379: 1  00E6	37					ADDC	A,@R1
  380: 1  00E7	D4					DA	A
  381: 1  00E8	F7					MOV	@R1,A
  382: 1  00E9	18					DEC	R0
  383: 1  00EA	19					DEC	R1
  384: 1  00EB	DF F8					DJNZ	R7,ADDLP			;LOOP UNTIL DONE
  385: 1  00ED	22					RET
  386: 1				;
  387: 1				;
  388: 1  00EE	E6		SUBLP:			MOV	A,@R0				;NOW DO SUBTRACTION
  389: 1  00EF	FE					MOV	R6,A
  390: 1  00F0	E4					CLR	A
  391: 1  00F1	34 99					ADDC	A,#99H
  392: 1  00F3	97					SUBB	A,@R1
  393: 1  00F4	2E					ADD	A,R6
  394: 1  00F5	D4					DA	A
  395: 1  00F6	F7					MOV	@R1,A
  396: 1  00F7	18					DEC	R0
  397: 1  00F8	19					DEC	R1
  398: 1  00F9	DF F3					DJNZ	R7,SUBLP
  399: 1  00FB	40 11					JC	FSUB6
  400: 1				;
  401: 1				;
  402: 1				; Need to complement the result and sign because the floating
  403: 1				; point accumulator mantissa was larger than the external
  404: 1				; memory and their signs were equal.
  405: 1				;
  406: 1  00FD	B2 78					CPL	FP_SIGN.0
  407: 1  00FF	79 2E					MOV	R1,#FP_DIG78
  408: 1  0101	7F 04					MOV	R7,#DIGIT			;LOOP COUNT
  409: 1				;
  410: 1  0103	74 9A		FSUB5:			MOV	A,#9AH
  411: 1  0105	97					SUBB	A,@R1
  412: 1  0106	24 00					ADD	A,#0
  413: 1  0108	D4					DA	A
  414: 1  0109	F7					MOV	@R1,A
  415: 1  010A	19					DEC	R1
  416: 1  010B	B3					CPL	C
  417: 1  010C	DF F5					DJNZ	R7,FSUB5			;LOOP
  418: 1				;
  419: 1				; Now see how many zeros their are
  420: 1				;
  421: 1  010E	78 2B		FSUB6:			MOV	R0,#FP_DIG12
  422: 1  0110	7F 00					MOV	R7,#0
  423: 1				;

ASEM-51 V1.3                                         Copyright (c) 2002 by W.W. Heinz                                         PAGE 9



 Line  I  Addr  Code            Source

  424: 1  0112	E6		FSUB7:			MOV	A,@R0
  425: 1  0113	70 08					JNZ	FSUB8
  426: 1  0115	0F					INC	R7
  427: 1  0116	0F					INC	R7
  428: 1  0117	08					INC	R0
  429: 1  0118	B8 2F F7				CJNE	R0,#FP_SIGN,FSUB7
  430: 1  011B	41 85					AJMP	ZERO_AND_EXIT
  431: 1				;
  432: 1  011D			FSUB8:			CMP	A,#10H
  433+ 2  011D	B4 10 00	CJNE	A,#10H,$+3
  434: 1  0120	50 01					JNC	FSUB9
  435: 1  0122	0F					INC	R7
  436: 1				;
  437: 1				; Now R7 has the number of leading zeros in the FP ACC
  438: 1				;
  439: 1  0123	E5 30		FSUB9:			MOV	A,FP_EXP			;GET THE OLD EXPONENT
  440: 1  0125	C3					CLR	C
  441: 1  0126	9F					SUBB	A,R7				;SUBTRACT FROM THE NUMBER OF ZEROS
  442: 1  0127	60 0B					JZ	FSUB10
  443: 1  0129	40 09					JC	FSUB10
  444: 1				;
  445: 1  012B	F5 30					MOV	FP_EXP,A			;SAVE THE NEW EXPONENT
  446: 1				;
  447: 1  012D	51 CF					ACALL	LEFT1				;SHIFT THE FP ACC
  448: 1  012F	75 2A 00				MOV	FP_CARRY,#0
  449: 1  0132	41 3D					AJMP	STORE_ALIGN_TEST_AND_EXIT
  450: 1				;
  451: 1  0134	41 7F		FSUB10:			AJMP	UNDERFLOW_AND_EXIT
  452: 1				;
  453: 1				;***************************************************************
  454: 1				;
  455: 1  0136			FLOATING_COMP:	; Compare two floating point numbers
  456: 1					; used for relational operations and is faster
  457: 1					; than subtraction. ON RETURN, The carry is set
  458: 1					; if ARG1 is > ARG2, else carry is not set
  459: 1					; if ARG1 = ARG2, F0 gets set
  460: 1				;
  461: 1				;***************************************************************
  462: 1				;
  463: 1  0136	71 41					ACALL	MDES1				;SET UP THE REGISTERS
  464: 1  0138	E5 24					MOV	A,ARG_STACK
  465: 1  013A	24 0C					ADD	A,#FP_NUMBER_SIZE+FP_NUMBER_SIZE
  466: 1  013C	F5 24					MOV	ARG_STACK,A			;POP THE STACK TWICE, CLEAR THE CARR
       1			Y
  467: 1  013E	EE					MOV	A,R6				;CHECK OUT EXPONENTS
  468: 1  013F	C2 D5					CLR	F0
  469: 1  0141	C3		        		CLR     C
  470: 1  0142	9F					SUBB	A,R7
  471: 1  0143	60 0A					JZ	EXPONENTS_EQUAL
  472: 1  0145	40 03					JC	ARG1_EXP_IS_LARGER
  473: 1				;
  474: 1				; Now the ARG2 EXPONENT is > ARG1 EXPONENT
  475: 1				;
  476: 1  0147			SIGNS_DIFFERENT:
  477: 1				;
  478: 1  0147	EB					MOV	A,R3				;SEE IF SIGN OF ARG2 IS POSITIVE

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 10



 Line  I  Addr  Code            Source

  479: 1  0148	80 01					SJMP	ARG1_EXP_IS_LARGER1
  480: 1				;
  481: 1  014A			ARG1_EXP_IS_LARGER:
  482: 1				;
  483: 1  014A	EC					MOV	A,R4				;GET THE SIGN OF ARG1 EXPONENT
  484: 1  014B	60 01		ARG1_EXP_IS_LARGER1:	JZ	ARG1_EXP_IS_LARGER2
  485: 1  014D	B3					CPL	C
  486: 1  014E	22		ARG1_EXP_IS_LARGER2:	RET
  487: 1				;
  488: 1  014F			EXPONENTS_EQUAL:
  489: 1				;
  490: 1				; First, test the sign, then the mantissa
  491: 1				;
  492: 1  014F	BD 00 F5				CJNE	R5,#0,SIGNS_DIFFERENT
  493: 1				;
  494: 1  0152			BOTH_PLUS:
  495: 1				;
  496: 1  0152	7F 04					MOV	R7,#DIGIT			;POINT AT MS DIGIT
  497: 1  0154	18					DEC	R0
  498: 1  0155	18					DEC	R0
  499: 1  0156	18					DEC	R0
  500: 1  0157	19					DEC	R1
  501: 1  0158	19					DEC	R1
  502: 1  0159	19					DEC	R1
  503: 1				;
  504: 1				; Now do the compare
  505: 1				;
  506: 1  015A	E6		CLOOP:			MOV	A,@R0
  507: 1  015B	FE					MOV	R6,A
  508: 1  015C	E7					MOV	A,@R1
  509: 1  015D	9E					SUBB	A,R6
  510: 1  015E	70 EA					JNZ	ARG1_EXP_IS_LARGER
  511: 1  0160	08					INC	R0
  512: 1  0161	09					INC	R1
  513: 1  0162	DF F6					DJNZ	R7,CLOOP
  514: 1				;
  515: 1				; If here, the numbers are the same, the carry is cleared
  516: 1				;
  517: 1  0164	D2 D5					SETB	F0
  518: 1  0166	22					RET					;EXIT WITH EQUAL
  519: 1				;
  520: 1			;MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
  521: 1			;
  522: 1  0167			FLOATING_MUL:							; Floating point multiply
  523: 1			;
  524: 1			;MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
  525: 1			;
  526: 1  0167	71 3F					ACALL	MUL_DIV_EXP_AND_SIGN
  527: 1				;
  528: 1				; check for zero exponents
  529: 1				;
  530: 1  0169	BE 00 02				CJNE	R6,#00,FMUL1			;ARG 2 EXP ZERO?
  531: 1  016C	41 85		FMUL0:			AJMP	ZERO_AND_EXIT
  532: 1				;
  533: 1				; calculate the exponent
  534: 1				;

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 11



 Line  I  Addr  Code            Source

  535: 1  016E	8D 2F		FMUL1:			MOV	FP_SIGN,R5			;SAVE THE SIGN, IN CASE OF FAILURE
  536: 1				;
  537: 1  0170	EF					MOV	A,R7
  538: 1  0171	60 F9					JZ	FMUL0
  539: 1  0173	2E					ADD	A,R6				;ADD THE EXPONENTS
  540: 1  0174	20 E7 05				JB	ACC.7,FMUL_OVER
  541: 1  0177	10 D7 06				JBC	CY,FMUL2			;SEE IF CARRY IS SET
  542: 1				;
  543: 1  017A	41 7F					AJMP	UNDERFLOW_AND_EXIT
  544: 1				;
  545: 1  017C			FMUL_OVER:
  546: 1				;
  547: 1  017C	50 02					JNC	FMUL2				;OK IF SET
  548: 1				;
  549: 1  017E	41 6E		FOV:			AJMP	OVERFLOW_AND_EXIT
  550: 1				;
  551: 1  0180	94 81		FMUL2:			SUBB	A,#129				;SUBTRACT THE EXPONENT BIAS
  552: 1  0182	FE					MOV	R6,A				;SAVE IT FOR LATER
  553: 1				;
  554: 1				; Unpack and load R0
  555: 1				;
  556: 1  0183	51 58					ACALL	UNPACK_R0
  557: 1				;
  558: 1				; Now set up for loop multiply
  559: 1				;
  560: 1  0185	7B 04					MOV	R3,#DIGIT
  561: 1  0187	AC 01					MOV	R4,R1B0
  562: 1				;
  563: 1				;
  564: 1				; Now, do the multiply and accumulate the product
  565: 1				;
  566: 1  0189	8C 01		FMUL3:			MOV	R1B0,R4
  567: 1  018B	E7					MOV	A,@R1
  568: 1  018C	FA					MOV	R2,A
  569: 1  018D	71 05					ACALL	MUL_NIBBLE
  570: 1				;
  571: 1  018F	EA					MOV	A,R2
  572: 1  0190	C4					SWAP	A
  573: 1  0191	71 05					ACALL	MUL_NIBBLE
  574: 1  0193	1C					DEC	R4
  575: 1  0194	DB F3					DJNZ	R3,FMUL3
  576: 1				;
  577: 1				; Now, pack and restore the sign
  578: 1				;
  579: 1  0196	8E 30					MOV	FP_EXP,R6
  580: 1  0198	8D 2F					MOV	FP_SIGN,R5
  581: 1  019A	21 FD					AJMP	PACK				;FINISH IT OFF
  582: 1				;
  583: 1				;DDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDD
  584: 1				;
  585: 1  019C			FLOATING_DIV:
  586: 1				;
  587: 1				;DDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDD
  588: 1				;
  589: 1  019C	71 41					ACALL	MDES1
  590: 1				;

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 12



 Line  I  Addr  Code            Source

  591: 1				; Check the exponents
  592: 1				;
  593: 1  019E	8D 2F					MOV	FP_SIGN,R5			;SAVE THE SIGN
  594: 1  01A0	BF 00 06				CJNE	R7,#0,DIV0			;CLEARS THE CARRY
  595: 1  01A3	51 6E					ACALL	OVERFLOW_AND_EXIT
  596: 1  01A5	E4					CLR	A
  597: 1  01A6	D2 E3					SETB	ACC.ZERO_DIVIDE
  598: 1  01A8	22					RET
  599: 1				;
  600: 1  01A9	EE		DIV0:			MOV	A,R6				;GET EXPONENT
  601: 1  01AA	60 C0					JZ	FMUL1-2				;EXIT IF ZERO
  602: 1  01AC	9F					SUBB	A,R7				;DELTA EXPONENT
  603: 1  01AD	20 E7 04				JB	ACC.7,D_UNDER
  604: 1  01B0	50 04					JNC	DIV3
  605: 1  01B2	41 7F					AJMP	UNDERFLOW_AND_EXIT
  606: 1				;
  607: 1  01B4	50 C8		D_UNDER:		JNC	FOV
  608: 1				;
  609: 1  01B6	24 81		DIV3:			ADD	A,#129				;CORRECTLY BIAS THE EXPONENT
  610: 1  01B8	F5 30					MOV	FP_EXP,A			;SAVE THE EXPONENT
  611: 1  01BA	71 52					ACALL	LOADR1_MANTISSA			;LOAD THE DIVIDED
  612: 1				;
  613: 1  01BC	7A 34					MOV	R2,#FP_ACCC			;SAVE LOCATION
  614: 1  01BE	AB 00					MOV	R3,R0B0				;SAVE POINTER IN R3
  615: 1  01C0	75 2A 00				MOV	FP_CARRY,#0			;ZERO CARRY BYTE
  616: 1				;
  617: 1  01C3	7D FF		DIV4:			MOV	R5,#0FFH			;LOOP COUNT
  618: 1  01C5	D3					SETB	C
  619: 1				;
  620: 1  01C6	8B 00		DIV5:			MOV	R0B0,R3				;RESTORE THE EXTERNAL POINTER
  621: 1  01C8	79 2E					MOV	R1,#FP_DIG78			;SET UP INTERNAL POINTER
  622: 1  01CA	7F 04					MOV	R7,#DIGIT			;LOOP COUNT
  623: 1  01CC	50 17					JNC	DIV7				;EXIT IF NO CARRY
  624: 1				;
  625: 1  01CE	E6		DIV6:			MOV	A,@R0				;DO ACCUMLATION
  626: 1  01CF	FE					MOV	R6,A
  627: 1  01D0	E4					CLR	A
  628: 1  01D1	34 99					ADDC	A,#99H
  629: 1  01D3	9E					SUBB	A,R6
  630: 1  01D4	27					ADD	A,@R1
  631: 1  01D5	D4					DA	A
  632: 1  01D6	F7					MOV	@R1,A
  633: 1  01D7	18					DEC	R0
  634: 1  01D8	19					DEC	R1
  635: 1  01D9	DF F3					DJNZ	R7,DIV6				;LOOP
  636: 1				;
  637: 1  01DB	0D					INC	R5				;SUBTRACT COUNTER
  638: 1  01DC	40 E8					JC	DIV5				;KEEP LOOPING IF CARRY
  639: 1  01DE	E7					MOV	A,@R1				;GET CARRY
  640: 1  01DF	94 01					SUBB	A,#1				;CARRY IS CLEARED
  641: 1  01E1	F7					MOV	@R1,A				;SAVE CARRY DIGIT
  642: 1  01E2	B3					CPL	C
  643: 1  01E3	80 E1					SJMP	DIV5				;LOOP
  644: 1				;
  645: 1				; Restore the result if carry was found
  646: 1				;

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 13



 Line  I  Addr  Code            Source

  647: 1  01E5	11 E5		DIV7:			ACALL	ADDLP				;ADD NUMBER BACK
  648: 1  01E7	77 00					MOV	@R1,#0				;CLEAR CARRY
  649: 1  01E9	8A 00					MOV	R0B0,R2				;GET SAVE COUNTER
  650: 1  01EB	A6 05					MOV	@R0,5				;SAVE COUNT BYTE
  651: 1				;
  652: 1  01ED	0A					INC	R2				;ADJUST SAVE COUNTER
  653: 1  01EE	7F 01					MOV	R7,#1				;BUMP DIVIDEND
  654: 1  01F0	51 CD					ACALL	LEFT
  655: 1  01F2	BA 3E CE				CJNE	R2,#FP_ACC8+2,DIV4
  656: 1				;
  657: 1  01F5	D5 30 02				DJNZ	FP_EXP,DIV8
  658: 1  01F8	41 7F					AJMP	UNDERFLOW_AND_EXIT
  659: 1				;
  660: 1  01FA	75 2A 00	DIV8:			MOV	FP_CARRY,#0
  661: 1				;
  662: 1				;***************************************************************
  663: 1				;
  664: 1  01FD			PACK:	; Pack the mantissa
  665: 1				;
  666: 1				;***************************************************************
  667: 1				;
  668: 1				; First, set up the pointers
  669: 1				;
  670: 1  01FD	78 34					MOV	R0,#FP_ACCC
  671: 1  01FF	E6					MOV	A,@R0				;GET FP_ACCC
  672: 1  0200	FE					MOV	R6,A				;SAVE FOR ZERO COUNT
  673: 1  0201	60 03					JZ	PACK0				;JUMP OVER IF ZERO
  674: 1  0203	51 4C					ACALL	INC_FP_EXP			;BUMP THE EXPONENT
  675: 1  0205	18					DEC	R0
  676: 1				;
  677: 1  0206	08		PACK0:			INC	R0				;POINT AT FP_ACC1
  678: 1				;
  679: 1  0207	74 08		PACK1:			MOV	A,#8				;ADJUST NIBBLE POINTER
  680: 1  0209	F9					MOV	R1,A
  681: 1  020A	28					ADD	A,R0
  682: 1  020B	F8					MOV	R0,A
  683: 1						CMP	@R0,#5				;SEE IF ADJUSTING NEEDED
  684+ 2  020C	B6 05 00	CJNE	@R0,#5,$+3
  685: 1  020F	40 13					JC	PACK3+1
  686: 1				;
  687: 1  0211	D3		PACK2:			SETB	C
  688: 1  0212	E4					CLR	A
  689: 1  0213	18					DEC	R0
  690: 1  0214	36					ADDC	A,@R0
  691: 1  0215	D4					DA	A
  692: 1  0216	D6					XCHD	A,@R0				;SAVE THE VALUE
  693: 1  0217	30 E4 09				JNB	ACC.4,PACK3
  694: 1  021A	D9 F5					DJNZ	R1,PACK2
  695: 1				;
  696: 1  021C	18					DEC	R0
  697: 1  021D	76 01					MOV	@R0,#1
  698: 1  021F	51 4C					ACALL	INC_FP_EXP
  699: 1  0221	80 06					SJMP	PACK4
  700: 1				;
  701: 1  0223	19		PACK3:			DEC	R1
  702: 1  0224	E9					MOV	A,R1

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 14



 Line  I  Addr  Code            Source

  703: 1  0225	C3					CLR	C
  704: 1  0226	C8					XCH	A,R0
  705: 1  0227	98					SUBB	A,R0
  706: 1  0228	F8					MOV	R0,A
  707: 1				;
  708: 1  0229	79 2B		PACK4:			MOV	R1,#FP_DIG12
  709: 1				;
  710: 1				; Now, pack
  711: 1				;
  712: 1  022B	E6		PLOOP:			MOV	A,@R0
  713: 1  022C	C4					SWAP	A				;FLIP THE DIGITS
  714: 1  022D	08					INC	R0
  715: 1  022E	D6					XCHD	A,@R0
  716: 1  022F	42 06					ORL	6,A				;ACCUMULATE THE OR'ED DIGITS
  717: 1  0231	F7					MOV	@R1,A
  718: 1  0232	08					INC	R0
  719: 1  0233	09					INC	R1
  720: 1  0234	B9 2F F4				CJNE	R1,#FP_SIGN,PLOOP
  721: 1  0237	EE					MOV	A,R6
  722: 1  0238	70 03					JNZ	STORE_ALIGN_TEST_AND_EXIT
  723: 1  023A	75 30 00				MOV	FP_EXP,#0			;ZERO EXPONENT
  724: 1				;
  725: 1				;**************************************************************
  726: 1				;
  727: 1  023D			STORE_ALIGN_TEST_AND_EXIT:					;Save the number align carry and exi
       1			t
  728: 1				;
  729: 1				;**************************************************************
  730: 1				;
  731: 1  023D	71 38					ACALL	LOAD_POINTERS
  732: 1  023F	89 24					MOV	ARG_STACK,R1			;SET UP THE NEW STACK
  733: 1  0241	78 30					MOV	R0,#FP_EXP
  734: 1				;
  735: 1				; Now load the numbers
  736: 1				;
  737: 1  0243	E6		STORE2:			MOV	A,@R0
  738: 1  0244	F7					MOV	@R1,A				;SAVE THE NUMBER
  739: 1  0245	18					DEC	R0
  740: 1  0246	19					DEC	R1
  741: 1  0247	B8 2A F9				CJNE	R0,#FP_CARRY,STORE2
  742: 1				;
  743: 1  024A	E4					CLR	A				;NO ERRORS
  744: 1				;
  745: 1  024B	22		PRET:			RET					;EXIT
  746: 1				;
  747: 1  024C			INC_FP_EXP:
  748: 1				;
  749: 1  024C	05 30					INC	FP_EXP
  750: 1  024E	E5 30					MOV	A,FP_EXP
  751: 1  0250	70 F9					JNZ	PRET				;EXIT IF NOT ZERO
  752: 1  0252	D0 E0					POP	ACC				;WASTE THE CALLING STACK
  753: 1  0254	D0 E0					POP	ACC
  754: 1  0256	41 6E					AJMP	OVERFLOW_AND_EXIT
  755: 1				;
  756: 1			;***********************************************************************
  757: 1			;

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 15



 Line  I  Addr  Code            Source

  758: 1  0258			UNPACK_R0:	; Unpack BCD digits and load into nibble locations
  759: 1			;
  760: 1			;***********************************************************************
  761: 1				;
  762: 1  0258	C0 01					PUSH	R1B0
  763: 1  025A	79 32					MOV	R1,#FP_NIB8
  764: 1				;
  765: 1  025C	E6		ULOOP:			MOV	A,@R0
  766: 1  025D	54 0F					ANL	A,#0FH
  767: 1  025F	F7					MOV	@R1,A				;SAVE THE NIBBLE
  768: 1  0260	E6					MOV	A,@R0
  769: 1  0261	C4					SWAP	A
  770: 1  0262	54 0F					ANL	A,#0FH
  771: 1  0264	19					DEC	R1
  772: 1  0265	F7					MOV	@R1,A				;SAVE THE NIBBLE AGAIN
  773: 1  0266	18					DEC	R0
  774: 1  0267	19					DEC	R1
  775: 1  0268	B9 2A F1				CJNE	R1,#FP_NIB1-1,ULOOP
  776: 1				;
  777: 1  026B	D0 01					POP	R1B0
  778: 1				;
  779: 1  026D	22		LOAD7:			RET
  780: 1				;
  781: 1				;**************************************************************
  782: 1				;
  783: 1  026E			OVERFLOW_AND_EXIT:	;LOAD 99999999 E+127,  SET OV BIT, AND EXIT
  784: 1				;
  785: 1				;**************************************************************
  786: 1				;
  787: 1  026E	78 2E					MOV	R0,#FP_DIG78
  788: 1  0270	74 99					MOV	A,#99H
  789: 1				;
  790: 1  0272	F6		OVE1:			MOV	@R0,A
  791: 1  0273	18					DEC	R0
  792: 1  0274	B8 2A FB				CJNE	R0,#FP_CARRY,OVE1
  793: 1				;
  794: 1  0277	75 30 FF				MOV	FP_EXP,#0FFH
  795: 1  027A	51 3D					ACALL	STORE_ALIGN_TEST_AND_EXIT
  796: 1				;
  797: 1  027C	D2 E1					SETB	ACC.OVERFLOW
  798: 1  027E	22					RET
  799: 1				;
  800: 1				;**************************************************************
  801: 1				;
  802: 1  027F			UNDERFLOW_AND_EXIT:	;LOAD 0, SET UF BIT, AND EXIT
  803: 1				;
  804: 1				;**************************************************************
  805: 1				;
  806: 1  027F	51 85					ACALL	ZERO_AND_EXIT
  807: 1  0281	E4					CLR		A
  808: 1  0282	D2 E0					SETB	ACC.UNDERFLOW
  809: 1  0284	22					RET
  810: 1				;
  811: 1				;**************************************************************
  812: 1				;
  813: 1  0285			ZERO_AND_EXIT:		;LOAD 0, SET ZERO BIT, AND EXIT

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 16



 Line  I  Addr  Code            Source

  814: 1				;
  815: 1				;**************************************************************
  816: 1				;
  817: 1  0285	51 8C					ACALL	FP_CLEAR
  818: 1  0287	51 3D					ACALL	STORE_ALIGN_TEST_AND_EXIT
  819: 1  0289	D2 E2					SETB	ACC.ZERO
  820: 1  028B	22					RET					;EXIT
  821: 1				;
  822: 1				;**************************************************************
  823: 1				;
  824: 1  028C			FP_CLEAR:
  825: 1				;
  826: 1				; Clear internal storage
  827: 1				;
  828: 1				;**************************************************************
  829: 1				;
  830: 1  028C	E4					CLR	A
  831: 1  028D	78 3D					MOV	R0,#FP_ACC8+1
  832: 1				;
  833: 1  028F	F6		FPC1:			MOV	@R0,A
  834: 1  0290	18					DEC	R0
  835: 1  0291	B8 29 FB				CJNE	R0,#FP_TEMP,FPC1
  836: 1  0294	22					RET
  837: 1				;
  838: 1				;**************************************************************
  839: 1				;
  840: 1  0295			RIGHT:	; Shift ACCUMULATOR RIGHT the number of nibbles in R7
  841: 1				; Save the shifted values in R4 if SAVE_ROUND is set
  842: 1				;
  843: 1				;**************************************************************
  844: 1				;
  845: 1  0295	7C 00					MOV	R4,#0				;IN CASE OF NO SHIFT
  846: 1				;
  847: 1  0297	C3		RIGHT1:			CLR	C
  848: 1  0298	EF					MOV	A,R7				;GET THE DIGITS TO SHIFT
  849: 1  0299	60 22					JZ	RIGHT5-1			;EXIT IF ZERO
  850: 1  029B	94 02					SUBB	A,#2				;TWO TO DO?
  851: 1  029D	50 1F					JNC	RIGHT5				;SHIFT TWO NIBBLES
  852: 1				;
  853: 1				; Swap one nibble then exit
  854: 1				;
  855: 1  029F	C0 00		RIGHT3:			PUSH	R0B0				;SAVE POINTER REGISTER
  856: 1  02A1	C0 01					PUSH	R1B0
  857: 1				;
  858: 1  02A3	79 2E					MOV	R1,#FP_DIG78			;LOAD THE POINTERS
  859: 1  02A5	78 2D					MOV	R0,#FP_DIG56
  860: 1  02A7	EC					MOV	A,R4				;GET THE OVERFLOW REGISTER
  861: 1  02A8	D7					XCHD	A,@R1				;GET DIGIT 8
  862: 1  02A9	C4					SWAP	A				;FLIP FOR LOAD
  863: 1  02AA	FC					MOV	R4,A
  864: 1				;
  865: 1  02AB	E7		RIGHTL:			MOV	A,@R1				;GET THE LOW ORDER BYTE
  866: 1  02AC	D6					XCHD	A,@R0				;SWAP NIBBLES
  867: 1  02AD	C4					SWAP	A				;FLIP FOR STORE
  868: 1  02AE	F7					MOV	@R1,A				;SAVE THE DIGITS
  869: 1  02AF	18					DEC	R0				;BUMP THE POINTERS

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 17



 Line  I  Addr  Code            Source

  870: 1  02B0	19					DEC	R1
  871: 1  02B1	B9 2A F7				CJNE	R1,#FP_DIG12-1,RIGHTL	;LOOP
  872: 1				;
  873: 1  02B4	E7					MOV	A,@R1				;ACC = CH8
  874: 1  02B5	C4					SWAP	A				;ACC = 8CH
  875: 1  02B6	54 0F					ANL	A,#0FH				;ACC = 0CH
  876: 1  02B8	F7					MOV	@R1,A				;CARRY DONE
  877: 1  02B9	D0 01					POP	R1B0				;EXIT
  878: 1  02BB	D0 00					POP	R0B0				;RESTORE REGISTER
  879: 1  02BD	22					RET
  880: 1				;
  881: 1  02BE	FF		RIGHT5:			MOV	R7,A				;SAVE THE NEW SHIFT NUMBER
  882: 1  02BF	E4					CLR	A
  883: 1  02C0	C5 2A					XCH	A,FP_CARRY			;SWAP THE NIBBLES
  884: 1  02C2	C5 2B					XCH	A,FP_DIG12
  885: 1  02C4	C5 2C					XCH	A,FP_DIG34
  886: 1  02C6	C5 2D					XCH	A,FP_DIG56
  887: 1  02C8	C5 2E					XCH	A,FP_DIG78
  888: 1  02CA	FC					MOV	R4,A				;SAVE THE LAST DIGIT SHIFTED
  889: 1  02CB	80 CB					SJMP	RIGHT1+1
  890: 1				;
  891: 1				;***************************************************************
  892: 1				;
  893: 1  02CD			LEFT:	; Shift ACCUMULATOR LEFT the number of nibbles in R7
  894: 1				;
  895: 1				;***************************************************************
  896: 1				;
  897: 1  02CD	7C 00					MOV	R4,#00H				;CLEAR FOR SOME ENTRYS
  898: 1				;
  899: 1  02CF	C3		LEFT1:			CLR	C
  900: 1  02D0	EF					MOV	A,R7				;GET SHIFT VALUE
  901: 1  02D1	60 22					JZ	LEFT5-1				;EXIT IF ZERO
  902: 1  02D3	94 02					SUBB	A,#2				;SEE HOW MANY BYTES TO SHIFT
  903: 1  02D5	50 1F					JNC	LEFT5
  904: 1				;
  905: 1  02D7	C0 00		LEFT3:			PUSH	R0B0				;SAVE POINTER
  906: 1  02D9	C0 01					PUSH	R1B0
  907: 1  02DB	78 2A					MOV	R0,#FP_CARRY
  908: 1  02DD	79 2B					MOV	R1,#FP_DIG12
  909: 1				;
  910: 1  02DF	E6					MOV	A,@R0				;ACC=CHCL
  911: 1  02E0	C4					SWAP	A				;ACC = CLCH
  912: 1  02E1	F6					MOV	@R0,A				;ACC = CLCH, @R0 = CLCH
  913: 1				;
  914: 1  02E2	E7		LEFTL:			MOV	A,@R1				;DIG 12
  915: 1  02E3	C4					SWAP	A				;DIG 21
  916: 1  02E4	D6					XCHD	A,@R0
  917: 1  02E5	F7					MOV	@R1,A				;SAVE IT
  918: 1  02E6	08					INC	R0				;BUMP POINTERS
  919: 1  02E7	09					INC	R1
  920: 1  02E8	B8 2E F7				CJNE	R0,#FP_DIG78,LEFTL
  921: 1				;
  922: 1  02EB	EC					MOV	A,R4
  923: 1  02EC	C4					SWAP	A
  924: 1  02ED	D6					XCHD	A,@R0
  925: 1  02EE	54 F0					ANL	A,#0F0H

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 18



 Line  I  Addr  Code            Source

  926: 1  02F0	FC					MOV	R4,A
  927: 1				;
  928: 1  02F1	D0 01					POP	R1B0
  929: 1  02F3	D0 00					POP	R0B0				;RESTORE
  930: 1  02F5	22					RET					;DONE
  931: 1				;
  932: 1  02F6	FF		LEFT5:			MOV	R7,A				;RESTORE COUNT
  933: 1  02F7	E4					CLR	A
  934: 1  02F8	CC					XCH	A,R4				;GET THE RESTORATION BYTE
  935: 1  02F9	C5 2E					XCH	A,FP_DIG78			;DO THE SWAP
  936: 1  02FB	C5 2D					XCH	A,FP_DIG56
  937: 1  02FD	C5 2C					XCH	A,FP_DIG34
  938: 1  02FF	C5 2B					XCH	A,FP_DIG12
  939: 1  0301	C5 2A					XCH	A,FP_CARRY
  940: 1  0303	80 CB					SJMP	LEFT1+1
  941: 1				;
  942: 1  0305			MUL_NIBBLE:
  943: 1				;
  944: 1				; Multiply the nibble in R7 by the FP_NIB locations
  945: 1				; accumulate the product in FP_ACC
  946: 1				;
  947: 1				; Set up the pointers for multiplication
  948: 1				;
  949: 1  0305	54 0F					ANL	A,#0FH				;STRIP OFF MS NIBBLE
  950: 1  0307	FF					MOV	R7,A
  951: 1  0308	78 3C					MOV	R0,#FP_ACC8
  952: 1  030A	79 32					MOV	R1,#FP_NIB8
  953: 1  030C	E4					CLR	A
  954: 1  030D	F5 33					MOV	FP_ACCX,A
  955: 1				;
  956: 1  030F	18		MNLOOP:			DEC	R0				;BUMP POINTER TO PROPAGATE CARRY
  957: 1  0310	26					ADD	A,@R0				;ATTEMPT TO FORCE CARRY
  958: 1  0311	D4					DA	A				;BCD ADJUST
  959: 1  0312	30 E4 03				JNB	ACC.4,MNL0			;DON'T ADJUST IF NO NEED
  960: 1  0315	18					DEC	R0				;PROPAGATE CARRY TO THE NEXT DIGIT
  961: 1  0316	06					INC	@R0				;DO THE ADJUSTING
  962: 1  0317	08					INC	R0				;RESTORE R0
  963: 1				;
  964: 1  0318	D6		MNL0:			XCHD	A,@R0				;RESTORE INITIAL NUMBER
  965: 1  0319	8F F0					MOV	B,R7				;GET THE NUBBLE TO MULTIPLY
  966: 1  031B	E7					MOV	A,@R1				;GET THE OTHER NIBBLE
  967: 1  031C	A4					MUL	AB					;DO THE MULTIPLY
  968: 1  031D	75 F0 0A				MOV	B,#10				;NOW BCD ADJUST
  969: 1  0320	84					DIV	AB
  970: 1  0321	C5 F0					XCH	A,B				;GET THE REMAINDER
  971: 1  0323	26					ADD	A,@R0				;PROPAGATE THE PARTIAL PRODUCTS
  972: 1  0324	D4					DA	A				;BCD ADJUST
  973: 1  0325	30 E4 02				JNB	ACC.4,MNL1			;PROPAGATE PARTIAL PRODUCT CARRY
  974: 1  0328	05 F0					INC	B
  975: 1				;
  976: 1  032A	08		MNL1:			INC	R0
  977: 1  032B	D6					XCHD	A,@R0				;SAVE THE NEW PRODUCT
  978: 1  032C	18					DEC	R0
  979: 1  032D	E5 F0					MOV	A,B				;GET BACK THE QUOTIENT
  980: 1  032F	19					DEC	R1
  981: 1  0330	B9 2A DC				CJNE	R1,#FP_NIB1-1,MNLOOP

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 19



 Line  I  Addr  Code            Source

  982: 1				;
  983: 1  0333	25 33					ADD	A,FP_ACCX			;GET THE OVERFLOW
  984: 1  0335	D4					DA	A				;ADJUST
  985: 1  0336	F6					MOV	@R0,A				;SAVE IT
  986: 1  0337	22					RET					;EXIT
  987: 1				;
  988: 1				;***************************************************************
  989: 1				;
  990: 1  0338			LOAD_POINTERS:	; Load the ARG_STACK into R0 and bump R1
  991: 1				;
  992: 1				;***************************************************************
  993: 1				;
  994: 1  0338	A8 24					MOV	R0,ARG_STACK
  995: 1  033A	74 06					MOV	A,#FP_NUMBER_SIZE
  996: 1  033C	28					ADD	A,R0
  997: 1  033D	F9					MOV	R1,A
  998: 1  033E	22					RET
  999: 1				;
 1000: 1				;***************************************************************
 1001: 1				;
 1002: 1  033F			MUL_DIV_EXP_AND_SIGN:
 1003: 1				;
 1004: 1				; Load the sign into R7, R6. R5 gets the sign for
 1005: 1				; multiply and divide.
 1006: 1				;
 1007: 1				;***************************************************************
 1008: 1				;
 1009: 1  033F	51 8C					ACALL	FP_CLEAR			;CLEAR INTERNAL MEMORY
 1010: 1				;
 1011: 1  0341	71 38		MDES1:			ACALL	LOAD_POINTERS			;LOAD REGISTERS
 1012: 1  0343	E6					MOV	A,@R0				;ARG 1 EXP
 1013: 1  0344	FF					MOV	R7,A				;SAVED IN R7
 1014: 1  0345	E7					MOV	A,@R1				;ARG 2 EXP
 1015: 1  0346	FE					MOV	R6,A				;SAVED IN R6
 1016: 1  0347	18					DEC	R0				;BUMP POINTERS TO SIGN
 1017: 1  0348	19					DEC	R1
 1018: 1  0349	E6					MOV	A,@R0				;GET THE SIGN
 1019: 1  034A	FC					MOV	R4,A				;SIGN OF ARG1
 1020: 1  034B	E7					MOV	A,@R1				;GET SIGN OF NEXT ARG
 1021: 1  034C	FB					MOV	R3,A				;SIGN OF ARG2
 1022: 1  034D	6C					XRL	A,R4				;ACC GETS THE NEW SIGN
 1023: 1  034E	FD					MOV	R5,A				;R5 GETS THE NEW SIGN
 1024: 1				;
 1025: 1				; Bump the pointers to point at the LS digit
 1026: 1				;
 1027: 1  034F	18					DEC	R0
 1028: 1  0350	19					DEC	R1
 1029: 1				;
 1030: 1  0351	22					RET
 1031: 1				;
 1032: 1				;***************************************************************
 1033: 1				;
 1034: 1  0352			LOADR1_MANTISSA:
 1035: 1				;
 1036: 1				; Load the mantissa of R0 into FP_Digits
 1037: 1				;

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 20



 Line  I  Addr  Code            Source

 1038: 1				;***************************************************************
 1039: 1				;
 1040: 1  0352	C0 00					PUSH	R0B0				;SAVE REGISTER 1
 1041: 1  0354	78 2E					MOV	R0,#FP_DIG78			;SET UP THE POINTER
 1042: 1				;
 1043: 1  0356	E7		LOADR1:			MOV	A,@R1
 1044: 1  0357	F6					MOV	@R0,A
 1045: 1  0358	19					DEC	R1
 1046: 1  0359	18					DEC	R0
 1047: 1  035A	B8 2A F9				CJNE	R0,#FP_CARRY,LOADR1
 1048: 1				;
 1049: 1  035D	D0 00					POP	R0B0
 1050: 1  035F	22					RET
 1051: 1				;
 1052: 1				;***************************************************************
 1053: 1				;
 1054: 1  0360			HEXSCAN:	; Scan a string to determine if it is a hex number
 1055: 1					; set carry if hex, else carry = 0
 1056: 1				;
 1057: 1				;***************************************************************
 1058: 1				;
 1059: 1  0360	91 22					ACALL	GET_R1_CHARACTER
 1060: 1				;
 1061: 1  0362	E7		HEXSC1:			MOV	A,@R1				;GET THE CHARACTER
 1062: 1  0363	B1 EB					ACALL	DIGIT_CHECK			;SEE IF A DIGIT
 1063: 1  0365	40 0E					JC	HS1				;CONTINUE IF A DIGIT
 1064: 1  0367	71 78					ACALL	HEX_CHECK			;SEE IF HEX
 1065: 1  0369	40 0A					JC	HS1
 1066: 1				;
 1067: 1  036B	C2 E5					CLR	ACC.5				;NO LOWER CASE
 1068: 1  036D	B4 48 03				CJNE	A,#'H',HEXDON
 1069: 1  0370	D3					SETB	C
 1070: 1  0371	80 01					SJMP	HEXDO1				;NUMBER IS VALID HEX, MAYBE
 1071: 1				;
 1072: 1  0373	C3		HEXDON:			CLR	C
 1073: 1				;
 1074: 1  0374	22		HEXDO1:			RET
 1075: 1				;
 1076: 1  0375	09		HS1:			INC	R1				;BUMP TO NEXT CHARACTER
 1077: 1  0376	80 EA					SJMP	HEXSC1				;LOOP
 1078: 1				;
 1079: 1  0378			HEX_CHECK:	;CHECK FOR A VALID ASCII HEX, SET CARRY IF FOUND
 1080: 1				;
 1081: 1  0378	C2 E5					CLR	ACC.5				;WASTE LOWER CASE
 1082: 1						CMP	A,#'F'+1			;SEE IF F OR LESS
 1083+ 2  037A	B4 47 00	CJNE	A,#'F'+1,$+3
 1084: 1  037D	40 01					JC	HC1
 1085: 1  037F	22					RET
 1086: 1				;
 1087: 1  0380			HC1:			CMP	A,#'A'				;SEE IF A OR GREATER
 1088+ 2  0380	B4 41 00	CJNE	A,#'A',$+3
 1089: 1  0383	B3					CPL	C
 1090: 1  0384	22					RET
 1091: 1				;
 1092: 1				;***************************************************************
 1093: 1				;

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 21



 Line  I  Addr  Code            Source

 1094: 1  0385			FLOATING_POINT_INPUT:	; Input a floating point number pointed to by R1
 1095: 1				;
 1096: 1				;***************************************************************
 1097: 1				;
 1098: 1  0385	51 8C					ACALL	FP_CLEAR			;CLEAR EVERYTHING
 1099: 1  0387	91 22					ACALL	GET_R1_CHARACTER
 1100: 1  0389	91 28					ACALL	PLUS_MINUS_TEST
 1101: 1  038B	92 78					MOV	MSIGN,C				;SAVE THE MANTISSA SIGN
 1102: 1				;
 1103: 1				; Now, set up for input loop
 1104: 1				;
 1105: 1  038D	78 34					MOV	R0,#FP_ACCC
 1106: 1  038F	7E 7F					MOV	R6,#7FH				;BASE EXPONENT
 1107: 1  0391	D2 D5					SETB	F0				;SET INITIAL FLAG
 1108: 1				;
 1109: 1  0393	B1 E9		INLOOP:			ACALL	GET_DIGIT_CHECK
 1110: 1  0395	50 07					JNC	GTEST				;IF NOT A CHARACTER, WHAT IS IT?
 1111: 1  0397	54 0F					ANL	A,#0FH				;STRIP ASCII
 1112: 1  0399	71 FB					ACALL	STDIG				;STORE THE DIGITS
 1113: 1				;
 1114: 1  039B	09		INLPIK:			INC	R1				;BUMP POINTER FOR LOOP
 1115: 1  039C	80 F5					SJMP	INLOOP				;LOOP FOR INPUT
 1116: 1				;
 1117: 1  039E	B4 2E 0C	GTEST:			CJNE	A,#'.',GT1			;SEE IF A RADIX
 1118: 1  03A1	20 51 63				JB	FOUND_RADIX,INERR
 1119: 1  03A4	D2 51					SETB	FOUND_RADIX
 1120: 1  03A6	B8 34 F2				CJNE	R0,#FP_ACCC,INLPIK
 1121: 1  03A9	D2 52					SETB	FIRST_RADIX			;SET IF FIRST RADIX
 1122: 1  03AB	80 EE					SJMP	INLPIK				;GET ADDITIONAL DIGITS
 1123: 1				;
 1124: 1  03AD	20 D5 57	GT1:			JB	F0,INERR			;ERROR IF NOT CLEARED
 1125: 1  03B0	B4 65 02				CJNE	A,#'e',GT11			;CHECK FOR LOWER CASE
 1126: 1  03B3	80 03					SJMP	GT12
 1127: 1  03B5	B4 45 33	GT11:			CJNE	A,#'E',FINISH_UP
 1128: 1  03B8	91 21		GT12:			ACALL	INC_AND_GET_R1_CHARACTER
 1129: 1  03BA	91 28					ACALL	PLUS_MINUS_TEST
 1130: 1  03BC	92 50					MOV	XSIGN,C				;SAVE SIGN STATUS
 1131: 1  03BE	B1 E9					ACALL	GET_DIGIT_CHECK
 1132: 1  03C0	50 45					JNC	INERR
 1133: 1				;
 1134: 1  03C2	54 0F					ANL	A,#0FH				;STRIP ASCII BIAS OFF THE CHARACTER
 1135: 1  03C4	FD					MOV	R5,A				;SAVE THE CHARACTER IN R5
 1136: 1				;
 1137: 1  03C5	09		GT2:			INC	R1
 1138: 1  03C6	B1 E9					ACALL	GET_DIGIT_CHECK
 1139: 1  03C8	50 0D					JNC	FINISH1
 1140: 1  03CA	54 0F					ANL	A,#0FH				;STRIP OFF BIAS
 1141: 1  03CC	CD					XCH	A,R5				;GET THE LAST DIGIT
 1142: 1  03CD	75 F0 0A				MOV	B,#10				;MULTIPLY BY TEN
 1143: 1  03D0	A4					MUL	AB
 1144: 1  03D1	2D					ADD	A,R5				;ADD TO ORIGINAL VALUE
 1145: 1  03D2	FD					MOV	R5,A				;SAVE IN R5
 1146: 1  03D3	50 F0					JNC	GT2					;LOOP IF NO CARRY
 1147: 1  03D5	7D FF					MOV	R5,#0FFH			;FORCE AN ERROR
 1148: 1				;
 1149: 1  03D7	ED		FINISH1:		MOV	A,R5				;GET THE SIGN

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 22



 Line  I  Addr  Code            Source

 1150: 1  03D8	30 50 09				JNB	XSIGN,POSNUM			;SEE IF EXPONENT IS POS OR NEG
 1151: 1  03DB	C3					CLR	C
 1152: 1  03DC	9E					SUBB	A,R6
 1153: 1  03DD	F4					CPL	A
 1154: 1  03DE	04					INC	A
 1155: 1  03DF	40 09					JC	FINISH2
 1156: 1  03E1	74 01					MOV	A,#01H
 1157: 1  03E3	22					RET
 1158: 1				;
 1159: 1  03E4	2E		POSNUM:			ADD	A,R6				;ADD TO EXPONENT
 1160: 1  03E5	50 03					JNC	FINISH2
 1161: 1				;
 1162: 1  03E7	74 02		POSNM1:			MOV	A,#02H
 1163: 1  03E9	22					RET
 1164: 1				;
 1165: 1  03EA	CE		FINISH2:		XCH	A,R6				;SAVE THE EXPONENT
 1166: 1				;
 1167: 1  03EB			FINISH_UP:
 1168: 1				;
 1169: 1  03EB	8E 30					MOV	FP_EXP,R6			;SAVE EXPONENT
 1170: 1  03ED	B8 34 02				CJNE	R0,#FP_ACCC,FINISH_UP1
 1171: 1  03F0	51 8C					ACALL	FP_CLEAR			;CLEAR THE MEMORY IF 0
 1172: 1  03F2	E5 24		FINISH_UP1:		MOV	A,ARG_STACK			;GET THE ARG STACK
 1173: 1  03F4	C3					CLR	C
 1174: 1  03F5	94 0C					SUBB	A,#FP_NUMBER_SIZE+FP_NUMBER_SIZE
 1175: 1  03F7	F5 24					MOV	ARG_STACK,A			;ADJUST FOR STORE
 1176: 1  03F9	21 FD					AJMP	PACK
 1177: 1				;
 1178: 1  03FB	C2 D5		STDIG:			CLR	F0				;CLEAR INITIAL DESIGNATOR
 1179: 1  03FD	70 0B					JNZ	STDIG1				;CONTINUE IF NOT ZERO
 1180: 1  03FF	B8 34 08				CJNE	R0,#FP_ACCC,STDIG1
 1181: 1  0402	30 52 04				JNB	FIRST_RADIX,RET_X
 1182: 1				;
 1183: 1  0405	DE 02		DECX:			DJNZ	R6,RET_X
 1184: 1				;
 1185: 1  0407	74 FF		INERR:			MOV	A,#0FFH
 1186: 1				;
 1187: 1  0409	22		RET_X:			RET
 1188: 1				;
 1189: 1  040A	20 53 02	STDIG1:			JB	DONE_LOAD,FRTEST
 1190: 1  040D	C2 52					CLR	FIRST_RADIX
 1191: 1				;
 1192: 1  040F	20 52 F3	FRTEST:			JB	FIRST_RADIX,DECX
 1193: 1				;
 1194: 1  0412	20 51 01	FDTEST:			JB	FOUND_RADIX,FDT1
 1195: 1  0415	0E					INC	R6
 1196: 1				;
 1197: 1  0416	20 53 F0	FDT1:			JB	DONE_LOAD,RET_X
 1198: 1  0419	B8 3D 02				CJNE	R0,#FP_ACC8+1,FDT2
 1199: 1  041C	D2 53					SETB	DONE_LOAD
 1200: 1				;
 1201: 1  041E	F6		FDT2:			MOV	@R0,A				;SAVE THE STRIPPED ACCUMULATOR
 1202: 1  041F	08					INC	R0				;BUMP THE POINTER
 1203: 1  0420	22					RET					;EXIT
 1204: 1				;
 1205: 1				;***************************************************************

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 23



 Line  I  Addr  Code            Source

 1206: 1				;
 1207: 1				; I/O utilities
 1208: 1				;
 1209: 1				;***************************************************************
 1210: 1				;
 1211: 1  0421			INC_AND_GET_R1_CHARACTER:
 1212: 1				;
 1213: 1  0421	09					INC	R1
 1214: 1				;
 1215: 1  0422			GET_R1_CHARACTER:
 1216: 1				;
 1217: 1  0422	E7					MOV	A,@R1				;GET THE CHARACTER
 1218: 1  0423	B4 20 0C				CJNE	A,#' ',PMT1			;SEE IF A SPACE
 1219: 1				;
 1220: 1				; Kill spaces
 1221: 1				;
 1222: 1  0426	80 F9					SJMP	INC_AND_GET_R1_CHARACTER
 1223: 1				;
 1224: 1  0428			PLUS_MINUS_TEST:
 1225: 1				;
 1226: 1  0428	B4 2B 02				CJNE	A,#'+',PMT0
 1227: 1  042B	80 04					SJMP	PMT3
 1228: 1  042D	B4 2D 02	PMT0:			CJNE	A,#'-',PMT1
 1229: 1				;
 1230: 1  0430	D3		PMT2:			SETB	C
 1231: 1				;
 1232: 1  0431	09		PMT3:			INC	R1
 1233: 1				;
 1234: 1  0432	22		PMT1:			RET
 1235: 1				;
 1236: 1				;***************************************************************
 1237: 1				;
 1238: 1  0433			FLOATING_POINT_OUTPUT:	; Output the number, format is in location 25
 1239: 1				;
 1240: 1				; IF FORMAT = 00 - FREE FLOATING
 1241: 1				;           = FX - EXPONENTIAL (X IS THE NUMBER OF SIG DIGITS)
 1242: 1				;           = NX - N = NUM BEFORE RADIX, X = NUM AFTER RADIX
 1243: 1				;                  N + X = 8 MAX
 1244: 1				;
 1245: 1				;***************************************************************
 1246: 1				;
 1247: 1  0433	71 41					ACALL	MDES1				;GET THE NUMBER TO OUTPUT, R0 IS POI
       1			NTER
 1248: 1  0435	11 95					ACALL	POP_AND_EXIT			;OUTPUT POPS THE STACK
 1249: 1  0437	EF					MOV	A,R7
 1250: 1  0438	FE					MOV	R6,A				;PUT THE EXPONENT IN R6
 1251: 1  0439	51 58					ACALL	UNPACK_R0			;UNPACK THE NUMBER
 1252: 1  043B	78 2B					MOV	R0,#FP_NIB1			;POINT AT THE NUMBER
 1253: 1  043D	E5 25					MOV	A,FORMAT			;GET THE FORMAT
 1254: 1  043F	FB					MOV	R3,A				;SAVE IN CASE OF EXP FORMAT
 1255: 1  0440	60 49					JZ	FREE				;FREE FLOATING?
 1256: 1						CMP	A,#0F0H				;SEE IF EXPONENTIAL
 1257+ 2  0442	B4 F0 00	CJNE	A,#0F0H,$+3
 1258: 1  0445	50 73					JNC	EXPOUT
 1259: 1				;
 1260: 1				; If here, must be integer USING format

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 24



 Line  I  Addr  Code            Source

 1261: 1				;
 1262: 1  0447	EE					MOV	A,R6				;GET THE EXPONENT
 1263: 1  0448	70 02					JNZ	FPO1
 1264: 1  044A	7E 80					MOV	R6,#80H
 1265: 1  044C	EB		FPO1:			MOV	A,R3				;GET THE FORMAT
 1266: 1  044D	C4					SWAP	A				;SPLIT INTEGER AND FRACTION
 1267: 1  044E	54 0F					ANL	A,#0FH
 1268: 1  0450	FA					MOV	R2,A				;SAVE INTEGER
 1269: 1  0451	B1 20					ACALL	NUM_LT				;GET THE NUMBER OF INTEGERS
 1270: 1  0453	CA					XCH	A,R2				;FLIP FOR SUBB
 1271: 1  0454	C3					CLR	C
 1272: 1  0455	9A					SUBB	A,R2
 1273: 1  0456	FF					MOV	R7,A
 1274: 1  0457	50 06					JNC	FPO2
 1275: 1  0459	7D 3F					MOV	R5,#'?'				;OUTPUT A QUESTION MARK
 1276: 1  045B	B1 55					ACALL	SOUT1				;NUMBER IS TOO LARGE FOR FORMAT
 1277: 1  045D	81 8B					AJMP	FREE
 1278: 1  045F	BA 00 07	FPO2:			CJNE	R2,#00,USING0			;SEE IF ZERO
 1279: 1  0462	1F					DEC	R7
 1280: 1  0463	B1 42					ACALL	SS7
 1281: 1  0465	B1 4F					ACALL	ZOUT				;OUTPUT A ZERO
 1282: 1  0467	80 06					SJMP	USING1
 1283: 1				;
 1284: 1  0469	B1 42		USING0:			ACALL	SS7				;OUTPUT SPACES, IF NEED TO
 1285: 1  046B	EA					MOV	A,R2				;OUTPUT DIGITS
 1286: 1  046C	FF					MOV	R7,A
 1287: 1  046D	B1 04					ACALL	OUTR0
 1288: 1				;
 1289: 1  046F	EB		USING1:			MOV	A,R3
 1290: 1  0470	54 0F					ANL	A,#0FH				;GET THE NUMBER RIGHT OF DP
 1291: 1  0472	FA					MOV	R2,A				;SAVE IT
 1292: 1  0473	60 BD					JZ	PMT1				;EXIT IF ZERO
 1293: 1  0475	B1 4B					ACALL	ROUT				;OUTPUT DP
 1294: 1  0477	B1 29					ACALL	NUM_RT
 1295: 1  0479	B5 02 03				CJNE	A,2,USINGX			;COMPARE A TO R2
 1296: 1				;
 1297: 1  047C	EA		USINGY:			MOV	A,R2
 1298: 1  047D	A1 39					AJMP	Z7R7
 1299: 1				;
 1300: 1  047F	50 FB		USINGX:			JNC	USINGY
 1301: 1				;
 1302: 1  0481	CA		USING2:			XCH	A,R2
 1303: 1  0482	C3					CLR	C
 1304: 1  0483	9A					SUBB	A,R2
 1305: 1  0484	CA					XCH	A,R2
 1306: 1  0485	B1 39					ACALL	Z7R7				;OUTPUT ZEROS IF NEED TO
 1307: 1  0487	EA					MOV	A,R2
 1308: 1  0488	FF					MOV	R7,A
 1309: 1  0489	A1 04					AJMP	OUTR0
 1310: 1				;
 1311: 1				; First, force exponential output, if need to
 1312: 1				;
 1313: 1  048B	EE		FREE:			MOV	A,R6				;GET THE EXPONENT
 1314: 1  048C	70 04					JNZ	FREE1				;IF ZERO, PRINT IT
 1315: 1  048E	B1 53					ACALL	SOUT
 1316: 1  0490	A1 4F					AJMP	ZOUT

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 25



 Line  I  Addr  Code            Source

 1317: 1				;
 1318: 1  0492	7B F0		FREE1:			MOV	R3,#0F0H			;IN CASE EXP NEEDED
 1319: 1  0494	74 77					MOV	A,#80H-DIGIT-DIGIT-1
 1320: 1  0496	2E					ADD	A,R6
 1321: 1  0497	40 21					JC	EXPOUT
 1322: 1  0499	94 F7					SUBB	A,#0F7H
 1323: 1  049B	40 1D					JC	EXPOUT
 1324: 1				;
 1325: 1				; Now, just print the number
 1326: 1				;
 1327: 1  049D	B1 44					ACALL	SINOUT				;PRINT THE SIGN OF THE NUMBER
 1328: 1  049F	B1 20					ACALL	NUM_LT				;GET THE NUMBER LEFT OF DP
 1329: 1  04A1	B4 08 02				CJNE	A,#8,FREE4
 1330: 1  04A4	A1 04					AJMP	OUTR0
 1331: 1				;
 1332: 1  04A6	B1 04		FREE4:			ACALL	OUTR0
 1333: 1  04A8	B1 16					ACALL	ZTEST				;TEST FOR TRAILING ZEROS
 1334: 1  04AA	60 57					JZ	U_RET				;DONE IF ALL TRAILING ZEROS
 1335: 1  04AC	B1 4B					ACALL	ROUT				;OUTPUT RADIX
 1336: 1				;
 1337: 1  04AE	7F 01		FREE2:			MOV	R7,#1				;OUTPUT ONE DIGIT
 1338: 1  04B0	B1 04					ACALL	OUTR0
 1339: 1  04B2	70 4F					JNZ	U_RET
 1340: 1  04B4	B1 16					ACALL	ZTEST
 1341: 1  04B6	60 4B					JZ	U_RET
 1342: 1  04B8	80 F4					SJMP	FREE2				;LOOP
 1343: 1				;
 1344: 1  04BA	B1 44		EXPOUT:			ACALL	SINOUT				;PRINT THE SIGN
 1345: 1  04BC	7F 01					MOV	R7,#1				;OUTPUT ONE CHARACTER
 1346: 1  04BE	B1 04					ACALL	OUTR0
 1347: 1  04C0	B1 4B					ACALL	ROUT				;OUTPUT RADIX
 1348: 1  04C2	EB					MOV	A,R3				;GET FORMAT
 1349: 1  04C3	54 0F					ANL	A,#0FH				;STRIP INDICATOR
 1350: 1  04C5	60 06					JZ	EXPOTX
 1351: 1				;
 1352: 1  04C7	FF					MOV	R7,A				;OUTPUT THE NUMBER OF DIGITS
 1353: 1  04C8	1F					DEC	R7				;ADJUST BECAUSE ONE CHAR ALREADY OUT
 1354: 1  04C9	B1 04					ACALL	OUTR0
 1355: 1  04CB	80 02					SJMP	EXPOT4
 1356: 1				;
 1357: 1  04CD	91 AE		EXPOTX:			ACALL	FREE2				;OUTPUT UNTIL TRAILING ZEROS
 1358: 1				;
 1359: 1  04CF	B1 53		EXPOT4:			ACALL	SOUT				;OUTPUT A SPACE
 1360: 1  04D1	7D 45					MOV	R5,#'E'
 1361: 1  04D3	B1 55					ACALL	SOUT1				;OUTPUT AN E
 1362: 1  04D5	EE					MOV	A,R6				;GET THE EXPONENT
 1363: 1  04D6	60 04					JZ	XOUT0				;EXIT IF ZERO
 1364: 1  04D8	14					DEC	A				;ADJUST FOR THE DIGIT ALREADY OUTPUT
 1365: 1  04D9	B4 80 05				CJNE	A,#80H,XOUT2			;SEE WHAT IT IS
 1366: 1				;
 1367: 1  04DC	B1 53		XOUT0:			ACALL	SOUT
 1368: 1  04DE	E4					CLR	A
 1369: 1  04DF	80 0C					SJMP	XOUT4
 1370: 1				;
 1371: 1  04E1	40 06		XOUT2:			JC	XOUT3				;NEGATIVE EXPONENT
 1372: 1  04E3	7D 2B					MOV	R5,#'+'				;OUTPUT A PLUS SIGN

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 26



 Line  I  Addr  Code            Source

 1373: 1  04E5	B1 55					ACALL	SOUT1
 1374: 1  04E7	80 04					SJMP	XOUT4
 1375: 1				;
 1376: 1  04E9	B1 47		XOUT3:			ACALL	MOUT
 1377: 1  04EB	F4					CPL	A				;FLIP BITS
 1378: 1  04EC	04					INC	A				;BUMP
 1379: 1				;
 1380: 1  04ED	C2 E7		XOUT4:			CLR	ACC.7
 1381: 1  04EF	F8					MOV	R0,A
 1382: 1  04F0	7A 00					MOV	R2,#0
 1383: 1  04F2	79 27					MOV	R1,#LOW CONVT			;CONVERSION LOCATION
 1384: 1  04F4	7B 00					MOV	R3,#HIGH CONVT
 1385: 1  04F6	B1 7B					ACALL	CONVERT_BINARY_TO_ASCII_STRING
 1386: 1  04F8	78 27					MOV	R0,#LOW CONVT			;NOW, OUTPUT EXPONENT
 1387: 1				;
 1388: 1  04FA	E6		EXPOT5:			MOV	A,@R0				;GET THE CHARACTER
 1389: 1  04FB	FD					MOV	R5,A				;OUTPUT IT
 1390: 1  04FC	B1 55					ACALL	SOUT1
 1391: 1  04FE	08					INC	R0				;BUMP THE POINTER
 1392: 1  04FF	E8					MOV	A,R0				;GET THE POINTER
 1393: 1  0500	B5 01 F7				CJNE	A,R1B0,EXPOT5			;LOOP
 1394: 1				;
 1395: 1  0503	22		U_RET:			RET					;EXIT
 1396: 1				;
 1397: 1  0504			OUTR0:	; Output the characters pointed to by R0, also bias ascii
 1398: 1				;
 1399: 1  0504	EF					MOV	A,R7				;GET THE COUNTER
 1400: 1  0505	60 0E					JZ	OUTR				;EXIT IF DONE
 1401: 1  0507	E6					MOV	A,@R0				;GET THE NUMBER
 1402: 1  0508	44 30					ORL	A,#30H				;ASCII BIAS
 1403: 1  050A	08					INC	R0				;BUMP POINTER AND COUNTER
 1404: 1  050B	1F					DEC	R7
 1405: 1  050C	FD					MOV	R5,A				;PUT CHARACTER IN OUTPUT REGISTER
 1406: 1  050D	B1 55					ACALL	SOUT1				;OUTPUT THE CHARACTER
 1407: 1  050F	E4					CLR	A				;JUST FOR TEST
 1408: 1  0510	B8 33 F1				CJNE	R0,#FP_NIB8+1,OUTR0
 1409: 1  0513	74 55					MOV	A,#55H				;KNOW WHERE EXIT OCCURED
 1410: 1				;
 1411: 1  0515	22		OUTR:			RET
 1412: 1				;
 1413: 1  0516	A9 00		ZTEST:			MOV	R1,R0B0				;GET POINTER REGISTER
 1414: 1				;
 1415: 1  0518	E7		ZT0:			MOV	A,@R1				;GET THE VALUE
 1416: 1  0519	70 04					JNZ	ZT1
 1417: 1  051B	09					INC	R1				;BUMP POINTER
 1418: 1  051C	B9 33 F9				CJNE	R1,#FP_NIB8+1,ZT0
 1419: 1				;
 1420: 1  051F	22		ZT1:			RET
 1421: 1				;
 1422: 1  0520	EE		NUM_LT:			MOV	A,R6				;GET EXPONENT
 1423: 1  0521	C3					CLR	C				;GET READY FOR SUBB
 1424: 1  0522	94 80					SUBB	A,#80H				;SUB EXPONENT BIAS
 1425: 1  0524	50 01					JNC	NL1				;OK IF NO CARRY
 1426: 1  0526	E4					CLR	A				;NO DIGITS LEFT
 1427: 1				;
 1428: 1  0527	FF		NL1:			MOV	R7,A				;SAVE THE COUNT

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 27



 Line  I  Addr  Code            Source

 1429: 1  0528	22					RET
 1430: 1				;
 1431: 1  0529	C3		NUM_RT:			CLR	C				;SUBB AGAIN
 1432: 1  052A	74 80					MOV	A,#80H				;EXPONENT BIAS
 1433: 1  052C	9E					SUBB	A,R6				;GET THE BIASED EXPONENT
 1434: 1  052D	50 01					JNC	NR1
 1435: 1  052F	E4					CLR	A
 1436: 1				;
 1437: 1  0530	22		NR1:			RET					;EXIT
 1438: 1				;
 1439: 1  0531	EF		SPACE7:			MOV	A,R7				;GET THE NUMBER OF SPACES
 1440: 1  0532	60 FC					JZ	NR1				;EXIT IF ZERO
 1441: 1  0534	B1 53					ACALL	SOUT				;OUTPUT A SPACE
 1442: 1  0536	1F					DEC	R7				;BUMP COUNTER
 1443: 1  0537	80 F8					SJMP	SPACE7				;LOOP
 1444: 1				;
 1445: 1  0539	FF		Z7R7:			MOV	R7,A
 1446: 1				;
 1447: 1  053A	EF		ZERO7:			MOV	A,R7				;GET COUNTER
 1448: 1  053B	60 F3					JZ	NR1				;EXIT IF ZERO
 1449: 1  053D	B1 4F					ACALL	ZOUT				;OUTPUT A ZERO
 1450: 1  053F	1F					DEC	R7				;BUMP COUNTER
 1451: 1  0540	80 F8					SJMP	ZERO7				;LOOP
 1452: 1				;
 1453: 1  0542	B1 31		SS7:			ACALL	SPACE7
 1454: 1				;
 1455: 1  0544	EC		SINOUT:			MOV	A,R4				;GET THE SIGN
 1456: 1  0545	60 0C					JZ	SOUT				;OUTPUT A SPACE IF ZERO
 1457: 1				;
 1458: 1  0547	7D 2D		MOUT:			MOV	R5,#'-'
 1459: 1  0549	80 0A					SJMP	SOUT1				;OUTPUT A MINUS IF NOT
 1460: 1				;
 1461: 1  054B	7D 2E		ROUT:			MOV	R5,#'.'				;OUTPUT A RADIX
 1462: 1  054D	80 06					SJMP	SOUT1
 1463: 1				;
 1464: 1  054F	7D 30		ZOUT:			MOV	R5,#'0'				;OUTPUT A ZERO
 1465: 1  0551	80 02					SJMP	SOUT1
 1466: 1				;
 1467: 1  0553	7D 20		SOUT:			MOV	R5,#' '				;OUTPUT A SPACE
 1468: 1				;
 1469: 1  0555	A1 F6		SOUT1:			AJMP	R5OUT
 1470: 1				;
 1471: 1				;
 1472: 1  0557	75 F0 0A	MULNUM10:		MOV	B,#10
 1473: 1				;
 1474: 1				;***************************************************************
 1475: 1				;
 1476: 1  055A			MULNUM:	; Take the next digit in the acc (masked to 0FH)
 1477: 1				; accumulate in R3:R1
 1478: 1				;
 1479: 1				;***************************************************************
 1480: 1				;
 1481: 1  055A	C0 E0					PUSH	ACC				;SAVE ACC
 1482: 1  055C	C0 F0					PUSH	B				;SAVE MULTIPLIER
 1483: 1  055E	E9					MOV	A,R1				;PUT LOW ORDER BITS IN ACC
 1484: 1  055F	A4					MUL	AB				;DO THE MULTIPLY

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 28



 Line  I  Addr  Code            Source

 1485: 1  0560	F9					MOV	R1,A				;PUT THE RESULT BACK
 1486: 1  0561	EB					MOV	A,R3				;GET THE HIGH ORDER BYTE
 1487: 1  0562	AB F0					MOV	R3,B				;SAVE THE OVERFLOW
 1488: 1  0564	D0 F0					POP	B				;GET THE MULTIPLIER
 1489: 1  0566	A4					MUL	AB				;DO IT
 1490: 1  0567	A2 D2					MOV	C,OV				;SAVE OVERFLOW IN F0
 1491: 1  0569	92 D5					MOV	F0,C
 1492: 1  056B	2B					ADD	A,R3				;ADD OVERFLOW TO HIGH RESULT
 1493: 1  056C	FB					MOV	R3,A				;PUT IT BACK
 1494: 1  056D	D0 E0					POP	ACC				;GET THE ORIGINAL ACC BACK
 1495: 1  056F	72 D5					ORL	C,F0				;OR CARRY AND OVERFLOW
 1496: 1  0571	40 07					JC	MULX				;NO GOOD IF THE CARRY IS SET
 1497: 1				;
 1498: 1  0573	54 0F		MUL11:			ANL	A,#0FH				;MASK OFF HIGH ORDER BITS
 1499: 1  0575	29					ADD	A,R1				;NOW ADD THE ACC
 1500: 1  0576	F9					MOV	R1,A				;PUT IT BACK
 1501: 1  0577	E4					CLR	A				;PROPAGATE THE CARRY
 1502: 1  0578	3B					ADDC	A,R3
 1503: 1  0579	FB					MOV	R3,A				;PUT IT BACK
 1504: 1				;
 1505: 1  057A	22		MULX:			RET					;EXIT WITH OR WITHOUT CARRY
 1506: 1				;
 1507: 1				;***************************************************************
 1508: 1				;
 1509: 1  057B			CONVERT_BINARY_TO_ASCII_STRING:
 1510: 1				;
 1511: 1				;R1 contains the address of the string
 1512: 1				;R0 contains the value to convert
 1513: 1				;DPTR, R7, R6, and ACC gets clobbered
 1514: 1				;
 1515: 1				;***************************************************************
 1516: 1				;
 1517: 1  057B	E4					CLR	A				;NO LEADING ZEROS
 1518: 1  057C	90 27 10				MOV	DPTR,#10000			;SUBTRACT 10000
 1519: 1  057F	B1 98					ACALL	RSUB				;DO THE SUBTRACTION
 1520: 1  0581	90 03 E8				MOV	DPTR,#1000			;NOW 1000
 1521: 1  0584	B1 98					ACALL	RSUB
 1522: 1  0586	90 00 64				MOV	DPTR,#100			;NOW 100
 1523: 1  0589	B1 98					ACALL	RSUB
 1524: 1  058B	90 00 0A				MOV	DPTR,#10			;NOW 10
 1525: 1  058E	B1 98					ACALL	RSUB
 1526: 1  0590	90 00 01				MOV	DPTR,#1				;NOW 1
 1527: 1  0593	B1 98					ACALL	RSUB
 1528: 1  0595	60 20					JZ	RSUB2				;JUMP OVER RET
 1529: 1				;
 1530: 1  0597	22		RSUB_R:			RET
 1531: 1				;
 1532: 1  0598	7E FF		RSUB:			MOV	R6,#-1				;SET UP THE COUNTER
 1533: 1				;
 1534: 1  059A	0E		RSUB1:			INC	R6				;BUMP THE COUNTER
 1535: 1  059B	CA					XCH	A,R2				;DO A FAST COMPARE
 1536: 1						CMP	A,DPH
 1537+ 2  059C	B5 83 00	CJNE	A,DPH,$+3
 1538: 1  059F	CA					XCH	A,R2
 1539: 1  05A0	40 12					JC	FAST_DONE
 1540: 1  05A2	C8					XCH	A,R0				;GET LOW BYTE

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 29



 Line  I  Addr  Code            Source

 1541: 1  05A3	95 82					SUBB	A,DPL				;SUBTRACT, CARRY IS CLEARED
 1542: 1  05A5	C8					XCH	A,R0				;PUT IT BACK
 1543: 1  05A6	CA					XCH	A,R2				;GET THE HIGH BYTE
 1544: 1  05A7	95 83					SUBB	A,DPH				;ADD THE HIGH BYTE
 1545: 1  05A9	CA					XCH	A,R2				;PUT IT BACK
 1546: 1  05AA	50 EE					JNC	RSUB1				;LOOP UNTIL CARRY
 1547: 1				;
 1548: 1  05AC	C8					XCH	A,R0
 1549: 1  05AD	25 82					ADD	A,DPL				;RESTORE R2:R0
 1550: 1  05AF	C8					XCH	A,R0
 1551: 1  05B0	CA					XCH	A,R2
 1552: 1  05B1	35 83					ADDC	A,DPH
 1553: 1  05B3	CA					XCH	A,R2
 1554: 1				;
 1555: 1  05B4			FAST_DONE:
 1556: 1				;
 1557: 1  05B4	4E					ORL	A,R6				;OR THE COUNT VALUE
 1558: 1  05B5	60 E0					JZ	RSUB_R				;RETURN IF ZERO
 1559: 1				;
 1560: 1  05B7	74 30		RSUB2:			MOV	A,#'0'				;GET THE ASCII BIAS
 1561: 1  05B9	2E					ADD	A,R6				;ADD THE COUNT
 1562: 1				;
 1563: 1  05BA	F7		RSUB4:			MOV	@R1,A				;PLACE THE VALUE IN MEMORY
 1564: 1  05BB	09					INC	R1
 1565: 1				;
 1566: 1  05BC	22					RET					;EXIT
 1567: 1				;
 1568: 1				;***************************************************************
 1569: 1				;
 1570: 1  05BD			HEXOUT:	; Output the hex number in R3:R1, supress leading zeros, if set
 1571: 1				;
 1572: 1				;***************************************************************
 1573: 1				;
 1574: 1  05BD	B1 53					ACALL	SOUT				;OUTPUT A SPACE
 1575: 1  05BF	A2 36					MOV	C,ZSURP				;GET ZERO SUPPRESSION BIT
 1576: 1  05C1	92 33					MOV	ADD_IN,C
 1577: 1  05C3	EB					MOV	A,R3				;GET HIGH NIBBLE AND PRINT IT
 1578: 1  05C4	B1 E0					ACALL	HOUTHI
 1579: 1  05C6	EB					MOV	A,R3
 1580: 1  05C7	B1 E1					ACALL	HOUTLO
 1581: 1				;
 1582: 1  05C9	C2 33		HEX2X:			CLR	ADD_IN				;DON'T SUPPRESS ZEROS
 1583: 1  05CB	E9					MOV	A,R1				;GET LOW NIBBLE AND PRINT IT
 1584: 1  05CC	B1 E0					ACALL	HOUTHI
 1585: 1  05CE	E9					MOV	A,R1
 1586: 1  05CF	B1 E1					ACALL	HOUTLO
 1587: 1  05D1	7D 48					MOV	R5,#'H'				;OUTPUT H TO INDICATE HEX MODE
 1588: 1				;
 1589: 1  05D3	A1 55		SOUT_1:			AJMP	SOUT1
 1590: 1				;
 1591: 1  05D5	C2 33		HOUT1:			CLR	ADD_IN				;PRINTED SOMETHING, SO CLEAR ADD_IN
 1592: 1  05D7	24 90					ADD	A,#90H				;CONVERT TO ASCII
 1593: 1  05D9	D4					DA	A
 1594: 1  05DA	34 40					ADDC	A,#40H
 1595: 1  05DC	D4					DA	A				;GOT IT HERE
 1596: 1  05DD	FD					MOV	R5,A				;OUTPUT THE BYTE

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 30



 Line  I  Addr  Code            Source

 1597: 1  05DE	80 F3					SJMP	SOUT_1
 1598: 1				;
 1599: 1  05E0	C4		HOUTHI:			SWAP	A				;SWAP TO OUTPUT HIGH NIBBLE
 1600: 1				;
 1601: 1  05E1	54 0F		HOUTLO:			ANL	A,#0FH				;STRIP
 1602: 1  05E3	70 F0					JNZ	HOUT1				;PRINT IF NOT ZERO
 1603: 1  05E5	30 33 ED				JNB	ADD_IN,HOUT1			;OUTPUT A ZERO IF NOT SUPRESSED
 1604: 1  05E8	22					RET
 1605: 1				;
 1606: 1				;
 1607: 1  05E9			GET_DIGIT_CHECK:	; Get a character, then check for digit
 1608: 1				;
 1609: 1  05E9	91 22					ACALL	GET_R1_CHARACTER
 1610: 1				;
 1611: 1  05EB			DIGIT_CHECK:	;CHECK FOR A VALID ASCII DIGIT, SET CARRY IF FOUND
 1612: 1				;
 1613: 1						CMP	A,#'9'+1			;SEE IF ASCII 9 OR LESS
 1614+ 2  05EB	B4 3A 00	CJNE	A,#'9'+1,$+3
 1615: 1  05EE	40 01					JC	DC1
 1616: 1  05F0	22					RET
 1617: 1				;
 1618: 1  05F1			DC1:			CMP	A,#'0'				;SEE IF ASCII 0 OR GREATER
 1619+ 2  05F1	B4 30 00	CJNE	A,#'0',$+3
 1620: 1  05F4	B3					CPL	C
 1621: 1  05F5	22					RET
 1622: 1				;
 1623: 1
 1624: 1  05F6	C0 E0		R5OUT:			PUSH	ACC				; ME
 1625: 1  05F8	C0 00					PUSH	00H
 1626: 1  05FA	A8 50					MOV	R0,FPCHR_OUT
 1627: 1  05FC	ED					MOV	A,R5				; ME
 1628: 1  05FD	F6					MOV	@R0,A
 1629: 1  05FE	05 50					INC	FPCHR_OUT
 1630: 1  0600	D0 00					POP	00H
 1631: 1  0602	D0 E0					POP	ACC				; ME
 1632: 1  0604	22					RET
 1633: 1
 1634: 1  0605	01 7B		SQ_ERR:			JMP	BADPRM				; me
 1635: 1
 1636: 1			; Pop the ARG STACK and check for overflow
 1637: 1  0607			INC_ASTKA:
 1638: 1  0607	74 06					MOV	A,#FP_NUMBER_SIZE		;number to pop
 1639: 1  0609	80 16					SJMP	SETREG1
 1640: 1
 1641: 1			;Push ARG STACK and check for underflow
 1642: 1  060B			DEC_ASTKA:
 1643: 1  060B	74 FA					MOV	A,#-FP_NUMBER_SIZE
 1644: 1  060D	25 24					ADD	A,ARG_STACK
 1645: 1						CMP	A,#0
 1646+ 2  060F	B4 00 00	CJNE	A,#0,$+3
 1647: 1  0612	40 28					JC	E4YY
 1648: 1  0614	F5 24					MOV	ARG_STACK,A
 1649: 1  0616	F9					MOV	R1,A
 1650: 1  0617	22		SRT:			RET
 1651: 1
 1652: 1  0618	D1 07		POPAS:			ACALL	INC_ASTKA

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 31



 Line  I  Addr  Code            Source

 1653: 1  061A	C1 33					AJMP	VARCOP				;COPY THE VARIABLE
 1654: 1
 1655: 1  061C	D1 0B		PUSHAS:			ACALL	DEC_ASTKA
 1656: 1  061E	C1 33					AJMP	VARCOP
 1657: 1
 1658: 1  0620	E4		SETREG:			CLR	A				;DON'T POP ANYTHING
 1659: 1  0621	A8 24		SETREG1:		MOV	R0,ARG_STACK
 1660: 1  0623	28					ADD	A,R0
 1661: 1  0624	40 16					JC	E4YY
 1662: 1  0626	F5 24					MOV	ARG_STACK,A
 1663: 1  0628	E6					MOV	A,@R0
 1664: 1  0629	22		A_D:			RET
 1665: 1
 1666: 1			;Routine to copy bottom arg on stack to address in R1.
 1667: 1  062A	D1 20		MOVAS:  		ACALL   SETREG				;SET UP R0
 1668: 1  062C	E6		M_C:			MOV	A,@R0				;READ THE VALUE
 1669: 1  062D	F7					MOV	@R1,A				;SAVE IT
 1670: 1  062E	08		        		INC     R0
 1671: 1  062F	09		        		INC     R1
 1672: 1  0630	DC FA		        		DJNZ    R4,M_C  	        	;LOOP
 1673: 1  0632	22					RET					;EXIT
 1674: 1
 1675: 1
 1676: 1			; VARCOP - Copy a variable from R0 to R1
 1677: 1  0633	7C 06		VARCOP:			MOV	R4,#FP_NUMBER_SIZE		;LOAD THE LOOP COUNTER
 1678: 1  0635	E6		V_C:			MOV	A,@R0				;READ THE VALUE
 1679: 1  0636	F7					MOV	@R1,A				;SAVE IT
 1680: 1  0637	18					DEC	R0
 1681: 1  0638	19					DEC	R1
 1682: 1  0639	DC FA					DJNZ	R4,V_C				;LOOP
 1683: 1  063B	22					RET					;EXIT
 1684: 1			;
 1685: 1  063C	90 06 6F	E4YY:			MOV	DPTR,#EXA
 1686: 1  063F	01 7A					JMP	PRTERR				; me
 1687: 1
 1688: 1				; integer operator - INT
 1689: 1  0641	D1 20		AINT:			ACALL	SETREG				;SET UP THE REGISTERS, CLEAR CARRY
 1690: 1  0643	94 81					SUBB	A,#129				;SUBTRACT EXPONENT BIAS
 1691: 1  0645	50 07					JNC	AI1				;JUMP IF ACC > 81H
 1692: 1				;
 1693: 1				; Force the number to be a zero
 1694: 1				;
 1695: 1  0647	D1 07					ACALL	INC_ASTKA			;BUMP THE STACK
 1696: 1				;
 1697: 1  0649	90 06 77	P_Z:			MOV	DPTR,#ZRO			;PUT ZERO ON THE STACK
 1698: 1  064C	C1 63					AJMP	PUSHC
 1699: 1				;
 1700: 1  064E	94 07		AI1:			SUBB	A,#7
 1701: 1  0650	50 10					JNC	AI3
 1702: 1  0652	F4					CPL	A
 1703: 1  0653	04					INC	A
 1704: 1  0654	FB					MOV	R3,A
 1705: 1  0655	18					DEC	R0				;POINT AT SIGN
 1706: 1				;
 1707: 1  0656	18		AI2:			DEC	R0				;NOW AT LSB'S
 1708: 1  0657	E6					MOV	A,@R0				;READ BYTE

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 32



 Line  I  Addr  Code            Source

 1709: 1  0658	54 F0					ANL	A,#0F0H				;STRIP NIBBLE
 1710: 1  065A	F6					MOV	@R0,A				;WRITE BYTE
 1711: 1  065B	DB 01					DJNZ	R3,AI21
 1712: 1  065D	22					RET
 1713: 1  065E	E4		AI21:			CLR	A
 1714: 1  065F	F6					MOV	@R0,A				;CLEAR THE LOCATION
 1715: 1  0660	DB F4					DJNZ	R3,AI2
 1716: 1  0662	22		AI3:			RET					;EXIT
 1717: 1				;
 1718: 1				; PUSHC - Push constant pointed by DPTR on to the arg stack
 1719: 1  0663	D1 0B		PUSHC:			ACALL	DEC_ASTKA
 1720: 1  0665	7B 06					MOV	R3,#FP_number_SIZe		;LOOP COUNTER
 1721: 1  0667	E4		PCL:			CLR	A				;SET UP A
 1722: 1  0668	93					MOVC	A,@A+DPTR			;LOAD IT
 1723: 1  0669	F7					MOV	@R1,A				;SAVE IT
 1724: 1  066A	A3					INC	DPTR				;BUMP POINTERS
 1725: 1  066B	19					DEC	R1
 1726: 1  066C	DB F9					DJNZ	R3,PCL				;LOOP
 1727: 1  066E	22					RET					;EXIT
 1728: 1			;
 1729: 1
 1730: 1  066F	41 2D 53 54	EXA:			DB	'A-STACK',0
       1  0673	41 43 4B 00
 1731: 1  0677	00 00 00	ZRO:			DB	00h,00h,00h
 1732: 1  067A	00 00 00				DB	00h,00h,00h			;0.0000000
 1733: 1  067D	81 00 00	FPONE:			DB 	81h,00h,00h
 1734: 1  0680	00 00 10				DB	00h,00h,10h			;1.0000000
 1735: 1  0683	81 00 00	FPTWO:			DB 	81h,00h,00h
 1736: 1  0686	00 00 20				DB	00h,00h,20h			;2.0000000
 1737: 1  0689	81 00 27	FPPI:			DB	81h,00h,27h
 1738: 1  068C	59 41 31				DB	59h,41h,31h			;3.1415927
 1739: 1  068F	77 00 00	FPCCAL:			DB	77h,00h,00h
 1740: 1  0692	00 50 94				DB	00h,50h,94h			;1nF=1e-9
 1741: 1  0695	8D 00 00	FPP:			DB	8Dh,00h,00h
 1742: 1  0698	00 00 10				DB	00h,00h,10h			;1e12
 1743: 1  069B	8A 00 00	FPN:			DB	8Ah,00h,00h
 1744: 1  069E	00 00 10				DB	00h,00h,10h			;1e9
 1745: 1  06A1	87 00 00	FPU:			DB	87h,00h,00h
 1746: 1  06A4	00 00 10				DB	00h,00h,10h			;1e6
 1747: 1  06A7	84 00 00	FPM:			DB	84h,00h,00h
 1748: 1  06AA	00 00 10				DB	00h,00h,10h			;1e3
 1749:
 1750:		N      0800			ORG	0800h
 1751:
 1752:	  0800	75 81 90	START0:		MOV	SP,#MCUSTACK			;Init stack pointer.
 1753:	  0803	C2 94				CLR	P1.4				;L/C
 1754:	  0805	C2 95				CLR	P1.5				;CAL
 1755:	  0807	E4				CLR	A
 1756:	  0808	F5 A8				MOV	IE,A				;Disable all interrupts
 1757:	  080A	D2 A8				SETB	EX0				;Enable INT0
 1758:	  080C	D2 AF				SETB	EA				;Enable interrupts
 1759:	  080E	12 00 76			LCALL	FLOATING_INIT
 1760:	  0811	51 AA				ACALL	WAITASEC
 1761:	  0813	71 B8				ACALL	LCDINIT
 1762:	  0815	E4				CLR	A
 1763:	  0816	71 8F				ACALL	LCDSETADR

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 33



 Line  I  Addr  Code            Source

 1764:	  0818	71 9B				ACALL	LCDPRNTCSTR
 1765:	  081A	57 65 6C 63			DB	'Welcome Ketil',0
	  081E	6F 6D 65 20
	  0822	4B 65 74 69
	  0826	6C 00
 1766:	  0828	51 AA				ACALL	WAITASEC
 1767:	  082A	75 51 00			MOV	MODE,#00h
 1768:	  082D	71 D1		START:		ACALL	LCDCLEARLINE
 1769:	  082F	AF 51				MOV	R7,MODE
 1770:	  0831	DF 04				DJNZ	R7,START1
 1771:						;C Meter
 1772:	  0833	31 3E				ACALL	CMeter
 1773:	  0835	80 F6				SJMP	START
 1774:	  0837	DF 04		START1:		DJNZ	R7,START2
 1775:						;L Meter
 1776:	  0839	31 A8				ACALL	LMeter
 1777:	  083B	80 F0				SJMP	START
 1778:	  083D	DF 06		START2:		DJNZ	R7,START3
 1779:						;30MHz
 1780:	  083F	74 01				MOV	A,#01h				;CH1, 30MHz
 1781:	  0841	11 54				ACALL	FREQUENCY
 1782:	  0843	80 E8				SJMP	START
 1783:	  0845	DF 06		START3:		DJNZ	R7,START4
 1784:						;1GHz
 1785:	  0847	74 02				MOV	A,#02h				;CH2, 1GHz
 1786:	  0849	11 54				ACALL	FREQUENCY
 1787:	  084B	80 E0				SJMP	START
 1788:	  084D			START4:		;Calibrate
 1789:	  084D	11 B6				ACALL	LCMETERINIT
 1790:	  084F	75 51 03			MOV	MODE,#03h
 1791:	  0852	80 D9				SJMP	START
 1792:
 1793:	  0854	C2 94		FREQUENCY:	CLR	P1.4				;C
 1794:	  0856	C2 95				CLR	P1.5				;F1
 1795:	  0858	51 B7				ACALL	FRQCOUNT
 1796:	  085A	78 44				MOV	R0,#LCDLINE+4			;Decimal buffer
 1797:	  085C	51 2C				ACALL	BIN2DEC
 1798:	  085E	FF				MOV	R7,A				;Number of digits
 1799:	  085F	51 F4				ACALL	FRQFORMAT
 1800:	  0861	E4				CLR	A				;Output result
 1801:	  0862	71 8F				ACALL	LCDSETADR
 1802:	  0864	78 40				MOV	R0,#LCDLINE
 1803:	  0866	7F 10				MOV	R7,#10h
 1804:	  0868	71 94				ACALL	LCDPRINTSTR
 1805:	  086A	22				RET
 1806:
 1807:				;------------------------------------------------------------------
 1808:
 1809:				;Get LC meter frquency
 1810:				;IN:	R1 points to FP buffer
 1811:				;OUT:	Nothing
 1812:	  086B	C0 01		LCMETERGETFRQ:	PUSH	01h				;Save R1
 1813:	  086D	74 FA				MOV	A,#250
 1814:	  086F	51 25				ACALL	WAIT				;Wait 25ms for relay to kick in / out
 1815:	  0871	74 FA				MOV	A,#250
 1816:	  0873	51 25				ACALL	WAIT				;Wait 25ms for relay to kick in / out

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 34



 Line  I  Addr  Code            Source

 1817:	  0875	74 00				MOV	A,#00h				;CH0, LC Meter
 1818:	  0877	51 B7				ACALL	FRQCOUNT
 1819:	  0879	78 40				MOV	R0,#LCDLINE
 1820:	  087B	51 2C				ACALL	BIN2DEC
 1821:	  087D	78 40				MOV	R0,#LCDLINE
 1822:	  087F	79 27				MOV	R1,#CONVT
 1823:	  0881	7F 0A				MOV	R7,#0Ah
 1824:	  0883	E6		LCMETERGETFRQ1:	MOV	A,@R0
 1825:	  0884	F7				MOV	@R1,A
 1826:	  0885	08				INC	R0
 1827:	  0886	09				INC	R1
 1828:	  0887	DF FA				DJNZ	R7,LCMETERGETFRQ1
 1829:	  0889	74 0D				MOV	A,#0Dh
 1830:	  088B	F3				MOVX	@R1,A
 1831:	  088C	79 27				MOV	R1,#CONVT
 1832:	  088E	12 03 85			LCALL	FLOATING_POINT_INPUT
 1833:	  0891	D0 01				POP	01h				;Restore R1
 1834:	  0893	12 06 18			LCALL	POPAS				;POP ARGUMENT TO R1
 1835:	  0896	22				RET
 1836:
 1837:				;Calculate X=((Fa/Fb)^2)-1
 1838:				;IN:	Fa=R0, Fb=R1
 1839:				;OUT:	Nothing
 1840:	  0897	C0 01		LCCALC:		PUSH	01h
 1841:	  0899	12 06 1C			LCALL	PUSHAS				; PUSH R0 TO ARGUMENT
 1842:	  089C	D0 00				POP	00h
 1843:	  089E	12 06 1C			LCALL	PUSHAS				; PUSH R0 TO ARGUMENT
 1844:	  08A1	12 01 9C			LCALL	FLOATING_DIV
 1845:	  08A4	A8 24				MOV	R0,ARG_STACK
 1846:	  08A6	12 06 1C			LCALL	PUSHAS				; PUSH R0 TO ARGUMENT
 1847:	  08A9	12 01 67			LCALL	FLOATING_MUL
 1848:	  08AC	90 06 7D			MOV	DPTR,#FPONE
 1849:	  08AF	12 06 63			LCALL	PUSHC				; PUSH ARG IN DPTR TO STACK
 1850:	  08B2	12 00 7C			LCALL	FLOATING_SUB
 1851:	  08B5	22				RET
 1852:
 1853:				;Get LC meter frquency F1 and F2. Calculatr LCCA=((F1/F2)^2)-1 and LCCB=LCCA*((1/(2*Pi*F1))^2)*(1/Cc
				al)
 1854:				;IN:	Nothing
 1855:				;OUT:	Nothing
 1856:	  08B6	C2 94		LCMETERINIT:	CLR	P1.4				;C
 1857:	  08B8	C2 95				CLR	P1.5				;F1
 1858:	  08BA	71 84				ACALL	LCDCLEAR
 1859:	  08BC	71 9B				ACALL	LCDPRNTCSTR
 1860:	  08BE	43 61 6C 69			DB	'Calibrating',0
	  08C2	62 72 61 74
	  08C6	69 6E 67 00
 1861:	  08CA	7F 05				MOV	R7,#05h
 1862:	  08CC	C0 07		LCMETERINIT1:	PUSH	07h
 1863:	  08CE	51 AA				ACALL	WAITASEC
 1864:	  08D0	74 2E				MOV	A,#'.'
 1865:	  08D2	71 70				ACALL	LCDCHROUT
 1866:	  08D4	D0 07				POP	07h
 1867:	  08D6	DF F4				DJNZ	R7,LCMETERINIT1
 1868:	  08D8	C2 95				CLR	P1.5				;F1
 1869:	  08DA	79 60				MOV	R1,#LCF1

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 35



 Line  I  Addr  Code            Source

 1870:	  08DC	12 08 6B			LCALL	LCMETERGETFRQ			;Get F1
 1871:	  08DF	D2 95				SETB	P1.5				;F2
 1872:	  08E1	79 68				MOV	R1,#LCF2
 1873:	  08E3	11 6B				ACALL	LCMETERGETFRQ			;Get F2
 1874:	  08E5	C2 95				CLR	P1.5				;F1
 1875:						;Calculate LCCA=((F1/F2)^2)-1
 1876:	  08E7	78 60				MOV	R0,#LCF1
 1877:	  08E9	79 68				MOV	R1,#LCF2
 1878:	  08EB	11 97				ACALL	LCCALC
 1879:						;Save result to LCCA
 1880:	  08ED	79 78				MOV	R1,#LCCA
 1881:	  08EF	12 06 18			LCALL	POPAS				;POP ARGUMENT TO R1
 1882:						;Calculate A=(1/(2*Pi*F1))^2
 1883:	  08F2	90 06 83			MOV	DPTR,#FPTWO
 1884:	  08F5	12 06 63			LCALL	PUSHC				;PUSH ARG IN DPTR TO STACK
 1885:	  08F8	90 06 89			MOV	DPTR,#FPPI
 1886:	  08FB	12 06 63			LCALL	PUSHC				;PUSH ARG IN DPTR TO STACK
 1887:	  08FE	12 01 67			LCALL	FLOATING_MUL
 1888:	  0901	78 60				MOV	R0,#LCF1
 1889:	  0903	12 06 1C			LCALL	PUSHAS				;PUSH R0 TO ARGUMENT
 1890:	  0906	12 01 67			LCALL	FLOATING_MUL
 1891:	  0909	79 88				MOV	R1,#LCCT
 1892:	  090B	12 06 18			LCALL	POPAS				;POP ARGUMENT TO R1
 1893:	  090E	90 06 7D			MOV	DPTR,#FPONE
 1894:	  0911	12 06 63			LCALL	PUSHC				;PUSH ARG IN DPTR TO STACK
 1895:	  0914	78 88				MOV	R0,#LCCT
 1896:	  0916	12 06 1C			LCALL	PUSHAS				;PUSH R0 TO ARGUMENT
 1897:	  0919	12 01 9C			LCALL	FLOATING_DIV
 1898:	  091C	A8 24				MOV	R0,ARG_STACK
 1899:	  091E	12 06 1C			LCALL	PUSHAS				;PUSH R0 TO ARGUMENT
 1900:	  0921	12 01 67			LCALL	FLOATING_MUL
 1901:						;Calculate LCCB=A*LCCA*(1/Ccal)
 1902:	  0924	78 78				MOV	R0,#LCCA
 1903:	  0926	12 06 1C			LCALL	PUSHAS				;PUSH R0 TO ARGUMENT
 1904:	  0929	12 01 67			LCALL	FLOATING_MUL
 1905:	  092C	90 06 8F			MOV	DPTR,#FPCCAL
 1906:	  092F	12 06 63			LCALL	PUSHC				;PUSH ARG IN DPTR TO STACK
 1907:	  0932	12 01 9C			LCALL	FLOATING_DIV
 1908:						;Save result to LCCB
 1909:	  0935	79 80				MOV	R1,#LCCB
 1910:	  0937	12 06 18			LCALL	POPAS				;POP ARGUMENT TO R1
 1911:	  093A	12 0B 84			LCALL	LCDCLEAR
 1912:	  093D	22				RET
 1913:
 1914:				;Capacitance meter: Cx=((F1/F3)^2)-1)/((F1/F2)^2)-1)*Ccal
 1915:				;IN:	Nothing
 1916:				;OUT:	Nothing
 1917:	  093E	C2 94		CMETER:		CLR	P1.4				;C
 1918:	  0940	C2 95				CLR	P1.5				;F1
 1919:	  0942	79 70				MOV	R1,#LCF3
 1920:	  0944	11 6B				ACALL	LCMETERGETFRQ			;Get F3
 1921:						;Calculate A=((F1/F3)^2)-1
 1922:	  0946	78 60				MOV	R0,#LCF1
 1923:	  0948	79 70				MOV	R1,#LCF3
 1924:	  094A	11 97				ACALL	LCCALC
 1925:						;Calculate B=A/LCCA

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 36



 Line  I  Addr  Code            Source

 1926:	  094C	78 78				MOV	R0,#LCCA
 1927:	  094E	12 06 1C			LCALL	PUSHAS				;PUSH R0 TO ARGUMENT
 1928:	  0951	12 01 9C			LCALL	FLOATING_DIV
 1929:						;Calculate Cx=A/B*Ccal
 1930:	  0954	90 06 8F			MOV	DPTR,#FPCCAL
 1931:	  0957	12 06 63			LCALL	PUSHC				;PUSH ARG IN DPTR TO STACK
 1932:	  095A	12 01 67			LCALL	FLOATING_MUL
 1933:	  095D	A8 24				MOV	R0,ARG_STACK
 1934:	  095F	18				DEC	R0
 1935:	  0960	E6				MOV	A,@R0
 1936:	  0961	08				INC	R0
 1937:	  0962	60 02				JZ	CMETER1
 1938:	  0964	E4				CLR	A
 1939:	  0965	F6				MOV	@R0,A
 1940:	  0966	E6		CMETER1:	MOV	A,@R0
 1941:	  0967	75 4E 70			MOV	LCDLINE+14,#'p'
 1942:	  096A	90 06 95			MOV	DPTR,#FPP
 1943:	  096D	60 0B				JZ	CMETER2
 1944:	  096F	B4 78 00			CJNE	A,#78h,$+3
 1945:	  0972	40 06				JC	CMETER2
 1946:	  0974	75 4E 6E			MOV	LCDLINE+14,#'n'
 1947:	  0977	90 06 9B			MOV	DPTR,#FPN
 1948:	  097A	12 06 63	CMETER2:	LCALL	PUSHC				;PUSH ARG IN DPTR TO STACK
 1949:	  097D	12 01 67			LCALL	FLOATING_MUL
 1950:	  0980	75 40 43			MOV	LCDLINE,#'C'
 1951:	  0983	75 41 20			MOV	LCDLINE+1,#' '
 1952:	  0986	75 42 3D			MOV	LCDLINE+2,#'='
 1953:	  0989	75 43 20			MOV	LCDLINE+3,#' '
 1954:	  098C	75 4F 46			MOV	LCDLINE+15,#'F'
 1955:	  098F	75 50 44			MOV	FPCHR_OUT,#LCDLINE+4
 1956:	  0992	75 25 53			MOV	FORMAT,#53h
 1957:	  0995	E5 24				MOV	A,ARG_STACK
 1958:	  0997	C3				CLR	C
 1959:	  0998	94 05				SUBB	A,#05h
 1960:	  099A	F8				MOV	R0,A
 1961:	  099B	12 04 33			LCALL	FLOATING_POINT_OUTPUT
 1962:	  099E	E4				CLR	A				;Output result
 1963:	  099F	71 8F				ACALL	LCDSETADR
 1964:	  09A1	78 40				MOV	R0,#LCDLINE
 1965:	  09A3	7F 10				MOV	R7,#10h
 1966:	  09A5	71 94				ACALL	LCDPRINTSTR
 1967:	  09A7	22				RET
 1968:
 1969:				;Inductance meter Lx=((F1/F3)^2)-1)*((F1/F2)^2)-1)*((1/(2*Pi*F1))^2)*(1/Ccal)
 1970:				;IN:	Nothing
 1971:				;OUT:	Nothing
 1972:	  09A8	D2 94		LMETER:		SETB	P1.4				;L
 1973:	  09AA	C2 95				CLR	P1.5				;F1
 1974:	  09AC	79 70				MOV	R1,#LCF3
 1975:	  09AE	11 6B				ACALL	LCMETERGETFRQ			;Get F3
 1976:						;Calculate A=((F1/F3)^2)-1
 1977:	  09B0	78 60				MOV	R0,#LCF1
 1978:	  09B2	79 70				MOV	R1,#LCF3
 1979:	  09B4	11 97				ACALL	LCCALC
 1980:						;Calculate B=A*LCCB
 1981:	  09B6	78 80				MOV	R0,#LCCB

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 37



 Line  I  Addr  Code            Source

 1982:	  09B8	12 06 1C			LCALL	PUSHAS				;PUSH R2:R0 TO ARGUMENT
 1983:	  09BB	12 01 67			LCALL	FLOATING_MUL
 1984:	  09BE	A8 24				MOV	R0,ARG_STACK
 1985:	  09C0	18				DEC	R0
 1986:	  09C1	E6				MOV	A,@R0
 1987:	  09C2	08				INC	R0
 1988:	  09C3	60 02				JZ	LMETER1
 1989:	  09C5	E4				CLR	A
 1990:	  09C6	F6				MOV	@R0,A
 1991:	  09C7	E6		LMETER1:	MOV	A,@R0
 1992:	  09C8	B4 80 00			CJNE	A,#80h,$+3
 1993:	  09CB	40 02				JC	LMETER2
 1994:	  09CD	E4				CLR	A
 1995:	  09CE	F6				MOV	@R0,A
 1996:	  09CF	75 4E 6E	LMETER2:	MOV	LCDLINE+14,#'n'
 1997:	  09D2	90 06 9B			MOV	DPTR,#FPN
 1998:	  09D5	60 16				JZ	LMETER3
 1999:	  09D7	B4 7B 00			CJNE	A,#7Bh,$+3
 2000:	  09DA	40 11				JC	LMETER3
 2001:	  09DC	75 4E 75			MOV	LCDLINE+14,#'u'
 2002:	  09DF	90 06 A1			MOV	DPTR,#FPU
 2003:	  09E2	B4 7E 00			CJNE	A,#7Eh,$+3
 2004:	  09E5	40 06				JC	LMETER3
 2005:	  09E7	75 4E 6D			MOV	LCDLINE+14,#'m'
 2006:	  09EA	90 06 A7			MOV	DPTR,#FPM
 2007:	  09ED	12 06 63	LMETER3:	LCALL	PUSHC				;PUSH ARG IN DPTR TO STACK
 2008:	  09F0	12 01 67			LCALL	FLOATING_MUL
 2009:	  09F3	75 40 4C			MOV	LCDLINE,#'L'
 2010:	  09F6	75 41 20			MOV	LCDLINE+1,#' '
 2011:	  09F9	75 42 3D			MOV	LCDLINE+2,#'='
 2012:	  09FC	75 43 20			MOV	LCDLINE+3,#' '
 2013:	  09FF	75 4F 48			MOV	LCDLINE+15,#'H'
 2014:	  0A02	75 50 44			MOV	FPCHR_OUT,#LCDLINE+4
 2015:	  0A05	75 25 53			MOV	FORMAT,#53h
 2016:	  0A08	E5 24				MOV	A,ARG_STACK
 2017:	  0A0A	C3				CLR	C
 2018:	  0A0B	94 05				SUBB	A,#05h
 2019:	  0A0D	F8				MOV	R0,A
 2020:	  0A0E	12 04 33			LCALL	FLOATING_POINT_OUTPUT
 2021:	  0A11	74 00				MOV	A,#00h
 2022:	  0A13	71 8F				ACALL	LCDSETADR
 2023:	  0A15	78 40				MOV	R0,#LCDLINE
 2024:	  0A17	7F 10				MOV	R7,#10h
 2025:	  0A19	71 94				ACALL	LCDPRINTSTR
 2026:	  0A1B	22				RET
 2027:
 2028:				;Wait functions
 2029:				;------------------------------------------------------------------
 2030:
 2031:	  0A1C	C0 07		WAIT100:	PUSH	07h				;Save R7
 2032:	  0A1E	7F 64				MOV	R7,#64h
 2033:	  0A20	DF FE		WAIT1001:	DJNZ	R7,WAIT1001			;Wait loop, 100uS
 2034:	  0A22	D0 07				POP	07h				;Restore R7
 2035:	  0A24	22				RET
 2036:
 2037:	  0A25	CF		WAIT:		XCH	A,R7

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 38



 Line  I  Addr  Code            Source

 2038:	  0A26	51 1C		WAIT1:		ACALL	WAIT100
 2039:	  0A28	DF FC				DJNZ	R7,WAIT1
 2040:	  0A2A	CF				XCH	A,R7
 2041:	  0A2B	22				RET
 2042:
 2043:				;Binary to decimal converter
 2044:				;Converts R7:R6:R5:R4 to decimal pointed to by R0
 2045:				;Returns with number of digits in A
 2046:				;------------------------------------------------------------------
 2047:	  0A2C	C0 00		BIN2DEC:	PUSH	00h
 2048:	  0A2E	90 0A 82			MOV	DPTR,#BINDEC
 2049:	  0A31	7A 0A				MOV	R2,#0Ah
 2050:	  0A33	7B 2F		BIN2DEC1:	MOV	R3,#2Fh
 2051:	  0A35	0B		BIN2DEC2:	INC	R3
 2052:	  0A36	51 55				ACALL	SUBIT
 2053:	  0A38	50 FB				JNC	BIN2DEC2
 2054:	  0A3A	51 6E				ACALL	ADDIT
 2055:	  0A3C	EB				MOV	A,R3
 2056:	  0A3D	F6				MOV	@R0,A
 2057:	  0A3E	08				INC	R0
 2058:	  0A3F	A3				INC	DPTR
 2059:	  0A40	A3				INC	DPTR
 2060:	  0A41	A3				INC	DPTR
 2061:	  0A42	A3				INC	DPTR
 2062:	  0A43	DA EE				DJNZ	R2,BIN2DEC1
 2063:	  0A45	D0 00				POP	00h
 2064:						;Remove leading zeroes
 2065:	  0A47	7A 09				MOV	R2,#09h
 2066:	  0A49	E6		BIN2DEC3:	MOV	A,@R0
 2067:	  0A4A	B4 30 05			CJNE	A,#30h,BIN2DEC4
 2068:	  0A4D	76 20				MOV	@R0,#20h
 2069:	  0A4F	08				INC	R0
 2070:	  0A50	DA F7				DJNZ	R2,BIN2DEC3
 2071:	  0A52	0A		BIN2DEC4:	INC	R2
 2072:	  0A53	EA				MOV	A,R2
 2073:	  0A54	22				RET
 2074:
 2075:	  0A55	E4		SUBIT:		CLR	A
 2076:	  0A56	93				MOVC	A,@A+DPTR
 2077:	  0A57	CC				XCH	A,R4
 2078:	  0A58	C3				CLR	C
 2079:	  0A59	9C				SUBB	A,R4
 2080:	  0A5A	FC				MOV	R4,A
 2081:	  0A5B	74 01				MOV	A,#01h
 2082:	  0A5D	93				MOVC	A,@A+DPTR
 2083:	  0A5E	CD				XCH	A,R5
 2084:	  0A5F	9D				SUBB	A,R5
 2085:	  0A60	FD				MOV	R5,A
 2086:	  0A61	74 02				MOV	A,#02h
 2087:	  0A63	93				MOVC	A,@A+DPTR
 2088:	  0A64	CE				XCH	A,R6
 2089:	  0A65	9E				SUBB	A,R6
 2090:	  0A66	FE				MOV	R6,A
 2091:	  0A67	74 03				MOV	A,#03h
 2092:	  0A69	93				MOVC	A,@A+DPTR
 2093:	  0A6A	CF				XCH	A,R7

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 39



 Line  I  Addr  Code            Source

 2094:	  0A6B	9F				SUBB	A,R7
 2095:	  0A6C	FF				MOV	R7,A
 2096:	  0A6D	22				RET
 2097:
 2098:	  0A6E	E4		ADDIT:		CLR	A
 2099:	  0A6F	93				MOVC	A,@A+DPTR
 2100:	  0A70	2C				ADD	A,R4
 2101:	  0A71	FC				MOV	R4,A
 2102:	  0A72	74 01				MOV	A,#01h
 2103:	  0A74	93				MOVC	A,@A+DPTR
 2104:	  0A75	3D				ADDC	A,R5
 2105:	  0A76	FD				MOV	R5,A
 2106:	  0A77	74 02				MOV	A,#02h
 2107:	  0A79	93				MOVC	A,@A+DPTR
 2108:	  0A7A	3E				ADDC	A,R6
 2109:	  0A7B	FE				MOV	R6,A
 2110:	  0A7C	74 03				MOV	A,#03h
 2111:	  0A7E	93				MOVC	A,@A+DPTR
 2112:	  0A7F	3F				ADDC	A,R7
 2113:	  0A80	FF				MOV	R7,A
 2114:	  0A81	22				RET
 2115:
 2116:	  0A82	00 CA 9A 3B	BINDEC:		DB 000h,0CAh,09Ah,03Bh			;1000000000
 2117:	  0A86	00 E1 F5 05			DB 000h,0E1h,0F5h,005h			; 100000000
 2118:	  0A8A	80 96 98 00			DB 080h,096h,098h,000h			;  10000000
 2119:	  0A8E	40 42 0F 00			DB 040h,042h,0Fh,0000h			;   1000000
 2120:	  0A92	A0 86 01 00			DB 0A0h,086h,001h,000h			;    100000
 2121:	  0A96	10 27 00 00			DB 010h,027h,000h,000h			;     10000
 2122:	  0A9A	E8 03 00 00			DB 0E8h,003h,000h,000h			;      1000
 2123:	  0A9E	64 00 00 00			DB 064h,000h,000h,000h			;       100
 2124:	  0AA2	0A 00 00 00			DB 00Ah,000h,000h,000h			;        10
 2125:	  0AA6	01 00 00 00			DB 001h,000h,000h,000h			;         1
 2126:
 2127:				;------------------------------------------------------------------
 2128:
 2129:				;Wait loop. Waits 1 second
 2130:				;------------------------------------------------------------------
 2131:	  0AAA	7F F9		WAITASEC:	MOV	R7,#0F9h
 2132:	  0AAC	7E 33				MOV	R6,#51
 2133:	  0AAE	7D 10				MOV	R5,#16
 2134:	  0AB0	DF FE		WAITASEC1:	DJNZ	R7,WAITASEC1
 2135:	  0AB2	DE FC				DJNZ	R6,WAITASEC1
 2136:	  0AB4	DD FA				DJNZ	R5,WAITASEC1
 2137:	  0AB6	22				RET
 2138:
 2139:				;Frequency counter. LSB from 74HC590 read at P0, TL0, TH0,
 2140:				;TF0 bit. 25 bits, max 33554431 Hz
 2141:				;IN:	A Channel (0-3)
 2142:				;OUT:	32 Bit result in R7:R6:R5:R4
 2143:				;------------------------------------------------------------------
 2144:	  0AB7	D2 93		FRQCOUNT:	SETB	P1.3				;DISABLE COUNT
 2145:	  0AB9	C2 92				CLR	P1.2				;RESET 74HC590
 2146:	  0ABB	D2 92				SETB	P1.2
 2147:						;Select channel
 2148:	  0ABD	A2 E0				MOV	C,ACC.0
 2149:	  0ABF	92 90				MOV	P1.0,C

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 40



 Line  I  Addr  Code            Source

 2150:	  0AC1	A2 E1				MOV	C,ACC.1
 2151:	  0AC3	92 91				MOV	P1.1,C
 2152:	  0AC5	75 8A 00			MOV	TL0,#00h
 2153:	  0AC8	75 8C 00			MOV	TH0,#00h
 2154:	  0ACB	E5 89				MOV	A,TMOD
 2155:	  0ACD	D2 E0				SETB	ACC.0				;M00
 2156:	  0ACF	C2 E1				CLR	ACC.1				;M01
 2157:	  0AD1	D2 E2				SETB	ACC.2				;C/T0#
 2158:	  0AD3	C2 E3				CLR	ACC.3				;GATE0
 2159:	  0AD5	F5 89				MOV	TMOD,A
 2160:	  0AD7	E5 88				MOV	A,TCON
 2161:	  0AD9	D2 E4				SETB	ACC.4				;TR0
 2162:	  0ADB	C2 E5				CLR	ACC.5				;TF0
 2163:	  0ADD	F5 88				MOV	TCON,A
 2164:	  0ADF	C2 93				CLR	P1.3				;ENABLR COUNT
 2165:	  0AE1	51 AA				ACALL	WAITASEC
 2166:	  0AE3	D2 93				SETB	P1.3				;DISABLE COUNT
 2167:	  0AE5	E5 80				MOV	A,P0				;8 BITS FROM 74HC590
 2168:	  0AE7	FC				MOV	R4,A
 2169:	  0AE8	E5 8A				MOV	A,TL0				;8 BITS FROM
 2170:	  0AEA	FD				MOV	R5,A
 2171:	  0AEB	E5 8C				MOV	A,TH0				;8 BITS FROM
 2172:	  0AED	FE				MOV	R6,A
 2173:	  0AEE	E4				CLR	A				;TF0 Is the 25th bit
 2174:	  0AEF	A2 8D				MOV	C,TF0
 2175:	  0AF1	33				RLC	A
 2176:	  0AF2	FF				MOV	R7,A
 2177:	  0AF3	22				RET
 2178:
 2179:				;Format frequency conter text line
 2180:				;	LCDLINE+4 Decimal result
 2181:				;	R7 Number of digits
 2182:				;OUT:	Formatted LCDLINE
 2183:	  0AF4	75 40 46	FRQFORMAT:	MOV	LCDLINE+0,#'F'
 2184:	  0AF7	75 41 3D			MOV	LCDLINE+1,#'='
 2185:	  0AFA	75 42 20			MOV	LCDLINE+2,#' '
 2186:	  0AFD	78 43				MOV	R0,#LCDLINE+3
 2187:	  0AFF	79 45				MOV	R1,#LCDLINE+5
 2188:	  0B01	BF 07 00			CJNE	R7,#07h,$+3
 2189:	  0B04	40 19				JC	FRQFORMATKHZ
 2190:						;MHz
 2191:	  0B06	7F 09				MOV	R7,#09h
 2192:	  0B08	E7		FRQFORMATMHZ1:	MOV	A,@R1
 2193:	  0B09	BF 06 03			CJNE	R7,#06h,FRQFORMATMHZ2
 2194:	  0B0C	76 2E				MOV	@R0,#'.'
 2195:	  0B0E	08				INC	R0
 2196:	  0B0F	F6		FRQFORMATMHZ2:	MOV	@R0,A
 2197:	  0B10	08				INC	R0
 2198:	  0B11	09				INC	R1
 2199:	  0B12	DF F4				DJNZ	R7,FRQFORMATMHZ1
 2200:	  0B14	75 4D 4D			MOV	LCDLINE+13,#'M'
 2201:	  0B17	75 4E 48			MOV	LCDLINE+14,#'H'
 2202:	  0B1A	75 4F 7A			MOV	LCDLINE+15,#'z'
 2203:	  0B1D	80 30				SJMP	FRQFORMATDONE
 2204:	  0B1F	BF 04 00	FRQFORMATKHZ:	CJNE	R7,#04h,$+3
 2205:	  0B22	40 19				JC	FRQFORMATHZ

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 41



 Line  I  Addr  Code            Source

 2206:						;KHz
 2207:	  0B24	7F 09				MOV	R7,#09h
 2208:	  0B26	E7		FRQFORMATKHZ1:	MOV	A,@R1
 2209:	  0B27	BF 03 03			CJNE	R7,#03h,FRQFORMATKHZ2
 2210:	  0B2A	76 2E				MOV	@R0,#'.'
 2211:	  0B2C	08				INC	R0
 2212:	  0B2D	F6		FRQFORMATKHZ2:	MOV	@R0,A
 2213:	  0B2E	08				INC	R0
 2214:	  0B2F	09				INC	R1
 2215:	  0B30	DF F4				DJNZ	R7,FRQFORMATKHZ1
 2216:	  0B32	75 4D 4B			MOV	LCDLINE+13,#'K'
 2217:	  0B35	75 4E 48			MOV	LCDLINE+14,#'H'
 2218:	  0B38	75 4F 7A			MOV	LCDLINE+15,#'z'
 2219:	  0B3B	80 12				SJMP	FRQFORMATDONE
 2220:	  0B3D			FRQFORMATHZ:	;Hz
 2221:	  0B3D	08				INC	R0
 2222:	  0B3E	7F 09				MOV	R7,#09h
 2223:	  0B40	E7		FRQFORMATHZ1:	MOV	A,@R1
 2224:	  0B41	F6				MOV	@R0,A
 2225:	  0B42	08				INC	R0
 2226:	  0B43	09				INC	R1
 2227:	  0B44	DF FA				DJNZ	R7,FRQFORMATHZ1
 2228:	  0B46	75 4D 48			MOV	LCDLINE+13,#'H'
 2229:	  0B49	75 4E 7A			MOV	LCDLINE+14,#'z'
 2230:	  0B4C	75 4F 20			MOV	LCDLINE+15,#' '
 2231:	  0B4F	22		FRQFORMATDONE:	RET
 2232:
 2233:				;LCD Output.
 2234:				;------------------------------------------------------------------
 2235:				;TXBYTE:		MOV	SBUF,A
 2236:				;		JNB	TI,$
 2237:				;		CLR	TI
 2238:				;		RET
 2239:
 2240:	  0B50	C0 07		LCDDELAY:	PUSH	07h
 2241:	  0B52	7F 00				MOV	R7,#00h
 2242:	  0B54	DF FE				DJNZ	R7,$
 2243:	  0B56	D0 07				POP	07h
 2244:	  0B58	22				RET
 2245:
 2246:				;A contains nibble, ACC.4 contains RS
 2247:	  0B59	D2 E5		LCDNIBOUT:	SETB	ACC.5				;E
 2248:	  0B5B	F5 A0				MOV	P2,A
 2249:	  0B5D	C2 A5				CLR	P2.5				;Negative edge on E
 2250:	  0B5F	22				RET
 2251:
 2252:				;A contains byte
 2253:	  0B60	C0 E0		LCDCMDOUT:	PUSH	ACC
 2254:	  0B62	C4				SWAP	A				;High nibble first
 2255:	  0B63	54 0F				ANL	A,#0Fh
 2256:	  0B65	71 59				ACALL	LCDNIBOUT
 2257:	  0B67	D0 E0				POP	ACC
 2258:	  0B69	54 0F				ANL	A,#0Fh
 2259:	  0B6B	71 59				ACALL	LCDNIBOUT
 2260:	  0B6D	71 50				ACALL	LCDDELAY			;Wait for BF to clear
 2261:	  0B6F	22				RET

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 42



 Line  I  Addr  Code            Source

 2262:
 2263:				;A contains byte
 2264:	  0B70			LCDCHROUT:
 2265:				;		AJMP	TXBYTE
 2266:	  0B70	C0 E0				PUSH	ACC
 2267:	  0B72	C4				SWAP	A				;High nibble first
 2268:	  0B73	54 0F				ANL	A,#0Fh
 2269:	  0B75	D2 E4				SETB	ACC.4				;RS
 2270:	  0B77	71 59				ACALL	LCDNIBOUT
 2271:	  0B79	D0 E0				POP	ACC
 2272:	  0B7B	54 0F				ANL	A,#0Fh
 2273:	  0B7D	D2 E4				SETB	ACC.4				;RS
 2274:	  0B7F	71 59				ACALL	LCDNIBOUT
 2275:	  0B81	71 50				ACALL	LCDDELAY			;Wait for BF to clear
 2276:	  0B83	22				RET
 2277:
 2278:	  0B84	74 01		LCDCLEAR:	MOV	A,#00000001b
 2279:	  0B86	71 60				ACALL	LCDCMDOUT
 2280:	  0B88	7F 00				MOV	R7,#00h
 2281:	  0B8A	71 50		LCDCLEAR1:	ACALL	LCDDELAY
 2282:	  0B8C	DF FC				DJNZ	R7,LCDCLEAR1
 2283:	  0B8E	22				RET
 2284:
 2285:				;A contais address
 2286:	  0B8F	44 80		LCDSETADR:	ORL	A,#10000000b
 2287:	  0B91	71 60				ACALL	LCDCMDOUT
 2288:	  0B93	22				RET
 2289:
 2290:	  0B94	E6		LCDPRINTSTR:	MOV	A,@R0
 2291:	  0B95	71 70				ACALL	LCDCHROUT
 2292:	  0B97	08				INC	R0
 2293:	  0B98	DF FA				DJNZ	R7,LCDPRINTSTR
 2294:	  0B9A	22				RET
 2295:
 2296:	  0B9B	D0 83		LCDPRNTCSTR:	POP	DPH
 2297:	  0B9D	D0 82				POP	DPL
 2298:	  0B9F	E4		LCDPRNTCSTR1:	CLR	A
 2299:	  0BA0	93				MOVC	A,@A+DPTR
 2300:	  0BA1	A3				INC	DPTR
 2301:	  0BA2	60 04				JZ	LCDPRNTCSTR2
 2302:	  0BA4	71 70				ACALL	LCDCHROUT
 2303:	  0BA6	80 F7				SJMP	LCDPRNTCSTR1
 2304:	  0BA8	C0 82		LCDPRNTCSTR2:	PUSH	DPL
 2305:	  0BAA	C0 83				PUSH	DPH
 2306:	  0BAC	22				RET
 2307:
 2308:	  0BAD	E4		PRNTCDPTRLCD:	CLR	A
 2309:	  0BAE	93				MOVC	A,@A+DPTR
 2310:	  0BAF	60 06				JZ	PRNTCDPTRLCD1
 2311:	  0BB1	12 0B 70			LCALL	LCDCHROUT
 2312:	  0BB4	A3				INC	DPTR
 2313:	  0BB5	80 F6				SJMP	PRNTCDPTRLCD
 2314:	  0BB7	22		PRNTCDPTRLCD1:	RET
 2315:
 2316:	  0BB8	74 03		LCDINIT:	MOV	A,#00000011b			;Function set
 2317:	  0BBA	71 59				ACALL	LCDNIBOUT

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 43



 Line  I  Addr  Code            Source

 2318:	  0BBC	71 50				ACALL	LCDDELAY			;Wait for BF to clear
 2319:	  0BBE	74 28				MOV	A,#00101000b
 2320:	  0BC0	71 60				ACALL	LCDCMDOUT
 2321:	  0BC2	74 28				MOV	A,#00101000b
 2322:	  0BC4	71 60				ACALL	LCDCMDOUT
 2323:	  0BC6	74 0C				MOV	A,#00001100b			;Display ON/OFF
 2324:	  0BC8	71 60				ACALL	LCDCMDOUT
 2325:	  0BCA	71 84				ACALL	LCDCLEAR			;Clear
 2326:	  0BCC	74 06				MOV	A,#00000110b			;Cursor direction
 2327:	  0BCE	71 60				ACALL	LCDCMDOUT
 2328:	  0BD0	22				RET
 2329:
 2330:	  0BD1	78 40		LCDCLEARLINE:	MOV	R0,#LCDLINE			;Get logic levels
 2331:	  0BD3	7F 10				MOV	R7,#10h
 2332:	  0BD5	74 20				MOV	A,#20H
 2333:	  0BD7	F6		LCDCLEARLINE1:	MOV	@R0,A
 2334:	  0BD8	08				INC	R0
 2335:	  0BD9	DF FC				DJNZ	R7,LCDCLEARLINE1
 2336:	  0BDB	22				RET
 2337:
 2338:						END
 2339:





                     register banks used:  ---

                     no errors




ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 44





	       L I S T   O F   S Y M B O L S
	       =============================


SYMBOL				  TYPE     VALUE	LINE
------------------------------------------------------------
??ASEM_51			  NUMBER    8051
??VERSION			  NUMBER    0130
AC				  BIT	      D6
ACC				  DATA	      E0
ADDIT				  CODE	    0A6E	2098
ADDLP				  CODE	    00E5	 378
ADD_IN				  BIT	      33	 153
ADD_R				  CODE	    00E3	 376
AI1				  CODE	    064E	1700
AI2				  CODE	    0656	1707
AI21				  CODE	    065E	1713
AI3				  CODE	    0662	1716
AINT				  CODE	    0641	1689
ARG1_EXP_IS_LARGER		  CODE	    014A	 481
ARG1_EXP_IS_LARGER1		  CODE	    014B	 484
ARG1_EXP_IS_LARGER2		  CODE	    014E	 486
ARG_STACK			  NUMBER    0024	 150
A_D				  CODE	    0629	1664
B				  DATA	      F0
BADPRM				  CODE	    007B	 271
BIN2DEC				  CODE	    0A2C	2047
BIN2DEC1			  CODE	    0A33	2050
BIN2DEC2			  CODE	    0A35	2051
BIN2DEC3			  CODE	    0A49	2066
BIN2DEC4			  CODE	    0A52	2071
BINDEC				  CODE	    0A82	2116
BOTH_PLUS			  CODE	    0152	 494
CLOOP				  CODE	    015A	 506
CMETER				  CODE	    093E	1917
CMETER1				  CODE	    0966	1940
CMETER2				  CODE	    097A	1948
CMP				  MACRO	        	 141
CONVERT_BINARY_TO_ASCII_STRING	  CODE	    057B	1509
CONVT				  NUMBER    0027	 155
CY				  BIT	      D7
DC1				  CODE	    05F1	1618
DEBOUNCEINT0			  CODE	    000E	  31
DEBOUNCEINT01			  CODE	    0012	  33
DECX				  CODE	    0405	1183
DEC_ASTKA			  CODE	    060B	1642
DIGIT				  NUMBER    0004	 164
DIGIT_CHECK			  CODE	    05EB	1611
DIV0				  CODE	    01A9	 600
DIV3				  CODE	    01B6	 609
DIV4				  CODE	    01C3	 617
DIV5				  CODE	    01C6	 620
DIV6				  CODE	    01CE	 625
DIV7				  CODE	    01E5	 647
DIV8				  CODE	    01FA	 660
DONE_LOAD			  BIT	      53	 194

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 45



SYMBOL				  TYPE     VALUE	LINE
------------------------------------------------------------
DPH				  DATA	      83
DPL				  DATA	      82
D_UNDER				  CODE	    01B4	 607
E4YY				  CODE	    063C	1685
EA				  BIT	      AF
ES				  BIT	      AC
ET0				  BIT	      A9
ET1				  BIT	      AB
EX0				  BIT	      A8
EX1				  BIT	      AA
EXA				  CODE	    066F	1730
EXPONENTS_EQUAL			  CODE	    014F	 488
EXPOT4				  CODE	    04CF	1359
EXPOT5				  CODE	    04FA	1388
EXPOTX				  CODE	    04CD	1357
EXPOUT				  CODE	    04BA	1344
EXTI0				  CODE	    0003
EXTI1				  CODE	    0013
F0				  BIT	      D5
FAST_DONE			  CODE	    05B4	1555
FDT1				  CODE	    0416	1197
FDT2				  CODE	    041E	1201
FDTEST				  CODE	    0412	1194
FINISH1				  CODE	    03D7	1149
FINISH2				  CODE	    03EA	1165
FINISH_UP			  CODE	    03EB	1167
FINISH_UP1			  CODE	    03F2	1172
FIRST_RADIX			  BIT	      52	 193
FLOATING_ADD			  CODE	    0083	 285
FLOATING_COMP			  CODE	    0136	 455
FLOATING_DIV			  CODE	    019C	 585
FLOATING_INIT			  CODE	    0076	 263
FLOATING_MUL			  CODE	    0167	 522
FLOATING_POINT_INPUT		  CODE	    0385	1094
FLOATING_POINT_OUTPUT		  CODE	    0433	1238
FLOATING_SUB			  CODE	    007C	 275
FMUL0				  CODE	    016C	 531
FMUL1				  CODE	    016E	 535
FMUL2				  CODE	    0180	 551
FMUL3				  CODE	    0189	 566
FMUL_OVER			  CODE	    017C	 545
FORMAT				  NUMBER    0025	 151
FOUND_RADIX			  BIT	      51	 192
FOV				  CODE	    017E	 549
FPC1				  CODE	    028F	 833
FPCCAL				  CODE	    068F	1739
FPCHR_OUT			  NUMBER    0050	   3
FPM				  CODE	    06A7	1747
FPN				  CODE	    069B	1743
FPO1				  CODE	    044C	1265
FPO2				  CODE	    045F	1278
FPONE				  CODE	    067D	1733
FPP				  CODE	    0695	1741
FPPI				  CODE	    0689	1737
FPSTACK				  NUMBER    00FF	  12
FPTWO				  CODE	    0683	1735

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 46



SYMBOL				  TYPE     VALUE	LINE
------------------------------------------------------------
FPU				  CODE	    06A1	1745
FP_ACC1				  NUMBER    0035	 205
FP_ACC2				  NUMBER    0036	 206
FP_ACC3				  NUMBER    0037	 207
FP_ACC4				  NUMBER    0038	 208
FP_ACC5				  NUMBER    0039	 209
FP_ACC6				  NUMBER    003A	 210
FP_ACC7				  NUMBER    003B	 211
FP_ACC8				  NUMBER    003C	 212
FP_ACCC				  NUMBER    0034	 204
FP_ACCS				  NUMBER    003D	 213
FP_ACCX				  NUMBER    0033	 203
FP_CARRY			  NUMBER    002A	 183
FP_CLEAR			  CODE	    028C	 824
FP_DIG12			  NUMBER    002B	 184
FP_DIG34			  NUMBER    002C	 185
FP_DIG56			  NUMBER    002D	 186
FP_DIG78			  NUMBER    002E	 187
FP_EXP				  NUMBER    0030	 189
FP_NIB1				  NUMBER    002B	 195
FP_NIB2				  NUMBER    002C	 196
FP_NIB3				  NUMBER    002D	 197
FP_NIB4				  NUMBER    002E	 198
FP_NIB5				  NUMBER    002F	 199
FP_NIB6				  NUMBER    0030	 200
FP_NIB7				  NUMBER    0031	 201
FP_NIB8				  NUMBER    0032	 202
FP_NUMBER_SIZE			  NUMBER    0006	 163
FP_SIGN				  NUMBER    002F	 188
FP_STATUS			  NUMBER    0028	 181
FP_TEMP				  NUMBER    0029	 182
FREE				  CODE	    048B	1313
FREE1				  CODE	    0492	1318
FREE2				  CODE	    04AE	1337
FREE4				  CODE	    04A6	1332
FREQUENCY			  CODE	    0854	1793
FRQCOUNT			  CODE	    0AB7	2144
FRQFORMAT			  CODE	    0AF4	2183
FRQFORMATDONE			  CODE	    0B4F	2231
FRQFORMATHZ			  CODE	    0B3D	2220
FRQFORMATHZ1			  CODE	    0B40	2223
FRQFORMATKHZ			  CODE	    0B1F	2204
FRQFORMATKHZ1			  CODE	    0B26	2208
FRQFORMATKHZ2			  CODE	    0B2D	2212
FRQFORMATMHZ1			  CODE	    0B08	2192
FRQFORMATMHZ2			  CODE	    0B0F	2196
FRTEST				  CODE	    040F	1192
FSUB10				  CODE	    0134	 451
FSUB5				  CODE	    0103	 410
FSUB6				  CODE	    010E	 421
FSUB7				  CODE	    0112	 424
FSUB8				  CODE	    011D	 432
FSUB9				  CODE	    0123	 439
GET_DIGIT_CHECK			  CODE	    05E9	1607
GET_R1_CHARACTER		  CODE	    0422	1215
GT1				  CODE	    03AD	1124

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 47



SYMBOL				  TYPE     VALUE	LINE
------------------------------------------------------------
GT11				  CODE	    03B5	1127
GT12				  CODE	    03B8	1128
GT2				  CODE	    03C5	1137
GTEST				  CODE	    039E	1117
HC1				  CODE	    0380	1087
HEX2X				  CODE	    05C9	1582
HEXDO1				  CODE	    0374	1074
HEXDON				  CODE	    0373	1072
HEXOUT				  CODE	    05BD	1570
HEXSC1				  CODE	    0362	1061
HEXSCAN				  CODE	    0360	1054
HEX_CHECK			  CODE	    0378	1079
HOUT1				  CODE	    05D5	1591
HOUTHI				  CODE	    05E0	1599
HOUTLO				  CODE	    05E1	1601
HS1				  CODE	    0375	1076
IE				  DATA	      A8
IE0				  BIT	      89
IE0IRQ				  CODE	    0005	  26
IE1				  BIT	      8B
INC_AND_GET_R1_CHARACTER	  CODE	    0421	1211
INC_ASTKA			  CODE	    0607	1637
INC_FP_EXP			  CODE	    024C	 747
INERR				  CODE	    0407	1185
INLOOP				  CODE	    0393	1109
INLPIK				  CODE	    039B	1114
INT0				  BIT	      B2
INT1				  BIT	      B3
INTGRC				  BIT	      31	 152
IP				  DATA	      B8
IT0				  BIT	      88
IT1				  BIT	      8A
LCCA				  NUMBER    0078	   8
LCCALC				  CODE	    0897	1840
LCCB				  NUMBER    0080	   9
LCCT				  NUMBER    0088	  10
LCDCHROUT			  CODE	    0B70	2264
LCDCLEAR			  CODE	    0B84	2278
LCDCLEAR1			  CODE	    0B8A	2281
LCDCLEARLINE			  CODE	    0BD1	2330
LCDCLEARLINE1			  CODE	    0BD7	2333
LCDCMDOUT			  CODE	    0B60	2253
LCDDELAY			  CODE	    0B50	2240
LCDINIT				  CODE	    0BB8	2316
LCDLINE				  NUMBER    0040	   2
LCDNIBOUT			  CODE	    0B59	2247
LCDPRINTSTR			  CODE	    0B94	2290
LCDPRNTCSTR			  CODE	    0B9B	2296
LCDPRNTCSTR1			  CODE	    0B9F	2298
LCDPRNTCSTR2			  CODE	    0BA8	2304
LCDSETADR			  CODE	    0B8F	2286
LCF1				  NUMBER    0060	   5
LCF2				  NUMBER    0068	   6
LCF3				  NUMBER    0070	   7
LCMETERGETFRQ			  CODE	    086B	1812
LCMETERGETFRQ1			  CODE	    0883	1824

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 48



SYMBOL				  TYPE     VALUE	LINE
------------------------------------------------------------
LCMETERINIT			  CODE	    08B6	1856
LCMETERINIT1			  CODE	    08CC	1862
LEFT				  CODE	    02CD	 893
LEFT1				  CODE	    02CF	 899
LEFT3				  CODE	    02D7	 905
LEFT5				  CODE	    02F6	 932
LEFTL				  CODE	    02E2	 914
LMETER				  CODE	    09A8	1972
LMETER1				  CODE	    09C7	1991
LMETER2				  CODE	    09CF	1996
LMETER3				  CODE	    09ED	2007
LOAD1				  CODE	    009D	 321
LOAD2				  CODE	    00AD	 333
LOAD3				  CODE	    00B5	 340
LOAD4				  CODE	    00BE	 350
LOAD5				  CODE	    00D0	 364
LOAD7				  CODE	    026D	 779
LOADR1				  CODE	    0356	1043
LOADR1_MANTISSA			  CODE	    0352	1034
LOAD_POINTERS			  CODE	    0338	 990
MCUSTACK			  NUMBER    0090	  11
MDES1				  CODE	    0341	1011
MNL0				  CODE	    0318	 964
MNL1				  CODE	    032A	 976
MNLOOP				  CODE	    030F	 956
MODE				  NUMBER    0051	   4
MODE0				  CODE	    0043	  57
MODE1				  CODE	    004D	  58
MODE2				  CODE	    0055	  59
MODE3				  CODE	    005D	  60
MODE4				  CODE	    0067	  61
MODEMAX				  NUMBER    0004	  14
MOUT				  CODE	    0547	1458
MOVAS				  CODE	    062A	1667
MSIGN				  BIT	      78	 190
MUL11				  CODE	    0573	1498
MULNUM				  CODE	    055A	1476
MULNUM10			  CODE	    0557	1472
MULX				  CODE	    057A	1505
MUL_DIV_EXP_AND_SIGN		  CODE	    033F	1002
MUL_NIBBLE			  CODE	    0305	 942
M_C				  CODE	    062C	1668
NL1				  CODE	    0527	1428
NR1				  CODE	    0530	1437
NUM_LT				  CODE	    0520	1422
NUM_RT				  CODE	    0529	1431
OUTR				  CODE	    0515	1411
OUTR0				  CODE	    0504	1397
OV				  BIT	      D2
OVE1				  CODE	    0272	 790
OVERFLOW			  NUMBER    0001	 168
OVERFLOW_AND_EXIT		  CODE	    026E	 783
P				  BIT	      D0
P0				  DATA	      80
P1				  DATA	      90
P2				  DATA	      A0

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 49



SYMBOL				  TYPE     VALUE	LINE
------------------------------------------------------------
P3				  DATA	      B0
PACK				  CODE	    01FD	 664
PACK0				  CODE	    0206	 677
PACK1				  CODE	    0207	 679
PACK2				  CODE	    0211	 687
PACK3				  CODE	    0223	 701
PACK4				  CODE	    0229	 708
PCL				  CODE	    0667	1721
PCON				  DATA	      87
PLOOP				  CODE	    022B	 712
PLUS_MINUS_TEST			  CODE	    0428	1224
PMT0				  CODE	    042D	1228
PMT1				  CODE	    0432	1234
PMT2				  CODE	    0430	1230
PMT3				  CODE	    0431	1232
POPAS				  CODE	    0618	1652
POP_AND_EXIT			  CODE	    0095	 312
POSNM1				  CODE	    03E7	1162
POSNUM				  CODE	    03E4	1159
PRET				  CODE	    024B	 745
PRNTCDPTRLCD			  CODE	    0BAD	2308
PRNTCDPTRLCD1			  CODE	    0BB7	2314
PRTERR				  CODE	    007A	 270
PS				  BIT	      BC
PSW				  DATA	      D0
PT0				  BIT	      B9
PT1				  BIT	      BB
PUSHAS				  CODE	    061C	1655
PUSHC				  CODE	    0663	1719
PX0				  BIT	      B8
PX1				  BIT	      BA
P_Z				  CODE	    0649	1697
R0B0				  NUMBER    0000	 165
R1B0				  NUMBER    0001	 166
R5OUT				  CODE	    05F6	1624
RB8				  BIT	      9A
RD				  BIT	      B7
REN				  BIT	      9C
RESET				  CODE	    0000
RET_X				  CODE	    0409	1187
RI				  BIT	      98
RIGHT				  CODE	    0295	 840
RIGHT1				  CODE	    0297	 847
RIGHT3				  CODE	    029F	 855
RIGHT5				  CODE	    02BE	 881
RIGHTL				  CODE	    02AB	 865
ROUT				  CODE	    054B	1461
RS0				  BIT	      D3
RS1				  BIT	      D4
RSUB				  CODE	    0598	1532
RSUB1				  CODE	    059A	1534
RSUB2				  CODE	    05B7	1560
RSUB4				  CODE	    05BA	1563
RSUB_R				  CODE	    0597	1530
RXD				  BIT	      B0
SBUF				  DATA	      99

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 50



SYMBOL				  TYPE     VALUE	LINE
------------------------------------------------------------
SCON				  DATA	      98
SE1				  CODE	    008F	 306
SETMODE				  CODE	    001C	  39
SETMODE1			  CODE	    0022	  42
SETMODE2			  CODE	    002D	  47
SETMODE3			  CODE	    0032	  49
SETMODE4			  CODE	    0037	  51
SETMODE5			  CODE	    003C	  53
SETREG				  CODE	    0620	1658
SETREG1				  CODE	    0621	1659
SIGNS_DIFFERENT			  CODE	    0147	 476
SINOUT				  CODE	    0544	1455
SINT				  CODE	    0023
SM0				  BIT	      9F
SM1				  BIT	      9E
SM2				  BIT	      9D
SOUT				  CODE	    0553	1467
SOUT1				  CODE	    0555	1469
SOUT_1				  CODE	    05D3	1589
SP				  DATA	      81
SPACE7				  CODE	    0531	1439
SQ_ERR				  CODE	    0605	1634
SRT				  CODE	    0617	1650
SS7				  CODE	    0542	1453
START				  CODE	    082D	1768
START0				  CODE	    0800	1752
START1				  CODE	    0837	1774
START2				  CODE	    083D	1778
START3				  CODE	    0845	1783
START4				  CODE	    084D	1788
STDIG				  CODE	    03FB	1178
STDIG1				  CODE	    040A	1189
STORE2				  CODE	    0243	 737
STORE_ALIGN_TEST_AND_EXIT	  CODE	    023D	 727
SUBIT				  CODE	    0A55	2075
SUBLP				  CODE	    00EE	 388
SWAP_AND_EXIT			  CODE	    008B	 299
T0				  BIT	      B4
T1				  BIT	      B5
TB8				  BIT	      9B
TCON				  DATA	      88
TF0				  BIT	      8D
TF1				  BIT	      8F
TH0				  DATA	      8C
TH1				  DATA	      8D
TI				  BIT	      99
TIMER0				  CODE	    000B
TIMER1				  CODE	    001B
TL0				  DATA	      8A
TL1				  DATA	      8B
TMOD				  DATA	      89
TR0				  BIT	      8C
TR1				  BIT	      8E
TXD				  BIT	      B1
ULOOP				  CODE	    025C	 765
UNDERFLOW			  NUMBER    0000	 167

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 51



SYMBOL				  TYPE     VALUE	LINE
------------------------------------------------------------
UNDERFLOW_AND_EXIT		  CODE	    027F	 802
UNPACK_R0			  CODE	    0258	 758
USING0				  CODE	    0469	1284
USING1				  CODE	    046F	1289
USING2				  CODE	    0481	1302
USINGX				  CODE	    047F	1300
USINGY				  CODE	    047C	1297
U_RET				  CODE	    0503	1395
VARCOP				  CODE	    0633	1677
V_C				  CODE	    0635	1678
WAIT				  CODE	    0A25	2037
WAIT1				  CODE	    0A26	2038
WAIT100				  CODE	    0A1C	2031
WAIT1001			  CODE	    0A20	2033
WAITASEC			  CODE	    0AAA	2131
WAITASEC1			  CODE	    0AB0	2134
WR				  BIT	      B6
XOUT0				  CODE	    04DC	1367
XOUT2				  CODE	    04E1	1371
XOUT3				  CODE	    04E9	1376
XOUT4				  CODE	    04ED	1380
XSIGN				  BIT	      50	 191
Z7R7				  CODE	    0539	1445
ZERO				  NUMBER    0002	 169
ZERO7				  CODE	    053A	1447
ZERO_AND_EXIT			  CODE	    0285	 813
ZERO_DIVIDE			  NUMBER    0003	 170
ZOUT				  CODE	    054F	1464
ZRO				  CODE	    0677	1731
ZSURP				  BIT	      36	 154
ZT0				  CODE	    0518	1415
ZT1				  CODE	    051F	1420
ZTEST				  CODE	    0516	1413
