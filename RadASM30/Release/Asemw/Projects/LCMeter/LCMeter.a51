
LCDLINE		EQU	40h				;16 Bytes
FPCHR_OUT	EQU	50h				;Holds addrss to next byte during FP number convertion
MODE		EQU	51h
LCF1		EQU	60H				;LC Meter F1
LCF2		EQU	68h				;LC Meter F2
LCF3		EQU	70h				;LC Meter F3
LCCA		EQU	78h				;((F1/F2)^2)-1
LCCB		EQU	80h				;((1/2*Pi*F1)^2)*LCCA
LCCT		EQU	88h				;Temp
MCUSTACK	EQU	90h
FPSTACK		EQU	0FFh

MODEMAX		EQU	4

		ORG	0000h

;RESET:***********************************************
		ORG	0000h

		LJMP	START0
;IE0IRQ:**********************************************
		ORG	0003h
		AJMP	IE0IRQ

IE0IRQ:		INC	MODE
		ACALL	SETMODE
		ACALL	DEBOUNCEINT0
		LJMP	START

DEBOUNCEINT0:	MOV	R6,#00h
		MOV	R7,#00h
DEBOUNCEINT01:	JNB	P3.2,DEBOUNCEINT0
		DJNZ	R6,DEBOUNCEINT01
		DJNZ	R7,DEBOUNCEINT01
		CLR	IE0
		RETI

SETMODE:	MOV	A,MODE
		CJNE	A,#MODEMAX+1,SETMODE1
		CLR	A
SETMODE1:	MOV	MODE,A
		MOV	R7,A
		MOV	DPTR,#MODE0
		DJNZ	R7,SETMODE2
		MOV	DPTR,#MODE1
SETMODE2:	DJNZ	R7,SETMODE3
		MOV	DPTR,#MODE2
SETMODE3:	DJNZ	R7,SETMODE4
		MOV	DPTR,#MODE3
SETMODE4:	DJNZ	R7,SETMODE5
		MOV	DPTR,#MODE4
SETMODE5:	LCALL	LCDCLEAR
		LCALL	PRNTCDPTRLCD
		RET

MODE0:		DB	'Calibrate',0
MODE1:		DB	'C Meter',0
MODE2:		DB 	'L Meter',0
MODE3:		DB	'Frq Count',0
MODE4:		DB	'Frq Count 1GHz',0

$INCLUDE	(FP52INT.a51)

		ORG	0800h

START0:		MOV	SP,#MCUSTACK			;Init stack pointer.
		CLR	P1.4				;L/C
		CLR	P1.5				;CAL
		CLR	A
		MOV	IE,A				;Disable all interrupts
		SETB	EX0				;Enable INT0
		SETB	EA				;Enable interrupts
		LCALL	FLOATING_INIT
		ACALL	WAITASEC
		ACALL	LCDINIT
		CLR	A
		ACALL	LCDSETADR
		ACALL	LCDPRNTCSTR
		DB	'Welcome Ketil',0
		ACALL	WAITASEC
		MOV	MODE,#00h
START:		ACALL	LCDCLEARLINE
		MOV	R7,MODE
		DJNZ	R7,START1
		;C Meter
		ACALL	CMeter
		SJMP	START
START1:		DJNZ	R7,START2
		;L Meter
		ACALL	LMeter
		SJMP	START
START2:		DJNZ	R7,START3
		;30MHz
		MOV	A,#01h				;CH1, 30MHz
		ACALL	FREQUENCY
		SJMP	START
START3:		DJNZ	R7,START4
		;1GHz
		MOV	A,#02h				;CH2, 1GHz
		ACALL	FREQUENCY
		SJMP	START
START4:		;Calibrate
		ACALL	LCMETERINIT
		MOV	MODE,#03h
		SJMP	START

FREQUENCY:	CLR	P1.4				;C
		CLR	P1.5				;F1
		ACALL	FRQCOUNT
		MOV	R0,#LCDLINE+4			;Decimal buffer
		ACALL	BIN2DEC
		MOV	R7,A				;Number of digits
		ACALL	FRQFORMAT
		CLR	A				;Output result
		ACALL	LCDSETADR
		MOV	R0,#LCDLINE
		MOV	R7,#10h
		ACALL	LCDPRINTSTR
		RET

;------------------------------------------------------------------

;Get LC meter frquency
;IN:	R1 points to FP buffer
;OUT:	Nothing
LCMETERGETFRQ:	PUSH	01h				;Save R1
		MOV	A,#250
		ACALL	WAIT				;Wait 25ms for relay to kick in / out
		MOV	A,#250
		ACALL	WAIT				;Wait 25ms for relay to kick in / out
		MOV	A,#00h				;CH0, LC Meter
		ACALL	FRQCOUNT
		MOV	R0,#LCDLINE
		ACALL	BIN2DEC
		MOV	R0,#LCDLINE
		MOV	R1,#CONVT
		MOV	R7,#0Ah
LCMETERGETFRQ1:	MOV	A,@R0
		MOV	@R1,A
		INC	R0
		INC	R1
		DJNZ	R7,LCMETERGETFRQ1
		MOV	A,#0Dh
		MOVX	@R1,A
		MOV	R1,#CONVT
		LCALL	FLOATING_POINT_INPUT
		POP	01h				;Restore R1
		LCALL	POPAS				;POP ARGUMENT TO R1
		RET

;Calculate X=((Fa/Fb)^2)-1
;IN:	Fa=R0, Fb=R1
;OUT:	Nothing
LCCALC:		PUSH	01h
		LCALL	PUSHAS				; PUSH R0 TO ARGUMENT
		POP	00h
		LCALL	PUSHAS				; PUSH R0 TO ARGUMENT
		LCALL	FLOATING_DIV
		MOV	R0,ARG_STACK
		LCALL	PUSHAS				; PUSH R0 TO ARGUMENT
		LCALL	FLOATING_MUL
		MOV	DPTR,#FPONE
		LCALL	PUSHC				; PUSH ARG IN DPTR TO STACK
		LCALL	FLOATING_SUB
		RET

;Get LC meter frquency F1 and F2. Calculatr LCCA=((F1/F2)^2)-1 and LCCB=LCCA*((1/(2*Pi*F1))^2)*(1/Ccal)
;IN:	Nothing
;OUT:	Nothing
LCMETERINIT:	CLR	P1.4				;C
		CLR	P1.5				;F1
		ACALL	LCDCLEAR
		ACALL	LCDPRNTCSTR
		DB	'Calibrating',0
		MOV	R7,#05h
LCMETERINIT1:	PUSH	07h
		ACALL	WAITASEC
		MOV	A,#'.'
		ACALL	LCDCHROUT
		POP	07h
		DJNZ	R7,LCMETERINIT1
		CLR	P1.5				;F1
		MOV	R1,#LCF1
		LCALL	LCMETERGETFRQ			;Get F1
		SETB	P1.5				;F2
		MOV	R1,#LCF2
		ACALL	LCMETERGETFRQ			;Get F2
		CLR	P1.5				;F1
		;Calculate LCCA=((F1/F2)^2)-1
		MOV	R0,#LCF1
		MOV	R1,#LCF2
		ACALL	LCCALC
		;Save result to LCCA
		MOV	R1,#LCCA
		LCALL	POPAS				;POP ARGUMENT TO R1
		;Calculate A=(1/(2*Pi*F1))^2
		MOV	DPTR,#FPTWO
		LCALL	PUSHC				;PUSH ARG IN DPTR TO STACK
		MOV	DPTR,#FPPI
		LCALL	PUSHC				;PUSH ARG IN DPTR TO STACK
		LCALL	FLOATING_MUL
		MOV	R0,#LCF1
		LCALL	PUSHAS				;PUSH R0 TO ARGUMENT
		LCALL	FLOATING_MUL
		MOV	R1,#LCCT
		LCALL	POPAS				;POP ARGUMENT TO R1
		MOV	DPTR,#FPONE
		LCALL	PUSHC				;PUSH ARG IN DPTR TO STACK
		MOV	R0,#LCCT
		LCALL	PUSHAS				;PUSH R0 TO ARGUMENT
		LCALL	FLOATING_DIV
		MOV	R0,ARG_STACK
		LCALL	PUSHAS				;PUSH R0 TO ARGUMENT
		LCALL	FLOATING_MUL
		;Calculate LCCB=A*LCCA*(1/Ccal)
		MOV	R0,#LCCA
		LCALL	PUSHAS				;PUSH R0 TO ARGUMENT
		LCALL	FLOATING_MUL
		MOV	DPTR,#FPCCAL
		LCALL	PUSHC				;PUSH ARG IN DPTR TO STACK
		LCALL	FLOATING_DIV
		;Save result to LCCB
		MOV	R1,#LCCB
		LCALL	POPAS				;POP ARGUMENT TO R1
		LCALL	LCDCLEAR
		RET

;Capacitance meter: Cx=((F1/F3)^2)-1)/((F1/F2)^2)-1)*Ccal
;IN:	Nothing
;OUT:	Nothing
CMETER:		CLR	P1.4				;C
		CLR	P1.5				;F1
		MOV	R1,#LCF3
		ACALL	LCMETERGETFRQ			;Get F3
		;Calculate A=((F1/F3)^2)-1
		MOV	R0,#LCF1
		MOV	R1,#LCF3
		ACALL	LCCALC
		;Calculate B=A/LCCA
		MOV	R0,#LCCA
		LCALL	PUSHAS				;PUSH R0 TO ARGUMENT
		LCALL	FLOATING_DIV
		;Calculate Cx=A/B*Ccal
		MOV	DPTR,#FPCCAL
		LCALL	PUSHC				;PUSH ARG IN DPTR TO STACK
		LCALL	FLOATING_MUL
		MOV	R0,ARG_STACK
		DEC	R0
		MOV	A,@R0
		INC	R0
		JZ	CMETER1
		CLR	A
		MOV	@R0,A
CMETER1:	MOV	A,@R0
		MOV	LCDLINE+14,#'p'
		MOV	DPTR,#FPP
		JZ	CMETER2
		CJNE	A,#78h,$+3
		JC	CMETER2
		MOV	LCDLINE+14,#'n'
		MOV	DPTR,#FPN
CMETER2:	LCALL	PUSHC				;PUSH ARG IN DPTR TO STACK
		LCALL	FLOATING_MUL
		MOV	LCDLINE,#'C'
		MOV	LCDLINE+1,#' '
		MOV	LCDLINE+2,#'='
		MOV	LCDLINE+3,#' '
		MOV	LCDLINE+15,#'F'
		MOV	FPCHR_OUT,#LCDLINE+4
		MOV	FORMAT,#53h
		MOV	A,ARG_STACK
		CLR	C
		SUBB	A,#05h
		MOV	R0,A
		LCALL	FLOATING_POINT_OUTPUT
		CLR	A				;Output result
		ACALL	LCDSETADR
		MOV	R0,#LCDLINE
		MOV	R7,#10h
		ACALL	LCDPRINTSTR
		RET

;Inductance meter Lx=((F1/F3)^2)-1)*((F1/F2)^2)-1)*((1/(2*Pi*F1))^2)*(1/Ccal)
;IN:	Nothing
;OUT:	Nothing
LMETER:		SETB	P1.4				;L
		CLR	P1.5				;F1
		MOV	R1,#LCF3
		ACALL	LCMETERGETFRQ			;Get F3
		;Calculate A=((F1/F3)^2)-1
		MOV	R0,#LCF1
		MOV	R1,#LCF3
		ACALL	LCCALC
		;Calculate B=A*LCCB
		MOV	R0,#LCCB
		LCALL	PUSHAS				;PUSH R2:R0 TO ARGUMENT
		LCALL	FLOATING_MUL
		MOV	R0,ARG_STACK
		DEC	R0
		MOV	A,@R0
		INC	R0
		JZ	LMETER1
		CLR	A
		MOV	@R0,A
LMETER1:	MOV	A,@R0
		CJNE	A,#80h,$+3
		JC	LMETER2
		CLR	A
		MOV	@R0,A
LMETER2:	MOV	LCDLINE+14,#'n'
		MOV	DPTR,#FPN
		JZ	LMETER3
		CJNE	A,#7Bh,$+3
		JC	LMETER3
		MOV	LCDLINE+14,#'u'
		MOV	DPTR,#FPU
		CJNE	A,#7Eh,$+3
		JC	LMETER3
		MOV	LCDLINE+14,#'m'
		MOV	DPTR,#FPM
LMETER3:	LCALL	PUSHC				;PUSH ARG IN DPTR TO STACK
		LCALL	FLOATING_MUL
		MOV	LCDLINE,#'L'
		MOV	LCDLINE+1,#' '
		MOV	LCDLINE+2,#'='
		MOV	LCDLINE+3,#' '
		MOV	LCDLINE+15,#'H'
		MOV	FPCHR_OUT,#LCDLINE+4
		MOV	FORMAT,#53h
		MOV	A,ARG_STACK
		CLR	C
		SUBB	A,#05h
		MOV	R0,A
		LCALL	FLOATING_POINT_OUTPUT
		MOV	A,#00h
		ACALL	LCDSETADR
		MOV	R0,#LCDLINE
		MOV	R7,#10h
		ACALL	LCDPRINTSTR
		RET

;Wait functions
;------------------------------------------------------------------

WAIT100:	PUSH	07h				;Save R7
		MOV	R7,#64h
WAIT1001:	DJNZ	R7,WAIT1001			;Wait loop, 100uS
		POP	07h				;Restore R7
		RET

WAIT:		XCH	A,R7
WAIT1:		ACALL	WAIT100
		DJNZ	R7,WAIT1
		XCH	A,R7
		RET

;Binary to decimal converter
;Converts R7:R6:R5:R4 to decimal pointed to by R0
;Returns with number of digits in A
;------------------------------------------------------------------
BIN2DEC:	PUSH	00h
		MOV	DPTR,#BINDEC
		MOV	R2,#0Ah
BIN2DEC1:	MOV	R3,#2Fh
BIN2DEC2:	INC	R3
		ACALL	SUBIT
		JNC	BIN2DEC2
		ACALL	ADDIT
		MOV	A,R3
		MOV	@R0,A
		INC	R0
		INC	DPTR
		INC	DPTR
		INC	DPTR
		INC	DPTR
		DJNZ	R2,BIN2DEC1
		POP	00h
		;Remove leading zeroes
		MOV	R2,#09h
BIN2DEC3:	MOV	A,@R0
		CJNE	A,#30h,BIN2DEC4
		MOV	@R0,#20h
		INC	R0
		DJNZ	R2,BIN2DEC3
BIN2DEC4:	INC	R2
		MOV	A,R2
		RET

SUBIT:		CLR	A
		MOVC	A,@A+DPTR
		XCH	A,R4
		CLR	C
		SUBB	A,R4
		MOV	R4,A
		MOV	A,#01h
		MOVC	A,@A+DPTR
		XCH	A,R5
		SUBB	A,R5
		MOV	R5,A
		MOV	A,#02h
		MOVC	A,@A+DPTR
		XCH	A,R6
		SUBB	A,R6
		MOV	R6,A
		MOV	A,#03h
		MOVC	A,@A+DPTR
		XCH	A,R7
		SUBB	A,R7
		MOV	R7,A
		RET

ADDIT:		CLR	A
		MOVC	A,@A+DPTR
		ADD	A,R4
		MOV	R4,A
		MOV	A,#01h
		MOVC	A,@A+DPTR
		ADDC	A,R5
		MOV	R5,A
		MOV	A,#02h
		MOVC	A,@A+DPTR
		ADDC	A,R6
		MOV	R6,A
		MOV	A,#03h
		MOVC	A,@A+DPTR
		ADDC	A,R7
		MOV	R7,A
		RET

BINDEC:		DB 000h,0CAh,09Ah,03Bh			;1000000000
		DB 000h,0E1h,0F5h,005h			; 100000000
		DB 080h,096h,098h,000h			;  10000000
		DB 040h,042h,0Fh,0000h			;   1000000
		DB 0A0h,086h,001h,000h			;    100000
		DB 010h,027h,000h,000h			;     10000
		DB 0E8h,003h,000h,000h			;      1000
		DB 064h,000h,000h,000h			;       100
		DB 00Ah,000h,000h,000h			;        10
		DB 001h,000h,000h,000h			;         1

;------------------------------------------------------------------

;Wait loop. Waits 1 second
;------------------------------------------------------------------
WAITASEC:	MOV	R7,#0F9h
		MOV	R6,#51
		MOV	R5,#16
WAITASEC1:	DJNZ	R7,WAITASEC1
		DJNZ	R6,WAITASEC1
		DJNZ	R5,WAITASEC1
		RET

;Frequency counter. LSB from 74HC590 read at P0, TL0, TH0,
;TF0 bit. 25 bits, max 33554431 Hz
;IN:	A Channel (0-3)
;OUT:	32 Bit result in R7:R6:R5:R4
;------------------------------------------------------------------
FRQCOUNT:	SETB	P1.3				;DISABLE COUNT
		CLR	P1.2				;RESET 74HC590
		SETB	P1.2
		;Select channel
		MOV	C,ACC.0
		MOV	P1.0,C
		MOV	C,ACC.1
		MOV	P1.1,C
		MOV	TL0,#00h
		MOV	TH0,#00h
		MOV	A,TMOD
		SETB	ACC.0				;M00
		CLR	ACC.1				;M01
		SETB	ACC.2				;C/T0#
		CLR	ACC.3				;GATE0
		MOV	TMOD,A
		MOV	A,TCON
		SETB	ACC.4				;TR0
		CLR	ACC.5				;TF0
		MOV	TCON,A
		CLR	P1.3				;ENABLR COUNT
		ACALL	WAITASEC
		SETB	P1.3				;DISABLE COUNT
		MOV	A,P0				;8 BITS FROM 74HC590
		MOV	R4,A
		MOV	A,TL0				;8 BITS FROM 
		MOV	R5,A
		MOV	A,TH0				;8 BITS FROM 
		MOV	R6,A
		CLR	A				;TF0 Is the 25th bit
		MOV	C,TF0
		RLC	A
		MOV	R7,A
		RET

;Format frequency conter text line
;	LCDLINE+4 Decimal result
;	R7 Number of digits
;OUT:	Formatted LCDLINE
FRQFORMAT:	MOV	LCDLINE+0,#'F'
		MOV	LCDLINE+1,#'='
		MOV	LCDLINE+2,#' '
		MOV	R0,#LCDLINE+3
		MOV	R1,#LCDLINE+5
		CJNE	R7,#07h,$+3
		JC	FRQFORMATKHZ
		;MHz
		MOV	R7,#09h
FRQFORMATMHZ1:	MOV	A,@R1
		CJNE	R7,#06h,FRQFORMATMHZ2
		MOV	@R0,#'.'
		INC	R0
FRQFORMATMHZ2:	MOV	@R0,A
		INC	R0
		INC	R1
		DJNZ	R7,FRQFORMATMHZ1
		MOV	LCDLINE+13,#'M'
		MOV	LCDLINE+14,#'H'
		MOV	LCDLINE+15,#'z'
		SJMP	FRQFORMATDONE
FRQFORMATKHZ:	CJNE	R7,#04h,$+3
		JC	FRQFORMATHZ
		;KHz
		MOV	R7,#09h
FRQFORMATKHZ1:	MOV	A,@R1
		CJNE	R7,#03h,FRQFORMATKHZ2
		MOV	@R0,#'.'
		INC	R0
FRQFORMATKHZ2:	MOV	@R0,A
		INC	R0
		INC	R1
		DJNZ	R7,FRQFORMATKHZ1
		MOV	LCDLINE+13,#'K'
		MOV	LCDLINE+14,#'H'
		MOV	LCDLINE+15,#'z'
		SJMP	FRQFORMATDONE
FRQFORMATHZ:	;Hz
		INC	R0
		MOV	R7,#09h
FRQFORMATHZ1:	MOV	A,@R1
		MOV	@R0,A
		INC	R0
		INC	R1
		DJNZ	R7,FRQFORMATHZ1
		MOV	LCDLINE+13,#'H'
		MOV	LCDLINE+14,#'z'
		MOV	LCDLINE+15,#' '
FRQFORMATDONE:	RET

;LCD Output.
;------------------------------------------------------------------
;TXBYTE:		MOV	SBUF,A
;		JNB	TI,$
;		CLR	TI
;		RET

LCDDELAY:	PUSH	07h
		MOV	R7,#00h
		DJNZ	R7,$
		POP	07h
		RET

;A contains nibble, ACC.4 contains RS
LCDNIBOUT:	SETB	ACC.5				;E
		MOV	P2,A
		CLR	P2.5				;Negative edge on E
		RET

;A contains byte
LCDCMDOUT:	PUSH	ACC
		SWAP	A				;High nibble first
		ANL	A,#0Fh
		ACALL	LCDNIBOUT
		POP	ACC
		ANL	A,#0Fh
		ACALL	LCDNIBOUT
		ACALL	LCDDELAY			;Wait for BF to clear
		RET

;A contains byte
LCDCHROUT:
;		AJMP	TXBYTE
		PUSH	ACC
		SWAP	A				;High nibble first
		ANL	A,#0Fh
		SETB	ACC.4				;RS
		ACALL	LCDNIBOUT
		POP	ACC
		ANL	A,#0Fh
		SETB	ACC.4				;RS
		ACALL	LCDNIBOUT
		ACALL	LCDDELAY			;Wait for BF to clear
		RET

LCDCLEAR:	MOV	A,#00000001b
		ACALL	LCDCMDOUT
		MOV	R7,#00h
LCDCLEAR1:	ACALL	LCDDELAY
		DJNZ	R7,LCDCLEAR1
		RET

;A contais address
LCDSETADR:	ORL	A,#10000000b
		ACALL	LCDCMDOUT
		RET

LCDPRINTSTR:	MOV	A,@R0
		ACALL	LCDCHROUT
		INC	R0
		DJNZ	R7,LCDPRINTSTR
		RET

LCDPRNTCSTR:	POP	DPH
		POP	DPL
LCDPRNTCSTR1:	CLR	A
		MOVC	A,@A+DPTR
		INC	DPTR
		JZ	LCDPRNTCSTR2
		ACALL	LCDCHROUT
		SJMP	LCDPRNTCSTR1
LCDPRNTCSTR2:	PUSH	DPL
		PUSH	DPH
		RET

PRNTCDPTRLCD:	CLR	A
		MOVC	A,@A+DPTR
		JZ	PRNTCDPTRLCD1
		LCALL	LCDCHROUT
		INC	DPTR
		SJMP	PRNTCDPTRLCD
PRNTCDPTRLCD1:	RET

LCDINIT:	MOV	A,#00000011b			;Function set
		ACALL	LCDNIBOUT
		ACALL	LCDDELAY			;Wait for BF to clear
		MOV	A,#00101000b
		ACALL	LCDCMDOUT
		MOV	A,#00101000b
		ACALL	LCDCMDOUT
		MOV	A,#00001100b			;Display ON/OFF
		ACALL	LCDCMDOUT
		ACALL	LCDCLEAR			;Clear
		MOV	A,#00000110b			;Cursor direction
		ACALL	LCDCMDOUT
		RET

LCDCLEARLINE:	MOV	R0,#LCDLINE			;Get logic levels
		MOV	R7,#10h
		MOV	A,#20H
LCDCLEARLINE1:	MOV	@R0,A
		INC	R0
		DJNZ	R7,LCDCLEARLINE1
		RET

		END

