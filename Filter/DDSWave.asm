
.code

SineGenerator proc uses ebx esi edi,ncount:DWORD
	LOCAL	tmp:DWORD

	push	ddswavedata.DDS_Amplitude
	xor		ebx,ebx
	mov		edi,ncount
	shl		edi,4
	.while ebx<edi
		fld		float2
		fldpi
		fmulp	st(1),st
		mov		tmp,ebx
		fild	tmp
		fmulp	st(1),st
		mov		eax,ncount
		mov		tmp,eax
		fild	tmp
		fdivp	st(1),st
		fsin
		mov		tmp,2047
		fild	tmp
		fmulp	st(1),st
		fistp	tmp
		mov		eax,tmp
		add		eax,2048
		mov		ecx,ddswavedata.DDS_Amplitude
		mul		ecx
		mov		ecx,4096
		div		ecx
		mov		ecx,ddswavedata.DDS_Amplitude
		shr		ecx,1
		sub		ax,cx
		add		ax,2048
		mov		ecx,ddswavedata.DDS_DCOffset
		add		ax,cx
		sub		ax,4096
		.if CARRY?
			xor		ax,ax
		.elseif ax>4095
			mov		ax,4095
		.endif
		mov		TestWave[ebx*WORD],ax
		sub		ddswavedata.DDS_Amplitude,32
		.if sdword ptr ddswavedata.DDS_Amplitude<0
			mov		ddswavedata.DDS_Amplitude,0
		.endif

;PrintDec tmp
		inc		ebx
	.endw
	pop		ddswavedata.DDS_Amplitude
	ret

SineGenerator endp

;//Simple "bandpass resonator" (notch) filter I generated with FIVIEW,
;// used to demostrate that the ADC to DAC path is working.
;
;// Center frequency is 880Hz, Q=50
;// FIVIEW generates code with doubles, I converted it to floats as
;// the STM32F4 had hardware FP for floats, but not doubles
;
;///////////////////////////////////////////////////////////////////////
;
;// Generated by Fiview 0.9.10 <http://uazu.net/fiview/>.  
;// All generated example code below is in the public domain.
;// Filter 1
;// File: -i #1
;// Guessed type: band-pass
;//
;// Frequency-response:
;//   Peak gain: 796.775
;//   Guessed 100% gain: 796.775
;//   Regions between half-power points (70.71% response or -3.01dB):
;//     871.245Hz -> 888.845Hz  (width 17.6Hz, midpoint 880.045Hz)
;//   Regions between quarter-power points (50% response or -6.02dB):
;//     864.89Hz -> 895.372Hz  (width 30.482Hz, midpoint 880.131Hz)
;//
;// Filter descriptions:
;//   BpRe/50/880 == Bandpass resonator, Q=50 (0 means Inf), frequency 880
;//
;// Example code (optimised for cleaner compilation to efficient machine code)
;float filter(register float val)
;{
;   static float buf[2];
;   register float tmp, fir, iir;
;   tmp= buf[0]; memmove(buf, buf+1, 1*sizeof(float));
;
;   iir= val * 0.001255059246835381 * 0.75;   
;   iir -= 0.9974898815063291*tmp; fir= -tmp;
;   iir -= -1.981739077169366*buf[0];
;
;   fir += iir;
;   buf[1]= iir; val= fir;
;   return val;
;}

Filter1 proc uses ebx esi edi,val:REAL4
	LOCAL	tmp:REAL4
	LOCAL	fir:REAL4
	LOCAL	iir:REAL4

	;tmp = buf[0]
	fld		buf[0]
	fst		tmp
	;fir = -tmp
	fchs
	fstp	fir
	;memmove(buf, buf+1, 1*sizeof(float))
	fld		buf[4]
	fstp	buf[0]
	;iir = val * 0.001255059246835381 * 0.75
	fld		val
	fmul	iir1a
	fmul	iir2a
	fstp	iir
	;iir -= 0.9974898815063291*tmp; fir= -tmp
	fld		iir
	fld		tmp
	fmul	iir3a
	fsubp	st(1),st
	fstp	iir
	;iir -= -1.981739077169366*buf[0]
	fld		iir
	fld		buf[0]
	fmul	iir4a
	fsubp	st(1),st
	fstp	iir
	;fir += iir
	fld		fir
	fadd	iir
	fstp	fir
	;buf[1]= iir
	fld		iir
	fstp	buf[4]
	;val = fir
	fld		fir
	fistp	val
	;return val
	mov		eax,val
	ret

Filter1 endp

;fiview 800000 -i BpRe/100/200000
;// Example code (functionally the same as the above code, but 
;//  optimised for cleaner compilation to efficient machine code)
;double
;process(register double val) {
;   static double buf[2];
;   register double tmp, fir, iir;
;   tmp= buf[0]; memmove(buf, buf+1, 1*sizeof(double));
;   // use 0.007792618324143074 below for unity gain at 100% level
;   iir= val * 0.007792618324143074;
;   iir -= 0.9844147633517139*tmp; fir= -tmp;
;   iir -= -1.2150259892613e-016*buf[0];
;   fir += iir;
;   buf[1]= iir; val= fir;
;   return val;
;}
;
Filter2 proc uses ebx esi edi,val:REAL4
	LOCAL	tmp:REAL4
	LOCAL	fir:REAL4
	LOCAL	iir:REAL4

	;tmp = buf[0]
	fld		buf[0]
	fst		tmp
	;fir = -tmp
	fchs
	fstp	fir
	;memmove(buf, buf+1, 1*sizeof(float))
	fld		buf[4]
	fstp	buf[0]
	;iir = val * 0.007792618324143074 * 1.0
	fld		val
	fmul	iir1b
	fmul	iir2b
	fstp	iir
	;iir -= 0.9844147633517139*tmp
	fld		iir
	fld		tmp
	fmul	iir3b
	fsubp	st(1),st
	fstp	iir
	;iir -= -1.2150259892613e-016*buf[0]
	fld		iir
	fld		buf[0]
	fmul	iir4b
	fsubp	st(1),st
	fstp	iir
	;fir += iir
	fld		fir
	fadd	iir
	fstp	fir
	;buf[1]= iir
	fld		iir
	fstp	buf[4]
	;val = fir
	fld		fir
	fistp	val
	;return val
	mov		eax,val
	ret

Filter2 endp

;fiview 800000 -i BpBe8/190000-210000
;// Example code (functionally the same as the above code, but 
;//  optimised for cleaner compilation to efficient machine code)
;double
;process(register double val) {
;   static double buf[2];
;   register double tmp, fir, iir;
;   tmp= buf[0]; memmove(buf, buf+1, 1*sizeof(double));
;   // use 0.07295965726826664 below for unity gain at 100% level
;   iir= val * 0.07295965726827532;
;   iir -= 0.8540806854634667*tmp; fir= -tmp;
;   iir -= -1.013642496376809e-016*buf[0];
;   fir += iir;
;   buf[1]= iir; val= fir;
;   return val;
;}
;
Filter3 proc uses ebx esi edi,val:REAL4
	LOCAL	tmp:REAL4
	LOCAL	fir:REAL4
	LOCAL	iir:REAL4
	LOCAL	imm:REAL4
	LOCAL	ival:DWORD

	;tmp = buf[0]
	fld		buf[0]
	fstp	tmp
	;memmove(buf, buf+1, 15*sizeof(double))
	invoke RtlMoveMemory,addr buf[0],addr buf[4],sizeof REAL4
	;iir= val * 0.07295965726827532
	;iir= val * 0.03780475417091263;

	fld		val
	fmul	iir1c
	fstp	iir
	;iir -= 0.8540806854634667 * tmp
   	;iir -= 0.9243904916582072*tmp;
	fld		iir
	fld		tmp
	fmul	iir2c
	fsubp	st(1),st
	fstp	iir
	;fir = -tmp
	fld		tmp
	fchs
	fstp	fir
	;iir -= -1.013642496376809e-016 * buf[0]
	;iir -= -1.361799464336839*buf[0];
	fld		iir
	fld		buf[0]
	fmul	iir3c
	fsubp	st(1),st
	fstp	iir
	;fir += iir
	fld		fir
	fadd	iir
	fstp	fir
	;buf[1] = iir;
	fld		iir
	fstp	buf[4]
	;val = fir
	fld		fir
	fistp	ival
	mov		eax,ival
	ret

Filter3 endp

DDSGenWave proc uses ebx esi edi
	LOCAL	val:REAL4
	LOCAL	ival:DWORD

	mov		WavePoints,8
	invoke SineGenerator,WavePoints
	xor		ebx,ebx
	xor		edi,edi
	shl		WavePoints,4
	.while ebx<4096
		.if edi==WavePoints
			xor		edi,edi
		.endif
		movsx	eax,TestWave[edi*WORD]
		mov		ival,eax
		fild	ival
		fstp	val
		invoke Filter3,val
		add		eax,2048
;PrintDec eax
		mov		wave[ebx*WORD],ax
		inc		ebx
		inc		edi
	.endw
	shr		WavePoints,4
	invoke InvalidateRect,childdialogs.hWndDDSWave,NULL,TRUE
	invoke UpdateWindow,childdialogs.hWndDDSWave

;	mov		eax,ddswavedata.SWEEP_StepSize
;	mov		ecx,ddswavedata.SWEEP_StepCount
;	shr		ecx,1
;	mul		ecx
;	mov		ebx,ddswavedata.DDS_PhaseFrq
;	sub		ebx,eax
;	mov		eax,ddswavedata.SWEEP_StepSize
;	mov		ecx,ddswavedata.SWEEP_StepCount
;	mul		ecx
;	mov		edx,ebx
;	add		edx,eax
;	mov		eax,ddswavedata.SWEEP_SubMode
;	.if eax==SWEEP_SubModeUp
;		mov		ddswavedata.DDS_Sweep.SWEEP_UpDovn,FALSE
;		mov		ddswavedata.DDS_Sweep.SWEEP_Min,ebx
;		mov		ddswavedata.DDS_Sweep.SWEEP_Max,edx
;		mov		eax,ddswavedata.SWEEP_StepSize
;		mov		ddswavedata.DDS_Sweep.SWEEP_Add,eax
;	.elseif eax==SWEEP_SubModeDown
;		mov		ddswavedata.DDS_Sweep.SWEEP_UpDovn,FALSE
;		mov		ddswavedata.DDS_Sweep.SWEEP_Max,ebx
;		mov		ddswavedata.DDS_Sweep.SWEEP_Min,edx
;		mov		eax,ddswavedata.SWEEP_StepSize
;		neg		eax
;		mov		ddswavedata.DDS_Sweep.SWEEP_Add,eax
;	.elseif eax==SWEEP_SubModeUpDown
;		mov		ddswavedata.DDS_Sweep.SWEEP_UpDovn,TRUE
;		mov		ddswavedata.DDS_Sweep.SWEEP_Min,ebx
;		mov		ddswavedata.DDS_Sweep.SWEEP_Max,edx
;		mov		eax,ddswavedata.SWEEP_StepSize
;		mov		ddswavedata.DDS_Sweep.SWEEP_Add,eax
;	.elseif eax==SWEEP_SubModePeak
;		mov		ddswavedata.DDS_Sweep.SWEEP_UpDovn,FALSE
;		mov		ddswavedata.DDS_Sweep.SWEEP_Min,ebx
;		mov		ddswavedata.DDS_Sweep.SWEEP_Max,edx
;		mov		eax,ddswavedata.SWEEP_StepSize
;		mov		ddswavedata.DDS_Sweep.SWEEP_Add,eax
;	.endif
	ret

DDSGenWave endp

DDSHzToPhaseAdd proc frq:DWORD

	fild	frq
	fild	dds64
	fmulp	st(1),st
	fild	ddscycles
	fmulp	st(1),st
	fild	STM32Clock
	fdivp	st(1),st
	fistp	frq
	mov		eax,frq
	ret

DDSHzToPhaseAdd endp

DDSPhaseFrqToHz proc PhaseAdd:DWORD
	
	fild	STM32Clock
	fild	dds64
	fdivp	st(1),st
	fild	ddscycles
	fdivp	st(1),st
	fild	PhaseAdd
	fmulp	st(1),st
	fistp	PhaseAdd
	mov		eax,PhaseAdd
	ret

DDSPhaseFrqToHz endp

DDSWaveSetupProc proc uses ebx esi edi,hWin:HWND,uMsg:UINT,wParam:WPARAM,lParam:LPARAM

	mov		eax,uMsg
	.if eax==WM_INITDIALOG
		mov		eax,hWin
		mov		childdialogs.hWndDDSWaveSetup,eax
		mov		esi,offset szDDS_Waves
		.while byte ptr [esi]
			invoke SendDlgItemMessage,hWin,IDC_CBODDSWAVE,CB_ADDSTRING,0,esi
			invoke lstrlen,esi
			lea		esi,[esi+eax+1]
		.endw
		mov		eax,ddswavedata.DDS_WaveForm
		invoke SendDlgItemMessage,hWin,IDC_CBODDSWAVE,CB_SETCURSEL,eax,0
		invoke SendDlgItemMessage,hWin,IDC_TRBDDSAMP,TBM_SETRANGE,FALSE,(DACMAX SHL 16)
		mov		eax,ddswavedata.DDS_Amplitude
		invoke SendDlgItemMessage,hWin,IDC_TRBDDSAMP,TBM_SETPOS,TRUE,eax
		invoke SendDlgItemMessage,hWin,IDC_TRBDDSDCOFS,TBM_SETRANGE,FALSE,(((DACMAX+1)*2-1) SHL 16)
		mov		eax,ddswavedata.DDS_DCOffset
		invoke SendDlgItemMessage,hWin,IDC_TRBDDSDCOFS,TBM_SETPOS,TRUE,eax
		invoke SendDlgItemMessage,hWin,IDC_TRBDDSFRQH,TBM_SETRANGE,FALSE,(DDSMAX SHL 16)
		mov		eax,ddswavedata.DDS_Frequency
		shr		eax,15
		invoke SendDlgItemMessage,hWin,IDC_TRBDDSFRQH,TBM_SETPOS,TRUE,eax
		invoke SendDlgItemMessage,hWin,IDC_TRBDDSFRQL,TBM_SETRANGE,FALSE,(DDSMAX SHL 16)
		mov		eax,ddswavedata.DDS_Frequency
		and		eax,DDSMAX
		invoke SendDlgItemMessage,hWin,IDC_TRBDDSFRQL,TBM_SETPOS,TRUE,eax
		invoke DDSPhaseFrqToHz,ddswavedata.DDS_PhaseFrq
		invoke SetDlgItemInt,hWin,IDC_EDTDDSFREQUENCY,eax,FALSE
		invoke SendDlgItemMessage,hWin,IDC_EDTDDSFREQUENCY,EM_LIMITTEXT,7,0
		mov		eax,ddswavedata.SWEEP_SubMode
		add		eax,IDC_RBNSWEEPOFF
		dec		eax
		invoke CheckRadioButton,hWin,IDC_RBNSWEEPOFF,IDC_RBNSWEEPPEAK,eax
		invoke SendDlgItemMessage,hWin,IDC_EDTSWEEPSIZE,EM_LIMITTEXT,4,0
		invoke DDSPhaseFrqToHz,ddswavedata.SWEEP_StepSize
		invoke SetDlgItemInt,hWin,IDC_EDTSWEEPSIZE,eax,FALSE
		invoke SendDlgItemMessage,hWin,IDC_EDTSWEEPTIME,EM_LIMITTEXT,4,0
		mov		eax,ddswavedata.SWEEP_StepTime
		inc		eax
		cdq
		mov		ecx,10
		div		ecx
		invoke SetDlgItemInt,hWin,IDC_EDTSWEEPTIME,eax,FALSE
		invoke SendDlgItemMessage,hWin,IDC_EDTSWEEPCOUNT,EM_LIMITTEXT,4,0
		mov		eax,ddswavedata.SWEEP_StepCount
		dec		eax
		invoke SetDlgItemInt,hWin,IDC_EDTSWEEPCOUNT,eax,FALSE
		invoke GetDlgItem,hWin,IDC_BTNDDSSET
		invoke EnableWindow,eax,FALSE
		invoke GetDlgItem,hWin,IDC_BTNSWEEPSET
		invoke EnableWindow,eax,FALSE
	.elseif eax==WM_COMMAND
		mov		edx,wParam
		movzx	eax,dx
		shr		edx,16
		.if edx==BN_CLICKED
			.if eax==IDC_BTNDDSSET
				invoke GetDlgItemInt,hWin,IDC_EDTDDSFREQUENCY,NULL,FALSE
				.if eax
					.if eax>5255000
						invoke SetDlgItemInt,hWin,IDC_EDTDDSFREQUENCY,5255000,FALSE
						mov		eax,5255000
					.endif
					invoke DDSHzToPhaseAdd,eax
					mov		ddswavedata.DDS_PhaseFrq,eax
					dec		eax
					mov		ddswavedata.DDS_Frequency,eax
					shr		eax,15
					invoke SendDlgItemMessage,hWin,IDC_TRBDDSFRQH,TBM_SETPOS,TRUE,eax
					mov		eax,ddswavedata.DDS_Frequency
					and		eax,DDSMAX
					invoke SendDlgItemMessage,hWin,IDC_TRBDDSFRQL,TBM_SETPOS,TRUE,eax
					invoke DDSGenWave
					invoke GetDlgItem,hWin,IDC_BTNDDSSET
					invoke EnableWindow,eax,FALSE
				.endif
			.elseif eax==IDC_RBNSWEEPOFF
				mov		ddswavedata.SWEEP_SubMode,SWEEP_SubModeOff
				invoke SendMessage,childdialogs.hWndDDSWaveDialog,WM_SIZE,0,0
				invoke DDSGenWave
			.elseif eax==IDC_RBNSWEEPUP
				mov		ddswavedata.SWEEP_SubMode,SWEEP_SubModeUp
				invoke SendMessage,childdialogs.hWndDDSWaveDialog,WM_SIZE,0,0
				invoke DDSGenWave
			.elseif eax==IDC_RBNSWEEPDOWN
				mov		ddswavedata.SWEEP_SubMode,SWEEP_SubModeDown
				invoke SendMessage,childdialogs.hWndDDSWaveDialog,WM_SIZE,0,0
				invoke DDSGenWave
			.elseif eax==IDC_RBNSWEEPUPDOWN
				mov		ddswavedata.SWEEP_SubMode,SWEEP_SubModeUpDown
				invoke SendMessage,childdialogs.hWndDDSWaveDialog,WM_SIZE,0,0
				invoke DDSGenWave
			.elseif eax==IDC_RBNSWEEPPEAK
				mov		ddswavedata.SWEEP_SubMode,SWEEP_SubModePeak
				invoke SendMessage,childdialogs.hWndDDSWaveDialog,WM_SIZE,0,0
				invoke DDSGenWave
			.elseif eax==IDC_BTNSWEEPSET
				invoke GetDlgItemInt,hWin,IDC_EDTSWEEPSIZE,NULL,FALSE
				invoke DDSHzToPhaseAdd,eax
				mov		ddswavedata.SWEEP_StepSize,eax
				invoke GetDlgItemInt,hWin,IDC_EDTSWEEPTIME,NULL,FALSE
				.if eax>6500
					invoke SetDlgItemInt,hWin,IDC_EDTSWEEPTIME,6500,FALSE
					mov		eax,6500
				.endif
				mov		ecx,10
				mul		ecx
				dec		eax
				mov		ddswavedata.SWEEP_StepTime,eax
				invoke GetDlgItemInt,hWin,IDC_EDTSWEEPCOUNT,NULL,FALSE
				.if eax>1535
					invoke SetDlgItemInt,hWin,IDC_EDTSWEEPCOUNT,1536,FALSE
					mov		eax,1535
				.endif
				inc		eax
				mov		ddswavedata.SWEEP_StepCount,eax
				invoke DDSGenWave
				invoke GetDlgItem,hWin,IDC_BTNSWEEPSET
				invoke EnableWindow,eax,FALSE
				invoke InvalidateRect,childdialogs.hWndDDSPeak,NULL,TRUE
			.endif
		.elseif edx==EN_CHANGE
			.if eax==IDC_EDTDDSFREQUENCY
				invoke GetDlgItem,hWin,IDC_BTNDDSSET
				invoke EnableWindow,eax,TRUE
			.else
				invoke GetDlgItem,hWin,IDC_BTNSWEEPSET
				invoke EnableWindow,eax,TRUE
			.endif
		.elseif edx==CBN_SELCHANGE
			invoke SendDlgItemMessage,hWin,IDC_CBODDSWAVE,CB_GETCURSEL,0,0
			mov		ddswavedata.DDS_WaveForm,eax
			invoke DDSGenWave
		.endif
	.elseif eax==WM_HSCROLL
		invoke GetDlgCtrlID,lParam
		.if eax==IDC_TRBDDSAMP
			invoke SendDlgItemMessage,hWin,IDC_TRBDDSAMP,TBM_GETPOS,0,0
			mov		ddswavedata.DDS_Amplitude,eax
			invoke DDSGenWave
		.elseif eax==IDC_TRBDDSDCOFS
			invoke SendDlgItemMessage,hWin,IDC_TRBDDSDCOFS,TBM_GETPOS,0,0
			mov		ddswavedata.DDS_DCOffset,eax
			invoke DDSGenWave
		.elseif eax==IDC_TRBDDSFRQH || eax==IDC_TRBDDSFRQL
			invoke SendDlgItemMessage,hWin,IDC_TRBDDSFRQH,TBM_GETPOS,0,0
			mov		edx,ddswavedata.DDS_Frequency
			and		edx,DDSMAX
			shl		eax,15
			or		eax,edx
			mov		ddswavedata.DDS_Frequency,eax
			invoke SendDlgItemMessage,hWin,IDC_TRBDDSFRQL,TBM_GETPOS,0,0
			mov		edx,ddswavedata.DDS_Frequency
			and		edx,0FFFF8000h
			or		eax,edx
			mov		ddswavedata.DDS_Frequency,eax
			inc		eax
			mov		ddswavedata.DDS_PhaseFrq,eax
			invoke DDSGenWave
		.endif
	.else
		mov		eax,FALSE
		ret
	.endif
	mov		eax,TRUE
	ret

DDSWaveSetupProc endp

DDSWaveProc proc uses ebx esi edi,hWin:HWND,uMsg:UINT,wParam:WPARAM,lParam:LPARAM
	LOCAL	ps:PAINTSTRUCT
	LOCAL	rect:RECT
	LOCAL	mDC:HDC
	LOCAL	pt:POINT
	LOCAL	buffer[128]:BYTE
	LOCAL	buffer1[128]:BYTE
	LOCAL	tmp:DWORD

	mov		eax,uMsg
	.if eax==WM_CREATE
		mov		eax,hWin
		mov		childdialogs.hWndDDSWave,eax
		xor		eax,eax
	.elseif eax==WM_PAINT
		invoke GetClientRect,hWin,addr rect
		invoke BeginPaint,hWin,addr ps
		invoke CreateCompatibleDC,ps.hdc
		mov		mDC,eax
		invoke CreateCompatibleBitmap,ps.hdc,rect.right,rect.bottom
		invoke SelectObject,mDC,eax
		push	eax
		invoke GetStockObject,BLACK_BRUSH
		invoke FillRect,mDC,addr rect,eax
		invoke GetClientRect,hWin,addr rect
		sub		rect.bottom,TEXTHIGHT
		invoke SetTextColor,mDC,00FF00h
		invoke SetBkMode,mDC,TRANSPARENT
		;Draw horizontal lines
		invoke CreatePen,PS_SOLID,1,0303030h
		invoke SelectObject,mDC,eax
		push	eax
		mov		eax,rect.bottom
		mov		ecx,6
		xor		edx,edx
		div		ecx
		mov		edx,eax
		mov		edi,eax
		xor		ecx,ecx
		.while ecx<5
			push	ecx
			push	edx
			invoke MoveToEx,mDC,0,edi,NULL
			invoke LineTo,mDC,rect.right,edi
			pop		edx
			add		edi,edx
			pop		ecx
			inc		ecx
		.endw
		invoke MoveToEx,mDC,0,rect.bottom,NULL
		invoke LineTo,mDC,rect.right,rect.bottom
		;Draw vertical lines
		mov		eax,rect.right
		mov		ecx,10
		xor		edx,edx
		div		ecx
		mov		edx,eax
		mov		edi,eax
		xor		ecx,ecx
		.while ecx<9
			push	ecx
			push	edx
			invoke MoveToEx,mDC,edi,0,NULL
			invoke LineTo,mDC,edi,rect.bottom
			pop		edx
			add		edi,edx
			pop		ecx
			inc		ecx
		.endw
		pop		eax
		invoke SelectObject,mDC,eax
		invoke DeleteObject,eax
		;Draw curve
		invoke CreateRectRgn,0,0,rect.right,rect.bottom
		push	eax
		invoke SelectClipRgn,mDC,eax
		pop		eax
		invoke DeleteObject,eax

		invoke CreatePen,PS_SOLID,2,303030h
		invoke SelectObject,mDC,eax
		push	eax
		mov		esi,offset TestWave
		xor		edi,edi
		xor		ebx,ebx
		call	GetPoint
		invoke MoveToEx,mDC,pt.x,pt.y,NULL
		shl		WavePoints,4
		.while ebx<64
			.if edi==WavePoints
				xor		edi,edi
			.endif
			call	GetPoint
			invoke LineTo,mDC,pt.x,pt.y
			lea		edi,[edi+1]
			lea		ebx,[ebx+1]
		.endw
		shr		WavePoints,4
		pop		eax
		invoke SelectObject,mDC,eax
		invoke DeleteObject,eax

		invoke CreatePen,PS_SOLID,2,008000h
		invoke SelectObject,mDC,eax
		push	eax
		mov		esi,offset wave
		xor		edi,edi
		xor		ebx,ebx
		call	GetPoint
		invoke MoveToEx,mDC,pt.x,pt.y,NULL
		.while ebx<64
			call	GetPoint
			invoke LineTo,mDC,pt.x,pt.y
			lea		edi,[edi+1]
			lea		ebx,[ebx+1]
		.endw
		pop		eax
		invoke SelectObject,mDC,eax
		invoke DeleteObject,eax

		add		rect.bottom,TEXTHIGHT
		invoke SelectClipRgn,mDC,NULL
		invoke BitBlt,ps.hdc,0,0,rect.right,rect.bottom,mDC,0,0,SRCCOPY
		pop		eax
		invoke SelectObject,mDC,eax
		invoke DeleteObject,eax
		invoke DeleteDC,mDC
		invoke EndPaint,hWin,addr ps
		xor		eax,eax
	.else
		invoke DefWindowProc,hWin,uMsg,wParam,lParam
	.endif
	ret

GetPoint:
	;Get X position
	lea		eax,[ebx*DWORD]
	mov		ecx,rect.right
	mul		ecx
	mov		ecx,256
	div		ecx
	mov		pt.x,eax
	;Get y position
	movsx	eax,word ptr [esi+edi*WORD]
	sub		eax,DACMAX
	neg		eax
	mov		ecx,rect.bottom
	sub		ecx,30
	.if SIGN?
		xor		ecx,ecx
	.endif
	mul		ecx
	mov		ecx,DACMAX
	div		ecx
	add		eax,20
	mov		pt.y,eax
	retn

DDSWaveProc endp

DDSPeakProc proc uses ebx esi edi,hWin:HWND,uMsg:UINT,wParam:WPARAM,lParam:LPARAM
	LOCAL	ps:PAINTSTRUCT
	LOCAL	rect:RECT
	LOCAL	mDC:HDC
	LOCAL	pt:POINT
	LOCAL	buffer[128]:BYTE
	LOCAL	buffer1[128]:BYTE
	LOCAL	tmp:DWORD

	mov		eax,uMsg
	.if eax==WM_CREATE
		mov		eax,hWin
		mov		childdialogs.hWndDDSPeak,eax
	.elseif eax==WM_PAINT
		invoke GetClientRect,hWin,addr rect
		invoke BeginPaint,hWin,addr ps
		invoke CreateCompatibleDC,ps.hdc
		mov		mDC,eax
		invoke CreateCompatibleBitmap,ps.hdc,rect.right,rect.bottom
		invoke SelectObject,mDC,eax
		push	eax
		invoke GetStockObject,BLACK_BRUSH
		invoke FillRect,mDC,addr rect,eax
		invoke GetClientRect,hWin,addr rect
		sub		rect.bottom,TEXTHIGHT
		invoke SetTextColor,mDC,00FF00h
		invoke SetBkMode,mDC,TRANSPARENT
		;Draw horizontal lines
		invoke CreatePen,PS_SOLID,1,0303030h
		invoke SelectObject,mDC,eax
		push	eax
		mov		eax,rect.bottom
		mov		ecx,6
		xor		edx,edx
		div		ecx
		mov		edx,eax
		mov		edi,eax
		xor		ecx,ecx
		.while ecx<5
			push	ecx
			push	edx
			invoke MoveToEx,mDC,0,edi,NULL
			invoke LineTo,mDC,rect.right,edi
			pop		edx
			add		edi,edx
			pop		ecx
			inc		ecx
		.endw
		invoke MoveToEx,mDC,0,rect.bottom,NULL
		invoke LineTo,mDC,rect.right,rect.bottom
		;Draw vertical lines
		mov		eax,rect.right
		mov		ecx,10
		xor		edx,edx
		div		ecx
		mov		edx,eax
		mov		edi,eax
		xor		ecx,ecx
		.while ecx<9
			push	ecx
			push	edx
			invoke MoveToEx,mDC,edi,0,NULL
			invoke LineTo,mDC,edi,rect.bottom
			pop		edx
			add		edi,edx
			pop		ecx
			inc		ecx
		.endw
		pop		eax
		invoke SelectObject,mDC,eax
		invoke DeleteObject,eax
		;Draw curve
		invoke CreateRectRgn,0,0,rect.right,rect.bottom
		push	eax
		invoke SelectClipRgn,mDC,eax
		pop		eax
		invoke DeleteObject,eax
		invoke CreatePen,PS_SOLID,2,008000h
		invoke SelectObject,mDC,eax
		push	eax
		mov		esi,offset ddswavedata.DDS_PeakData
		xor		edi,edi
		call	GetPoint
		invoke MoveToEx,mDC,pt.x,pt.y,NULL
		.while edi<ddswavedata.SWEEP_StepCount
			call	GetPoint
			invoke LineTo,mDC,pt.x,pt.y
			inc		edi
		.endw
		pop		eax
		invoke SelectObject,mDC,eax
		invoke DeleteObject,eax
		add		rect.bottom,TEXTHIGHT
		invoke SelectClipRgn,mDC,NULL
		invoke BitBlt,ps.hdc,0,0,rect.right,rect.bottom,mDC,0,0,SRCCOPY
		pop		eax
		invoke SelectObject,mDC,eax
		invoke DeleteObject,eax
		invoke DeleteDC,mDC
		invoke EndPaint,hWin,addr ps
		xor		eax,eax
	.else
		invoke DefWindowProc,hWin,uMsg,wParam,lParam
	.endif
	ret

GetPoint:
	;Get X position
	mov		eax,edi
	mov		ecx,rect.right
	mul		ecx
	mov		ecx,ddswavedata.SWEEP_StepCount
	dec		ecx
	div		ecx
	mov		pt.x,eax
	;Get y position
	movsx	eax,word ptr [esi+edi*WORD]
	sub		eax,DACMAX
	neg		eax
	mov		ecx,rect.bottom
	sub		ecx,10
	mul		ecx
	mov		ecx,DACMAX
	div		ecx
	add		eax,5
	mov		pt.y,eax
	retn

DDSPeakProc endp

DDSWaveChildProc proc uses ebx esi edi,hWin:HWND,uMsg:UINT,wParam:WPARAM,lParam:LPARAM
	LOCAL	rect:RECT

	mov		eax,uMsg
	.if eax==WM_INITDIALOG
		mov		ddswavedata.SWEEP_SubMode,SWEEP_SubModeOff
		mov		ddswavedata.DDS_DacBuffer,TRUE
		invoke DDSHzToPhaseAdd,5000	;5KHz
		mov		ddswavedata.DDS_Frequency,eax
		inc		eax
		mov		ddswavedata.DDS_PhaseFrq,eax
		mov		ddswavedata.DDS_WaveForm,DDS_ModeSinWave
		mov		ddswavedata.DDS_Amplitude,DACMAX
		mov		ddswavedata.DDS_DCOffset,DACMAX
		invoke DDSHzToPhaseAdd,10	;10Hz
		mov		ddswavedata.SWEEP_StepSize,eax
		mov		ddswavedata.SWEEP_StepTime,999
		mov		ddswavedata.SWEEP_StepCount,101
		invoke DDSGenWave
		mov		esi,offset DDS_SineWave
		mov		edi,offset ddswavedata.DDS_PeakData
		xor		ebx,ebx
		.while ebx<1536
			mov		ax,[esi+ebx*WORD]
			mov		[edi+ebx*WORD],ax
			inc		ebx
		.endw
		invoke CreateDialogParam,hInstance,IDD_DDSWAVESETUP,hWin,addr DDSWaveSetupProc,0
	.elseif	eax==WM_SIZE
		invoke GetClientRect,hWin,addr rect
		sub		rect.right,312
		.if ddswavedata.SWEEP_SubMode==SWEEP_SubModePeak
			push	rect.bottom
			invoke ShowWindow,childdialogs.hWndDDSPeak,SW_SHOWNA
			mov		ebx,rect.bottom
			shr		ebx,1
			dec		ebx
			invoke MoveWindow,childdialogs.hWndDDSWave,0,0,rect.right,ebx,TRUE
			add		ebx,2
			add		rect.top,ebx
			sub		rect.bottom,ebx
			invoke MoveWindow,childdialogs.hWndDDSPeak,0,rect.top,rect.right,rect.bottom,TRUE
			pop		rect.bottom
		.else
			invoke MoveWindow,childdialogs.hWndDDSWave,0,0,rect.right,rect.bottom,TRUE
			invoke ShowWindow,childdialogs.hWndDDSPeak,SW_HIDE
		.endif
		sub		rect.bottom,70
		invoke MoveWindow,childdialogs.hWndDDSWaveSetup,rect.right,0,312,rect.bottom,TRUE
	.elseif eax==WM_CLOSE
		invoke DestroyWindow,hWin
	.else
		mov		eax,FALSE
		ret
	.endif
	mov		eax,TRUE
	ret

DDSWaveChildProc endp
