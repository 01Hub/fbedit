
; STM32 value line Discovery Digital Oscilloscope demo project.
; -------------------------------------------------------------------------------
;
; IMPORTANT NOTICE!
; -----------------
; The use of the evaluation board is restricted:
; "This device is not, and may not be, offered for sale or lease, or sold or
; leased or otherwise distributed".
;
; For more info see this license agreement:
; http://www.st.com/internet/com/LEGAL_RESOURCES/LEGAL_AGREEMENT/
; LICENSE_AGREEMENT/EvaluationProductLicenseAgreement.pdf

.386
.model flat, stdcall  ;32 bit memory model
option casemap :none  ;case sensitive

include Filter.inc
include Frequency.asm
include HSClock.asm
include DDSWave.asm

.code

;//Simple "bandpass resonator" (notch) filter I generated with FIVIEW,
;// used to demostrate that the ADC to DAC path is working.
;
;// Center frequency is 880Hz, Q=50
;// FIVIEW generates code with doubles, I converted it to floats as
;// the STM32F4 had hardware FP for floats, but not doubles
;
;///////////////////////////////////////////////////////////////////////
;
;// Generated by Fiview 0.9.10 <http://uazu.net/fiview/>.  
;// All generated example code below is in the public domain.
;// Filter 1
;// File: -i #1
;// Guessed type: band-pass
;//
;// Frequency-response:
;//   Peak gain: 796.775
;//   Guessed 100% gain: 796.775
;//   Regions between half-power points (70.71% response or -3.01dB):
;//     871.245Hz -> 888.845Hz  (width 17.6Hz, midpoint 880.045Hz)
;//   Regions between quarter-power points (50% response or -6.02dB):
;//     864.89Hz -> 895.372Hz  (width 30.482Hz, midpoint 880.131Hz)
;//
;// Filter descriptions:
;//   BpRe/50/880 == Bandpass resonator, Q=50 (0 means Inf), frequency 880
;//
;// Example code (optimised for cleaner compilation to efficient machine code)
;float filter(register float val)
;{
;   static float buf[2];
;   register float tmp, fir, iir;
;   tmp= buf[0]; memmove(buf, buf+1, 1*sizeof(float));
;
;   iir= val * 0.001255059246835381 * 0.75;   
;   iir -= 0.9974898815063291*tmp; fir= -tmp;
;   iir -= -1.981739077169366*buf[0];
;
;   fir += iir;
;   buf[1]= iir; val= fir;
;   return val;
;}

Filter1 proc uses ebx esi edi,val:REAL4
	LOCAL	tmp:REAL4
	LOCAL	fir:REAL4
	LOCAL	iir:REAL4

	;tmp = buf[0]
	fld		buf[0]
	fst		tmp
	;fir = -tmp
	fchs
	fstp	fir
	;memmove(buf, buf+1, 1*sizeof(float))
	fld		buf[4]
	fstp	buf[0]
	;iir = val * 0.001255059246835381 * 0.75
	fld		val
	fmul	iir1a
	fmul	iir2a
	fstp	iir
	;iir -= 0.9974898815063291*tmp; fir= -tmp
	fld		iir
	fld		tmp
	fmul	iir3a
	fsubp	st(1),st
	fstp	iir
	;iir -= -1.981739077169366*buf[0]
	fld		iir
	fld		buf[0]
	fmul	iir4a
	fsubp	st(1),st
	fstp	iir
	;fir += iir
	fld		fir
	fadd	iir
	fstp	fir
	;buf[1]= iir
	fld		iir
	fstp	buf[4]
	;val = fir
	fld		fir
	fistp	val
	;return val
	mov		eax,val
	ret

Filter1 endp

;fiview 800000 -i BpRe/100/200000
;// Example code (functionally the same as the above code, but 
;//  optimised for cleaner compilation to efficient machine code)
;double
;process(register double val) {
;   static double buf[2];
;   register double tmp, fir, iir;
;   tmp= buf[0]; memmove(buf, buf+1, 1*sizeof(double));
;   // use 0.007792618324143074 below for unity gain at 100% level
;   iir= val * 0.007792618324143074;
;   iir -= 0.9844147633517139*tmp; fir= -tmp;
;   iir -= -1.2150259892613e-016*buf[0];
;   fir += iir;
;   buf[1]= iir; val= fir;
;   return val;
;}
;
Filter2 proc uses ebx esi edi,val:REAL4
	LOCAL	tmp:REAL4
	LOCAL	fir:REAL4
	LOCAL	iir:REAL4

	;tmp = buf[0]
	fld		buf[0]
	fst		tmp
	;fir = -tmp
	fchs
	fstp	fir
	;memmove(buf, buf+1, 1*sizeof(float))
	fld		buf[4]
	fstp	buf[0]
	;iir = val * 0.007792618324143074 * 1.0
	fld		val
	fmul	iir1b
	fmul	iir2b
	fstp	iir
	;iir -= 0.9844147633517139*tmp
	fld		iir
	fld		tmp
	fmul	iir3b
	fsubp	st(1),st
	fstp	iir
	;iir -= -1.2150259892613e-016*buf[0]
	fld		iir
	fld		buf[0]
	fmul	iir4b
	fsubp	st(1),st
	fstp	iir
	;fir += iir
	fld		fir
	fadd	iir
	fstp	fir
	;buf[1]= iir
	fld		iir
	fstp	buf[4]
	;val = fir
	fld		fir
	fistp	val
	;return val
	mov		eax,val
	ret

Filter2 endp

;fiview 800000 -i BpBe8/190000-210000
;// Example code (functionally the same as the above code, but 
;//  optimised for cleaner compilation to efficient machine code)
;double
;process(register double val) {
;   static double buf[16];
;   register double tmp, fir, iir;
;   tmp= buf[0]; memmove(buf, buf+1, 15*sizeof(double));
;   // use 1.187762813747436e-007 below for unity gain at 100% level
;   iir= val * 1.187762813747532e-007;
;   iir -= 0.8716668814893267*tmp; fir= tmp;
;   iir -= 0.2914719502507858*buf[0]; fir += -buf[0]-buf[0];
;   fir += iir;
;   tmp= buf[1]; buf[1]= iir; val= fir;
;   iir= val;
;   iir -= 0.8716668814893267*tmp; fir= tmp;
;   iir -= -0.2914719502507859*buf[2]; fir += -buf[2]-buf[2];
;   fir += iir;
;   tmp= buf[3]; buf[3]= iir; val= fir;
;   iir= val;
;   iir -= 0.8069569133336105*tmp; fir= tmp;
;   iir -= 0.1974007336168805*buf[4]; fir += -buf[4]-buf[4];
;   fir += iir;
;   tmp= buf[5]; buf[5]= iir; val= fir;
;   iir= val;
;   iir -= 0.8069569133336102*tmp; fir= tmp;
;   iir -= -0.19740073361688*buf[6]; fir += -buf[6]-buf[6];
;   fir += iir;
;   tmp= buf[7]; buf[7]= iir; val= fir;
;   iir= val;
;   iir -= 0.7726049819407979*tmp; fir= tmp;
;   iir -= 0.1155002465382225*buf[8]; fir += buf[8]+buf[8];
;   fir += iir;
;   tmp= buf[9]; buf[9]= iir; val= fir;
;   iir= val;
;   iir -= 0.7726049819407979*tmp; fir= tmp;
;   iir -= -0.1155002465382225*buf[10]; fir += buf[10]+buf[10];
;   fir += iir;
;   tmp= buf[11]; buf[11]= iir; val= fir;
;   iir= val;
;   iir -= 0.7570893527850519*tmp; fir= tmp;
;   iir -= 0.03809080303384055*buf[12]; fir += buf[12]+buf[12];
;   fir += iir;
;   tmp= buf[13]; buf[13]= iir; val= fir;
;   iir= val;
;   iir -= 0.757089352785052*tmp; fir= tmp;
;   iir -= -0.03809080303384059*buf[14]; fir += buf[14]+buf[14];
;   fir += iir;
;   buf[15]= iir; val= fir;
;   return val;
;}
;
Filter3 proc uses ebx esi edi,val:REAL4
	LOCAL	tmp:REAL4
	LOCAL	fir:REAL4
	LOCAL	iir:REAL4
	LOCAL	imm:REAL4

	;tmp = buf[0]
	fld		buf[0]
	fst		tmp
	;memmove(buf, buf+1, 15*sizeof(double))
	invoke RtlMoveMemory,addr buf[0],addr buf[4],15*sizeof REAL4
	;iir= val * 1.187762813747532e-007
	fld		val
	fmul	iir1c
	ret

Filter3 endp



MakeCommand proc

	mov		command.cmnd,STM32_CMNDWait
	;High speed clock
	mov		eax,hsclockdata.hsclockenable
	mov		command.HSC_enable,al
	mov		eax,hsclockdata.hsclockdivisor
	.if eax==1
		;Div5
		mov		eax,4
	.elseif eax==2
		;Div10
		mov		eax,9
	.elseif eax==3
		;Div50
		mov		eax,49
	.elseif eax==4
		;Div100
		mov		eax,99
	.elseif eax==5
		;Div500
		mov		eax,499
	.elseif eax==6
		;Div1000
		mov		eax,999
	.elseif eax==7
		;Div5000
		mov		eax,4999
	.elseif eax==8
		;Div10000
		mov		eax,9999
	.elseif eax==9
		;Div50000
		mov		eax,49999
	.endif
	mov		command.HSC_div,ax
	mov		eax,65536
	sub		eax,hsclockdata.hsclockfrequency
	mov		command.HSC_frq,eax
	mov		eax,hsclockdata.hsclockccr
	mov		command.HSC_dutycycle,eax
	;DDS wave generator
	mov		eax,ddswavedata.DDS_WaveForm
	lea		eax,[eax+1]
	mov		command.WaveType,eax
	mov		eax,ddswavedata.DDS_Amplitude
	mov		command.Amplitude,eax
	mov		eax,ddswavedata.DDS_DCOffset
	mov		command.DCOffset,eax
	mov		eax,ddswavedata.DDS_PhaseFrq
	mov		command.DDS_PhaseFrq,eax
	.if ddswavedata.DDS_Enable
		mov		eax,ddswavedata.SWEEP_SubMode
		mov		command.DDS_SubMode,al
	.else
		mov		command.DDS_SubMode,0
	.endif
	mov		eax,ddswavedata.DDS_DacBuffer
	mov		command.DDS_DacBuffer,al
	mov		eax,ddswavedata.SWEEP_StepTime
	mov		command.SWEEP_StepTime,ax
	mov		eax,ddswavedata.DDS_Sweep.SWEEP_UpDovn
	mov		command.SWEEP_UpDovn,eax
	mov		eax,ddswavedata.DDS_Sweep.SWEEP_Min
	mov		command.SWEEP_Min,eax
	mov		eax,ddswavedata.DDS_Sweep.SWEEP_Max
	mov		command.SWEEP_Max,eax
	mov		eax,ddswavedata.DDS_Sweep.SWEEP_Add
	mov		command.SWEEP_Add,eax
	ret

MakeCommand endp

;SampleThreadProc proc lParam:DWORD
;	LOCAL	buffer[32]:BYTE
;	LOCAL	tmp:DWORD
;
;	;Get frequency and DVM
;	invoke STLinkRead,hWnd,STM32_Frequency,addr tmp,4
;	invoke FormatFrequency,addr buffer,addr szNULL,tmp
;	invoke SetDlgItemText,childdialogs.hWndFrequency,IDC_UDCFREQUENCY,addr buffer
;	invoke STLinkRead,hWnd,STM32_DVM,addr tmp,4
;	mov		eax,tmp
;	add		DVMSum,eax
;	inc		nDVMCount
;	.if nDVMCount==8
;		mov		eax,DVMSum
;		mov		ecx,DVMMUL
;		mul		ecx
;		mov		ecx,DVMMAX*8
;		div		ecx
;		invoke FormatVoltage,addr buffer,addr szFmtVolts,eax
;		invoke SetDlgItemText,childdialogs.hWndFrequency,IDC_UDCVOLTSDVM,addr buffer
;		mov		nDVMCount,0
;		mov		DVMSum,0
;	.endif
;	.if fCommand
;		mov		fCommand,0
;		invoke STLinkReset,hWnd
;		invoke MakeCommand
;		mov		command.cmnd,STM32_CMNDWait
;		invoke STLinkWrite,hWnd,STM32_Command,addr command,sizeof COMMAND
;		.if ddswavedata.FRQ_Enable
;			mov		command.cmnd,STM32_CMNDFrqEnable
;			invoke STLinkWrite,hWnd,STM32_Command,addr command,4
;		.endif
;		mov		command.cmnd,STM32_CMNDStart
;		invoke STLinkWrite,hWnd,STM32_Command,addr command,4
;	.endif
;	.if command.DDS_SubMode==SWEEP_SubModePeak && ddswavedata.DDS_Enable
;		invoke STLinkRead,hWnd,STM32_Peak,addr ddswavedata.DDS_PeakData,1536*WORD
;		invoke InvalidateRect,childdialogs.hWndDDSPeak,NULL,TRUE
;	.endif
;	mov		fThread,FALSE
;	ret
;
;SampleThreadProc endp

MainDlgProc proc uses ebx esi edi,hWin:HWND,uMsg:UINT,wParam:WPARAM,lParam:LPARAM
	LOCAL	rect:RECT
	LOCAL	tid:DWORD
	LOCAL	tci:TC_ITEM
	LOCAL	val:REAL4
	LOCAL	ival:DWORD

	mov		eax,uMsg
	.if	eax==WM_INITDIALOG
		mov		eax,hWin
		mov		hWnd,eax
		invoke GetDlgItem,hWin,IDC_MAINTAB
		mov		childdialogs.hWndMainTab,eax
		mov		tci.imask,TCIF_TEXT
		mov		tci.lpReserved1,0
		mov		tci.lpReserved2,0
		mov		tci.iImage,-1
		mov		tci.lParam,0
		mov		tci.pszText,offset szTabTitleDDS
		invoke SendMessage,childdialogs.hWndMainTab,TCM_INSERTITEM,0,addr tci
		mov		tci.pszText,offset szTabTitleHSC
		invoke SendMessage,childdialogs.hWndMainTab,TCM_INSERTITEM,1,addr tci
		invoke CreateFontIndirect,addr Tahoma
		mov		hFont,eax
		;Create DDS Wave child dialog
		invoke CreateDialogParam,hInstance,IDD_DDSWAVE,childdialogs.hWndMainTab,addr DDSWaveChildProc,0
		mov		childdialogs.hWndDDSWaveDialog,eax
		;Create HS Clock child dialog
		invoke CreateDialogParam,hInstance,IDD_HSCLOCK,childdialogs.hWndMainTab,addr HSClockChildProc,0
		mov		childdialogs.hWndHSClockDialog,eax
		;Create frequency and DVM child dialog
		invoke CreateDialogParam,hInstance,IDD_FREQUENCY,childdialogs.hWndDDSWaveDialog,addr FrequencyChildProc,0
		mov		childdialogs.hWndFrequency,eax
		invoke SetTimer,hWin,1000,100,NULL
;mov		ival,2048
;fild	ival
;fstp	buf[4]
		xor		ebx,ebx
		.while ebx<4096
			mov		eax,ebx
			and		eax,0007h
			movzx	eax,TestWave[eax*WORD]
			mov		ival,eax
			fild	ival
			fstp	val
			invoke Filter2,val
;			PrintDec eax
			add		eax,2048
			mov		wave[ebx*WORD],ax
			inc		ebx
		.endw
		
	.elseif eax==WM_TIMER
;		.if !fConnected
;			mov		fConnected,IDIGNORE
;			invoke STLinkConnect,hWin
;			.if eax==IDABORT
;				invoke SendMessage,hWin,WM_CLOSE,0,0
;			.else
;				mov		fConnected,eax
;			.endif
;			.if fConnected && fConnected!=IDIGNORE
;				invoke STLinkReset,hWnd
;				.if ddswavedata.FRQ_Enable
;					mov		command.cmnd,STM32_CMNDFrqEnable
;					invoke STLinkWrite,hWnd,STM32_Command,addr command,4
;				.endif
;			.endif
;		.endif
;		.if fConnected && fConnected!=IDIGNORE && !fThread
;			mov		fThread,TRUE
;			invoke CreateThread,NULL,NULL,addr SampleThreadProc,hWin,0,addr tid
;			invoke CloseHandle,eax
;		.endif
	.elseif eax==WM_NOTIFY
		mov		eax,lParam
		.if [eax].NMHDR.code==TCN_SELCHANGE
			invoke SendMessage,childdialogs.hWndMainTab,TCM_GETCURSEL,0,0
			.if !eax
				invoke ShowWindow,childdialogs.hWndDDSWaveDialog,SW_SHOWNA
				invoke SetParent,childdialogs.hWndFrequency,childdialogs.hWndDDSWaveDialog
				invoke ShowWindow,childdialogs.hWndHSClockDialog,SW_HIDE
			.else
				invoke ShowWindow,childdialogs.hWndHSClockDialog,SW_SHOWNA
				invoke SetParent,childdialogs.hWndFrequency,childdialogs.hWndHSClockDialog
				invoke ShowWindow,childdialogs.hWndDDSWaveDialog,SW_HIDE
			.endif
		.endif
	.elseif	eax==WM_SIZE
		invoke GetClientRect,hWin,addr rect
		invoke MoveWindow,childdialogs.hWndMainTab,0,0,rect.right,rect.bottom,TRUE
		add		rect.left,5
		sub		rect.right,10
		add		rect.top,25
		sub		rect.bottom,30
		invoke MoveWindow,childdialogs.hWndDDSWaveDialog,rect.left,rect.top,rect.right,rect.bottom,TRUE
		invoke MoveWindow,childdialogs.hWndHSClockDialog,rect.left,rect.top,rect.right,rect.bottom,TRUE
	.elseif	eax==WM_CLOSE
		invoke KillTimer,hWin,1000
;		.if fConnected
;			invoke STLinkDisconnect,hWin
;		.endif
		invoke DeleteObject,hFont
		invoke EndDialog,hWin,0
	.else
		mov		eax,FALSE
		ret
	.endif
	mov		eax,TRUE
	ret

MainDlgProc endp

start:
	
	invoke	GetModuleHandle,NULL
	mov		hInstance,eax
	invoke	InitCommonControls
	mov		wc.cbSize,sizeof WNDCLASSEX
	mov		wc.style,CS_HREDRAW or CS_VREDRAW
	mov		wc.lpfnWndProc,offset TextProc
	mov		wc.lpszClassName,offset szTEXTCLASS
	mov		wc.cbClsExtra,0
	mov		wc.cbWndExtra,0
	mov		eax,hInstance
	mov		wc.hInstance,eax
	mov		wc.hIcon,NULL
	mov		wc.hIconSm,NULL
	invoke LoadCursor,0,IDC_ARROW
	mov		wc.hCursor,eax
	mov		wc.hbrBackground,NULL
	invoke RegisterClassEx,addr wc
	invoke LoadCursor,0,IDC_CROSS
	mov		wc.hCursor,eax
	mov		wc.lpfnWndProc,offset DDSWaveProc
	mov		wc.lpszClassName,offset szDDSWAVECLASS
	invoke RegisterClassEx,addr wc
	mov		wc.lpfnWndProc,offset DDSPeakProc
	mov		wc.lpszClassName,offset szDDSPEAKCLASS
	invoke RegisterClassEx,addr wc
	mov		wc.lpfnWndProc,offset HSClockProc
	mov		wc.lpszClassName,offset szHSCLOCKCLASS
	invoke RegisterClassEx,addr wc
	invoke	DialogBoxParam,hInstance,IDD_MAIN,NULL,addr MainDlgProc,NULL
	invoke	ExitProcess,0

end start
