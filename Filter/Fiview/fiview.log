// Generated by Fiview 0.9.10 <http://uazu.net/fiview/>.  
// All generated example code below is in the public domain.
// Filter 1
// File: -i #1
// Guessed type: band-pass
//
// Frequency-response:
//   Peak gain: 1
//   Guessed 100% gain: 1
//   Regions between half-power points (70.71% response or -3.01dB):
//     190000Hz -> 210000Hz  (width 19999.9Hz, midpoint 200000Hz)
//   Regions between quarter-power points (50% response or -6.02dB):
//     182750Hz -> 217250Hz  (width 34499.8Hz, midpoint 200000Hz)
//
// Time-response:
//   Sampling rate is 800000Hz
//   50% complete after 8 samples (1e-005s)
//   90% complete after 30 samples (3.75e-005s)
//   95% complete after 38 samples (4.75e-005s)
//   99% complete after 58 samples (7.25e-005s)
//   99.9% complete after 88 samples (0.00011s)
//   99.99% complete after 116 samples (0.000145s)
//   Impulse response max deviation is at 2 samples (2.5e-006s)
//   Impulse response ranges between -0.135273 and 0.115534
//
// Original filter:
//   x 0.0729596572682753
//   / 1 -1.01364249637681e-016 0.854080685463467
//   x 1 -0 -1 (BpBe1/190000-210000)
//
// Filter descriptions:
//   BpBe1/190000-210000 == Bandpass Bessel filter, order 1, -3.01dB
//     frequencies 190000-210000
//

// Example code (readable version)
double
process(register double val) {
   static double buf[2];
   register double tmp, fir, iir;
   tmp= buf[0]; memmove(buf, buf+1, 1*sizeof(double));
   // use 0.07295965726826664 below for unity gain at 100% level
   val *= 0.07295965726827532;
   iir= val+1.013642496376809e-016*buf[0]-0.8540806854634667*tmp;
   fir= iir-tmp;
   buf[1]= iir; val= fir;
   return val;
}

// Example code (functionally the same as the above code, but 
//  optimised for cleaner compilation to efficient machine code)
double
process(register double val) {
   static double buf[2];
   register double tmp, fir, iir;
   tmp= buf[0]; memmove(buf, buf+1, 1*sizeof(double));
   // use 0.07295965726826664 below for unity gain at 100% level
   iir= val * 0.07295965726827532;
   iir -= 0.8540806854634667*tmp; fir= -tmp;
   iir -= -1.013642496376809e-016*buf[0];
   fir += iir;
   buf[1]= iir; val= fir;
   return val;
}

// Example code for generating any of this class of filters at run-time
double coef[3], buf[2];
void
setup(double *coef) {
   coef[0]= 1 *
     fid_design_coef(coef+1, 2, "BpBe1", 800000, 190000, 210000, 0);
}
double
process(double *coef, double *buf, register double val) {
   register double tmp, fir, iir;
   tmp= buf[0]; memmove(buf, buf+1, 1*sizeof(double));
   iir= val * coef[0];
   iir -= coef[1]*tmp; fir= -tmp;
   iir -= coef[2]*buf[0];
   fir += iir;
   buf[1]= iir; val= fir;
   return val;
}

// Example using direct fidlib calls, and using the fidlib run-filter
//  code for execution, for maximum flexibility.
#include "fidlib/fidlib.h"    // May need adjusting
FidFilter *
setup() {
   FidFilter *filt0= fid_design("BpBe1", 800000, 190000, 210000, 0, 0);
   return filt0;
}
//
// Run a couple of instances using fidlib:
//
//   FidFilter *filt= setup();
//   FidFunc *funcp;
//   FidRun *run= fid_run_new(filt, &funcp);
//   void *fbuf1= fid_run_newbuf(run);
//   void *fbuf2= fid_run_newbuf(run);
//   while (...) {
//      out_1= funcp(fbuf1, in_1);
//      out_2= funcp(fbuf2, in_2);
//      if (restart_required) fid_run_zapbuf(fbuf1);
//      ...
//   }
//   fid_run_freebuf(fbuf2);
//   fid_run_freebuf(fbuf1);
//   fid_run_free(run);
//
// Or check the frequency response:
//   resp= fid_response(filt, freq/rate);
//

// Example code using combined stages.  WARNING: combined stages are   
//   less accurate, and can also be unstable for high-order filters.
double
process(register double val) {
   static double buf[2];
   register double tmp, fir, iir;
   tmp= buf[0]; memmove(buf, buf+1, 1*sizeof(double));
   // use 0.9999999999998812 below for unity gain at 100% level
   val *= 1;
   iir= val+1.013642496376809e-016*buf[0]-0.8540806854634667*tmp;
   fir= 0.07295965726827532*iir-0.07295965726827532*tmp;
   buf[1]= iir; val= fir;
   return val;
}


// Notes on use of example code:
// ----------------------------
//
// The example code above should be easy to adapt to your application.
// It is designed to be readable, and any unnecessary assignments used
// for readability's sake should optimise away on any decent compiler.
// memmove() is used for shifting the buffer.  This was found to be
// faster than all other portable alternatives on GCC for ix86,
// including copying longs.  Copying doubles is slowest of all due to
// conversion to/from the FPU's internal 80-bit format.
//
// The compilation-optimised version reorders the calculations into an
// order that minimises the number of values the compiler has to
// remember at any one time, giving us a better chance of decent code.
// I dare say it could all be squeezed more, but you'd need to do
// benchmarking to be sure that you are getting a real gain.  Many
// 'obvious' speed-up changes I tried actually slowed the code down --
// the behaviour of modern processors seems quite hard to predict in
// this regard.
//
// Note that the code for handling runtime generated filters receives
// clues from the filter-design code about which values are constant
// and which vary, but it can't easily pick up other patterns within
// the coefficients.  So, perhaps this also leaves some room for
// optimisation if squeezing out every last bit of performance is
// important for your application.
//
// For generating filters at runtime, call setup(coef) first to
// generate the coefficients, then use val= process(coef, buf, val)
// for each sample.  Zero the buf[] to reinitialise the filter at any
// time.  This should be easy to adapt to create banks or arrays of
// similar filters.  Within setup() you can safely change any of the
// frequencies (including the sampling rate), but not the spec-string.
//
// To use the example code that generates filters at runtime, you will
// also need the following extern declaration as a minimum:

extern double fid_design_coef(double *coef, int n_coef, char *spec, double rate,
                              double freq0, double freq1, int adj);

// Alternatively you could #include the fidlib.h file.  You will also
// need to link with the fidlib.o object file.  Probably it is easiest
// just to copy the fidlib directory into your own application and
// build it as part of it.
//
// The most general solution, using fidlib for both creating and
// running the filters, has the advantage of flexibility (all the
// filter parameters can be changed), with the cost of slightly lower
// performance and memory efficiency.
//
// Remember that the fidlib code is covered under the LGPL, and this
// means that you need to abide by the terms of the LGPL if you link
// your application with the fidlib.o object or any other fidlib code
// (which is needed if you use anything other than the hard-coded
// example routines above).  For one thing, this means that you need
// to make the fidlib source available when you distribute your
// completed app, including any changes to fidlib you may have made.
// However, the LGPL doesn't stop you keeping your own (separate)
// source code closed (more notes at http://uazu.net/license/).  See
// the COPYING_LIB file for full details of the license.
//
// Note that none of this code comes with any kind of legal warranty
// for correctness or whatever.  As Dr Tony Fisher put it on his page:
// "Don't blame me if your aircraft falls out of the sky!"


