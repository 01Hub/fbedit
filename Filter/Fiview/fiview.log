// Generated by Fiview 0.9.10 <http://uazu.net/fiview/>.  
// All generated example code below is in the public domain.
// Filter 1
// File: -i #1
// Guessed type: band-pass
//
// Frequency-response:
//   Peak gain: 1
//   Guessed 100% gain: 1
//   Regions between half-power points (70.71% response or -3.01dB):
//     190000Hz -> 210000Hz  (width 20000.1Hz, midpoint 200000Hz)
//   Regions between quarter-power points (50% response or -6.02dB):
//     186108Hz -> 213892Hz  (width 27783.7Hz, midpoint 200000Hz)
//
// Time-response:
//   Sampling rate is 800000Hz
//   50% complete after 40 samples (5e-005s)
//   90% complete after 56 samples (7e-005s)
//   95% complete after 60 samples (7.5e-005s)
//   99% complete after 68 samples (8.5e-005s)
//   99.9% complete after 102 samples (0.0001275s)
//   99.99% complete after 138 samples (0.0001725s)
//   Impulse response max deviation is at 40 samples (5e-005s)
//   Impulse response ranges between -0.0701301 and 0.0710366
//
// Original filter:
//   x 1.18776281374753e-007
//   / 1 0.291471950250786 0.871666881489327
//   x 1 -2 1
//   / 1 -0.291471950250786 0.871666881489327
//   x 1 -2 1
//   / 1 0.19740073361688 0.806956913333611
//   x 1 -2 1
//   / 1 -0.19740073361688 0.80695691333361
//   x 1 -2 1
//   / 1 0.115500246538223 0.772604981940798
//   x 1 2 1
//   / 1 -0.115500246538222 0.772604981940798
//   x 1 2 1
//   / 1 0.0380908030338405 0.757089352785052
//   x 1 2 1
//   / 1 -0.0380908030338406 0.757089352785052
//   x 1 2 1 (BpBe8/190000-210000)
//
// Filter descriptions:
//   BpBe8/190000-210000 == Bandpass Bessel filter, order 8, -3.01dB
//     frequencies 190000-210000
//

// Example code (readable version)
double
process(register double val) {
   static double buf[16];
   register double tmp, fir, iir;
   tmp= buf[0]; memmove(buf, buf+1, 15*sizeof(double));
   // use 1.187762813747436e-007 below for unity gain at 100% level
   val *= 1.187762813747532e-007;
   iir= val-0.2914719502507858*buf[0]-0.8716668814893267*tmp;
   fir= iir-buf[0]-buf[0]+tmp;
   tmp= buf[1]; buf[1]= iir; val= fir;
   iir= val+0.2914719502507859*buf[2]-0.8716668814893267*tmp;
   fir= iir-buf[2]-buf[2]+tmp;
   tmp= buf[3]; buf[3]= iir; val= fir;
   iir= val-0.1974007336168805*buf[4]-0.8069569133336105*tmp;
   fir= iir-buf[4]-buf[4]+tmp;
   tmp= buf[5]; buf[5]= iir; val= fir;
   iir= val+0.19740073361688*buf[6]-0.8069569133336102*tmp;
   fir= iir-buf[6]-buf[6]+tmp;
   tmp= buf[7]; buf[7]= iir; val= fir;
   iir= val-0.1155002465382225*buf[8]-0.7726049819407979*tmp;
   fir= iir+buf[8]+buf[8]+tmp;
   tmp= buf[9]; buf[9]= iir; val= fir;
   iir= val+0.1155002465382225*buf[10]-0.7726049819407979*tmp;
   fir= iir+buf[10]+buf[10]+tmp;
   tmp= buf[11]; buf[11]= iir; val= fir;
   iir= val-0.03809080303384055*buf[12]-0.7570893527850519*tmp;
   fir= iir+buf[12]+buf[12]+tmp;
   tmp= buf[13]; buf[13]= iir; val= fir;
   iir= val+0.03809080303384059*buf[14]-0.757089352785052*tmp;
   fir= iir+buf[14]+buf[14]+tmp;
   buf[15]= iir; val= fir;
   return val;
}

// Example code (functionally the same as the above code, but 
//  optimised for cleaner compilation to efficient machine code)
double
process(register double val) {
   static double buf[16];
   register double tmp, fir, iir;
   tmp= buf[0]; memmove(buf, buf+1, 15*sizeof(double));
   // use 1.187762813747436e-007 below for unity gain at 100% level
   iir= val * 1.187762813747532e-007;
   iir -= 0.8716668814893267*tmp; fir= tmp;
   iir -= 0.2914719502507858*buf[0]; fir += -buf[0]-buf[0];
   fir += iir;
   tmp= buf[1]; buf[1]= iir; val= fir;
   iir= val;
   iir -= 0.8716668814893267*tmp; fir= tmp;
   iir -= -0.2914719502507859*buf[2]; fir += -buf[2]-buf[2];
   fir += iir;
   tmp= buf[3]; buf[3]= iir; val= fir;
   iir= val;
   iir -= 0.8069569133336105*tmp; fir= tmp;
   iir -= 0.1974007336168805*buf[4]; fir += -buf[4]-buf[4];
   fir += iir;
   tmp= buf[5]; buf[5]= iir; val= fir;
   iir= val;
   iir -= 0.8069569133336102*tmp; fir= tmp;
   iir -= -0.19740073361688*buf[6]; fir += -buf[6]-buf[6];
   fir += iir;
   tmp= buf[7]; buf[7]= iir; val= fir;
   iir= val;
   iir -= 0.7726049819407979*tmp; fir= tmp;
   iir -= 0.1155002465382225*buf[8]; fir += buf[8]+buf[8];
   fir += iir;
   tmp= buf[9]; buf[9]= iir; val= fir;
   iir= val;
   iir -= 0.7726049819407979*tmp; fir= tmp;
   iir -= -0.1155002465382225*buf[10]; fir += buf[10]+buf[10];
   fir += iir;
   tmp= buf[11]; buf[11]= iir; val= fir;
   iir= val;
   iir -= 0.7570893527850519*tmp; fir= tmp;
   iir -= 0.03809080303384055*buf[12]; fir += buf[12]+buf[12];
   fir += iir;
   tmp= buf[13]; buf[13]= iir; val= fir;
   iir= val;
   iir -= 0.757089352785052*tmp; fir= tmp;
   iir -= -0.03809080303384059*buf[14]; fir += buf[14]+buf[14];
   fir += iir;
   buf[15]= iir; val= fir;
   return val;
}

// Example code for generating any of this class of filters at run-time
double coef[17], buf[16];
void
setup(double *coef) {
   coef[0]= 1 *
     fid_design_coef(coef+1, 16, "BpBe8", 800000, 190000, 210000, 0);
}
double
process(double *coef, double *buf, register double val) {
   register double tmp, fir, iir;
   tmp= buf[0]; memmove(buf, buf+1, 15*sizeof(double));
   iir= val * coef[0];
   iir -= coef[1]*tmp; fir= tmp;
   iir -= coef[2]*buf[0]; fir += -buf[0]-buf[0];
   fir += iir;
   tmp= buf[1]; buf[1]= iir; val= fir;
   iir= val;
   iir -= coef[3]*tmp; fir= tmp;
   iir -= coef[4]*buf[2]; fir += -buf[2]-buf[2];
   fir += iir;
   tmp= buf[3]; buf[3]= iir; val= fir;
   iir= val;
   iir -= coef[5]*tmp; fir= tmp;
   iir -= coef[6]*buf[4]; fir += -buf[4]-buf[4];
   fir += iir;
   tmp= buf[5]; buf[5]= iir; val= fir;
   iir= val;
   iir -= coef[7]*tmp; fir= tmp;
   iir -= coef[8]*buf[6]; fir += -buf[6]-buf[6];
   fir += iir;
   tmp= buf[7]; buf[7]= iir; val= fir;
   iir= val;
   iir -= coef[9]*tmp; fir= tmp;
   iir -= coef[10]*buf[8]; fir += buf[8]+buf[8];
   fir += iir;
   tmp= buf[9]; buf[9]= iir; val= fir;
   iir= val;
   iir -= coef[11]*tmp; fir= tmp;
   iir -= coef[12]*buf[10]; fir += buf[10]+buf[10];
   fir += iir;
   tmp= buf[11]; buf[11]= iir; val= fir;
   iir= val;
   iir -= coef[13]*tmp; fir= tmp;
   iir -= coef[14]*buf[12]; fir += buf[12]+buf[12];
   fir += iir;
   tmp= buf[13]; buf[13]= iir; val= fir;
   iir= val;
   iir -= coef[15]*tmp; fir= tmp;
   iir -= coef[16]*buf[14]; fir += buf[14]+buf[14];
   fir += iir;
   buf[15]= iir; val= fir;
   return val;
}

// Example using direct fidlib calls, and using the fidlib run-filter
//  code for execution, for maximum flexibility.
#include "fidlib/fidlib.h"    // May need adjusting
FidFilter *
setup() {
   FidFilter *filt0= fid_design("BpBe8", 800000, 190000, 210000, 0, 0);
   return filt0;
}
//
// Run a couple of instances using fidlib:
//
//   FidFilter *filt= setup();
//   FidFunc *funcp;
//   FidRun *run= fid_run_new(filt, &funcp);
//   void *fbuf1= fid_run_newbuf(run);
//   void *fbuf2= fid_run_newbuf(run);
//   while (...) {
//      out_1= funcp(fbuf1, in_1);
//      out_2= funcp(fbuf2, in_2);
//      if (restart_required) fid_run_zapbuf(fbuf1);
//      ...
//   }
//   fid_run_freebuf(fbuf2);
//   fid_run_freebuf(fbuf1);
//   fid_run_free(run);
//
// Or check the frequency response:
//   resp= fid_response(filt, freq/rate);
//

// Example code using combined stages.  WARNING: combined stages are   
//   less accurate, and can also be unstable for high-order filters.
double
process(register double val) {
   static double buf[16];
   register double tmp, fir, iir;
   tmp= buf[0]; memmove(buf, buf+1, 15*sizeof(double));
   // use 0.9999999999999192 below for unity gain at 100% level
   val *= 1;
   iir= val-3.885780586188048e-016*buf[14]-6.277922095455941*buf[13]
     -2.111497283442676e-015*buf[12]-17.35441601390389*buf[11]
     -4.94027561914745e-015*buf[10]-27.5814078355014*buf[9]
     -6.456505252314115e-015*buf[8]-27.55597486341137*buf[7]
     -5.07075935060608e-015*buf[6]-17.71664093994641*buf[5]
     -2.343611416044666e-015*buf[4]-7.156428696632884*buf[3]
     -5.901346306156491e-016*buf[2]-1.660100408787899*buf[1]
     -6.486324200189256e-017*buf[0]-0.1692821124715409*tmp;
   fir= 1.187762813747532e-007*iir-9.50210250998026e-007*buf[13]
     -1.799945012915388e-021*buf[12]+3.325735878493083e-006*buf[11]
     -1.736417541871316e-020*buf[10]-6.651471756986202e-006*buf[9]
     -1.397604362969596e-020*buf[8]+8.314339696232718e-006*buf[7]
     -1.397604362969596e-020*buf[6]-6.651471756986202e-006*buf[5]
     -1.736417541871316e-020*buf[4]+3.325735878493083e-006*buf[3]
     -1.799945012915388e-021*buf[2]-9.50210250998026e-007*buf[1]
     +1.187762813747532e-007*tmp;
   buf[15]= iir; val= fir;
   return val;
}


// Notes on use of example code:
// ----------------------------
//
// The example code above should be easy to adapt to your application.
// It is designed to be readable, and any unnecessary assignments used
// for readability's sake should optimise away on any decent compiler.
// memmove() is used for shifting the buffer.  This was found to be
// faster than all other portable alternatives on GCC for ix86,
// including copying longs.  Copying doubles is slowest of all due to
// conversion to/from the FPU's internal 80-bit format.
//
// The compilation-optimised version reorders the calculations into an
// order that minimises the number of values the compiler has to
// remember at any one time, giving us a better chance of decent code.
// I dare say it could all be squeezed more, but you'd need to do
// benchmarking to be sure that you are getting a real gain.  Many
// 'obvious' speed-up changes I tried actually slowed the code down --
// the behaviour of modern processors seems quite hard to predict in
// this regard.
//
// Note that the code for handling runtime generated filters receives
// clues from the filter-design code about which values are constant
// and which vary, but it can't easily pick up other patterns within
// the coefficients.  So, perhaps this also leaves some room for
// optimisation if squeezing out every last bit of performance is
// important for your application.
//
// For generating filters at runtime, call setup(coef) first to
// generate the coefficients, then use val= process(coef, buf, val)
// for each sample.  Zero the buf[] to reinitialise the filter at any
// time.  This should be easy to adapt to create banks or arrays of
// similar filters.  Within setup() you can safely change any of the
// frequencies (including the sampling rate), but not the spec-string.
//
// To use the example code that generates filters at runtime, you will
// also need the following extern declaration as a minimum:

extern double fid_design_coef(double *coef, int n_coef, char *spec, double rate,
                              double freq0, double freq1, int adj);

// Alternatively you could #include the fidlib.h file.  You will also
// need to link with the fidlib.o object file.  Probably it is easiest
// just to copy the fidlib directory into your own application and
// build it as part of it.
//
// The most general solution, using fidlib for both creating and
// running the filters, has the advantage of flexibility (all the
// filter parameters can be changed), with the cost of slightly lower
// performance and memory efficiency.
//
// Remember that the fidlib code is covered under the LGPL, and this
// means that you need to abide by the terms of the LGPL if you link
// your application with the fidlib.o object or any other fidlib code
// (which is needed if you use anything other than the hard-coded
// example routines above).  For one thing, this means that you need
// to make the fidlib source available when you distribute your
// completed app, including any changes to fidlib you may have made.
// However, the LGPL doesn't stop you keeping your own (separate)
// source code closed (more notes at http://uazu.net/license/).  See
// the COPYING_LIB file for full details of the license.
//
// Note that none of this code comes with any kind of legal warranty
// for correctness or whatever.  As Dr Tony Fisher put it on his page:
// "Don't blame me if your aircraft falls out of the sky!"


