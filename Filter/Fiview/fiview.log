// Generated by Fiview 0.9.10 <http://uazu.net/fiview/>.  
// All generated example code below is in the public domain.
// Filter 1
// File: -i #1
// Guessed type: band-pass
//
// Frequency-response:
//   Peak gain: 1
//   Guessed 100% gain: 1
//   Regions between half-power points (70.71% response or -3.01dB):
//     199084Hz -> 200920Hz  (width 1835.94Hz, midpoint 200002Hz)
//   Regions between quarter-power points (50% response or -6.02dB):
//     198624Hz -> 201384Hz  (width 2760.16Hz, midpoint 200004Hz)
//
// Time-response:
//   Sampling rate is 1.6e+006Hz
//   50% complete after 379 samples (0.000236875s)
//   90% complete after 753 samples (0.000470625s)
//   95% complete after 891 samples (0.000556875s)
//   99% complete after 1189 samples (0.000743125s)
//   99.9% complete after 1589 samples (0.000993125s)
//   99.99% complete after 1972 samples (0.0012325s)
//   Impulse response max deviation is at 284 samples (0.0001775s)
//   Impulse response ranges between -0.00382767 and 0.00382734
//
// Original filter:
//   / 1.00707106781187 -1.4142135623731 0.992928932188134
//   x 1 0 -1
//   x 0.00707106781186547
//   / 1.00707106781187 -1.4142135623731 0.992928932188134
//   x 1 0 -1
//   x 0.00707106781186547
//   / 1.00707106781187 -1.4142135623731 0.992928932188134
//   x 1 0 -1
//   x 0.00707106781186547 (BpBq3/50/200000)
//
// Filter descriptions:
//   BpBq3/50/200000 == Bandpass biquad filter, order 3, Q=50, centre
//     frequency 200000
//

// Example code (readable version)
double
process(register double val) {
   static double buf[6];
   register double tmp, fir, iir;
   tmp= buf[0]; memmove(buf, buf+1, 5*sizeof(double));
   // use 3.461582197386876e-007 below for unity gain at 100% level
   val *= 3.4615821973868e-007;
   iir= val+1.404283776561923*buf[0]-0.9859571622343808*tmp;
   fir= iir-tmp;
   tmp= buf[1]; buf[1]= iir; val= fir;
   iir= val+1.404283776561923*buf[2]-0.9859571622343808*tmp;
   fir= iir-tmp;
   tmp= buf[3]; buf[3]= iir; val= fir;
   iir= val+1.404283776561923*buf[4]-0.9859571622343808*tmp;
   fir= iir-tmp;
   buf[5]= iir; val= fir;
   return val;
}

// Example code (functionally the same as the above code, but 
//  optimised for cleaner compilation to efficient machine code)
double
process(register double val) {
   static double buf[6];
   register double tmp, fir, iir;
   tmp= buf[0]; memmove(buf, buf+1, 5*sizeof(double));
   // use 3.461582197386876e-007 below for unity gain at 100% level
   iir= val * 3.4615821973868e-007;
   iir -= 0.9859571622343808*tmp; fir= -tmp;
   iir -= -1.404283776561923*buf[0];
   fir += iir;
   tmp= buf[1]; buf[1]= iir; val= fir;
   iir= val;
   iir -= 0.9859571622343808*tmp; fir= -tmp;
   iir -= -1.404283776561923*buf[2];
   fir += iir;
   tmp= buf[3]; buf[3]= iir; val= fir;
   iir= val;
   iir -= 0.9859571622343808*tmp; fir= -tmp;
   iir -= -1.404283776561923*buf[4];
   fir += iir;
   buf[5]= iir; val= fir;
   return val;
}

// Example code for generating any of this class of filters at run-time
double coef[7], buf[6];
void
setup(double *coef) {
   coef[0]= 1 *
     fid_design_coef(coef+1, 6, "BpBq3/50", 1.6e+006, 200000, 0, 0);
}
double
process(double *coef, double *buf, register double val) {
   register double tmp, fir, iir;
   tmp= buf[0]; memmove(buf, buf+1, 5*sizeof(double));
   iir= val * coef[0];
   iir -= coef[1]*tmp; fir= -tmp;
   iir -= coef[2]*buf[0];
   fir += iir;
   tmp= buf[1]; buf[1]= iir; val= fir;
   iir= val;
   iir -= coef[3]*tmp; fir= -tmp;
   iir -= coef[4]*buf[2];
   fir += iir;
   tmp= buf[3]; buf[3]= iir; val= fir;
   iir= val;
   iir -= coef[5]*tmp; fir= -tmp;
   iir -= coef[6]*buf[4];
   fir += iir;
   buf[5]= iir; val= fir;
   return val;
}

// Example using direct fidlib calls, and using the fidlib run-filter
//  code for execution, for maximum flexibility.
#include "fidlib/fidlib.h"    // May need adjusting
FidFilter *
setup() {
   FidFilter *filt0= fid_design("BpBq3/50", 1.6e+006, 200000, 0, 0, 0);
   return filt0;
}
//
// Run a couple of instances using fidlib:
//
//   FidFilter *filt= setup();
//   FidFunc *funcp;
//   FidRun *run= fid_run_new(filt, &funcp);
//   void *fbuf1= fid_run_newbuf(run);
//   void *fbuf2= fid_run_newbuf(run);
//   while (...) {
//      out_1= funcp(fbuf1, in_1);
//      out_2= funcp(fbuf2, in_2);
//      if (restart_required) fid_run_zapbuf(fbuf1);
//      ...
//   }
//   fid_run_freebuf(fbuf2);
//   fid_run_freebuf(fbuf1);
//   fid_run_free(run);
//
// Or check the frequency response:
//   resp= fid_response(filt, freq/rate);
//

// Example code using combined stages.  WARNING: combined stages are   
//   less accurate, and can also be unstable for high-order filters.
double
process(register double val) {
   static double buf[6];
   register double tmp, fir, iir;
   tmp= buf[0]; memmove(buf, buf+1, 5*sizeof(double));
   // use 1.000000000000022 below for unity gain at 100% level
   val *= 1;
   iir= val+4.212851329685769*buf[4]-8.873910262048195*buf[3]
     +11.07664764177408*buf[2]-8.749295379891587*buf[1]
     +4.095361333906241*buf[0]-0.9584603213149187*tmp;
   fir= 3.4615821973868e-007*iir-1.03847465921604e-006*buf[3]
     +1.03847465921604e-006*buf[1]-3.4615821973868e-007*tmp;
   buf[5]= iir; val= fir;
   return val;
}


// Notes on use of example code:
// ----------------------------
//
// The example code above should be easy to adapt to your application.
// It is designed to be readable, and any unnecessary assignments used
// for readability's sake should optimise away on any decent compiler.
// memmove() is used for shifting the buffer.  This was found to be
// faster than all other portable alternatives on GCC for ix86,
// including copying longs.  Copying doubles is slowest of all due to
// conversion to/from the FPU's internal 80-bit format.
//
// The compilation-optimised version reorders the calculations into an
// order that minimises the number of values the compiler has to
// remember at any one time, giving us a better chance of decent code.
// I dare say it could all be squeezed more, but you'd need to do
// benchmarking to be sure that you are getting a real gain.  Many
// 'obvious' speed-up changes I tried actually slowed the code down --
// the behaviour of modern processors seems quite hard to predict in
// this regard.
//
// Note that the code for handling runtime generated filters receives
// clues from the filter-design code about which values are constant
// and which vary, but it can't easily pick up other patterns within
// the coefficients.  So, perhaps this also leaves some room for
// optimisation if squeezing out every last bit of performance is
// important for your application.
//
// For generating filters at runtime, call setup(coef) first to
// generate the coefficients, then use val= process(coef, buf, val)
// for each sample.  Zero the buf[] to reinitialise the filter at any
// time.  This should be easy to adapt to create banks or arrays of
// similar filters.  Within setup() you can safely change any of the
// frequencies (including the sampling rate), but not the spec-string.
//
// To use the example code that generates filters at runtime, you will
// also need the following extern declaration as a minimum:

extern double fid_design_coef(double *coef, int n_coef, char *spec, double rate,
                              double freq0, double freq1, int adj);

// Alternatively you could #include the fidlib.h file.  You will also
// need to link with the fidlib.o object file.  Probably it is easiest
// just to copy the fidlib directory into your own application and
// build it as part of it.
//
// The most general solution, using fidlib for both creating and
// running the filters, has the advantage of flexibility (all the
// filter parameters can be changed), with the cost of slightly lower
// performance and memory efficiency.
//
// Remember that the fidlib code is covered under the LGPL, and this
// means that you need to abide by the terms of the LGPL if you link
// your application with the fidlib.o object or any other fidlib code
// (which is needed if you use anything other than the hard-coded
// example routines above).  For one thing, this means that you need
// to make the fidlib source available when you distribute your
// completed app, including any changes to fidlib you may have made.
// However, the LGPL doesn't stop you keeping your own (separate)
// source code closed (more notes at http://uazu.net/license/).  See
// the COPYING_LIB file for full details of the license.
//
// Note that none of this code comes with any kind of legal warranty
// for correctness or whatever.  As Dr Tony Fisher put it on his page:
// "Don't blame me if your aircraft falls out of the sky!"


