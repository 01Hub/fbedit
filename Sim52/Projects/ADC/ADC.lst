
ASEM-51 V1.3                                         Copyright (c) 2002 by W.W. Heinz                                         PAGE 1





       MCS-51 Family Macro Assembler   A S E M - 5 1   V 1.3
       =====================================================



	Source File:	ADC.a51
	Object File:	ADC.hex
	List File:	ADC.lst



 Line  I  Addr  Code            Source

    1:
    2:		N      0040	LCDBUFF		EQU	40h				;16 Bytes
    3:		N      0010	LCDBUFFSIZE	EQU	10h
    4:
    5:		B	 09	INTGRC		BIT	21h.1		;BIT SET IF INTEGER ERROR
    6:		B	 0B	ADD_IN		BIT	21h.3		;DCMPXZ IN BASIC BACKAGE
    7:		B	 0E	ZSURP		BIT	21h.6		;ZERO SUPRESSION FOR HEX PRINT
    8:		N      0022	ARG_STACK	EQU	22h		;ARGUMENT STACK POINTER
    9:		N      0023	FORMAT		EQU	23h		;LOCATION OF OUTPUT FORMAT BYTE
   10:		N      0024	FP_STATUS	EQU	24h		;24 NOT used data pointer me
   11:		N      0066	CONVT		EQU	66h		;String addr TO CONVERT NUMBERS
   12:		N      0050	CR		EQU	50h
   13:		N      0054	FPOUTPTR	equ	54h		;Holds address of output character
   14:		N      0055	FPOUTSTR	equ	55h		;Address of output string, max 16 bytes
   15:
   16:				;RESET:***********************************************
   17:		N      0000			ORG	0000h
   18:	  0000	02 00 03			LJMP	START
   19:
   20:	  0003	75 22 85	START:		MOV	ARG_STACK,#85h	;ARG STACK
   21:	  0006	75 23 22			MOV	FORMAT,#22h	;FORMAT (##.##)
   22:	  0009	31 3A				ACALL	LCDCLEARBUFF
   23:	  000B	31 21				ACALL	LCDINIT
   24:	  000D	75 40 43			MOV	LCDBUFF,#'C'
   25:	  0010	75 41 48			MOV	LCDBUFF+1,#'H'
   26:	  0013	75 50 0D			MOV	CR,#0Dh
   27:	  0016	74 00		START1:		MOV	A,#00h			;CH0
   28:	  0018	11 9B				ACALL	ADCONVERT
   29:	  001A	7E 00				MOV	R6,#00h
   30:	  001C	7F 00				MOV	R7,#00h
   31:	  001E	78 46				MOV	R0,#LCDBUFF+6
   32:	  0020	31 45				ACALL	BIN2DEC
   33:	  0022	78 46				MOV	R0,#LCDBUFF+6
   34:	  0024	12 13 0B			LCALL	FLOATING_POINT_INPUT	;Convert to floating point
   35:	  0027	90 01 C3			MOV	DPTR,#FP5MUL
   36:	  002A	12 15 E9			LCALL	PUSHC
   37:	  002D	12 10 ED			LCALL	FLOATING_MUL
   38:	  0030	78 55				MOV	R0,#FPOUTSTR
   39:	  0032	88 54				MOV	FPOUTPTR,R0
   40:	  0034	12 13 B9			LCALL	FLOATING_POINT_OUTPUT
   41:	  0037	A8 54				MOV	R0,FPOUTPTR
   42:	  0039	79 4E				MOV	R1,#LCDBUFF+LCDBUFFSIZE-2
   43:	  003B	18		START2:		DEC	R0

ASEM-51 V1.3                                         Copyright (c) 2002 by W.W. Heinz                                         PAGE 2



 Line  I  Addr  Code            Source

   44:	  003C	E6				MOV	A,@R0
   45:	  003D	F7				MOV	@R1,A
   46:	  003E	19				DEC	R1
   47:	  003F	B8 55 F9			CJNE	R0,#FPOUTSTR,START2
   48:	  0042	75 42 30			MOV	LCDBUFF+2,#'0'
   49:	  0045	75 4F 56			MOV	LCDBUFF+LCDBUFFSIZE-1,#'V'
   50:	  0048	E4				CLR	A
   51:	  0049	31 0B				ACALL	LCDSETADR
   52:	  004B	7F 10				MOV	R7,#10h
   53:	  004D	78 40				MOV	R0,#LCDBUFF
   54:	  004F	31 10				ACALL	LCDPRINTSTR
   55:
   56:	  0051	74 01				MOV	A,#01h			;CH1
   57:	  0053	11 9B				ACALL	ADCONVERT
   58:	  0055	7E 00				MOV	R6,#00h
   59:	  0057	7F 00				MOV	R7,#00h
   60:	  0059	78 46				MOV	R0,#LCDBUFF+6
   61:	  005B	31 45				ACALL	BIN2DEC
   62:	  005D	78 46				MOV	R0,#LCDBUFF+6
   63:	  005F	12 13 0B			LCALL	FLOATING_POINT_INPUT	;Convert to floating point
   64:	  0062	90 01 C9			MOV	DPTR,#FP24MUL
   65:	  0065	12 15 E9			LCALL	PUSHC
   66:	  0068	12 10 ED			LCALL	FLOATING_MUL
   67:	  006B	78 55				MOV	R0,#FPOUTSTR
   68:	  006D	88 54				MOV	FPOUTPTR,R0
   69:	  006F	12 13 B9			LCALL	FLOATING_POINT_OUTPUT
   70:	  0072	A8 54				MOV	R0,FPOUTPTR
   71:	  0074	79 4E				MOV	R1,#LCDBUFF+LCDBUFFSIZE-2
   72:	  0076	18		START3:		DEC	R0
   73:	  0077	E6				MOV	A,@R0
   74:	  0078	F7				MOV	@R1,A
   75:	  0079	19				DEC	R1
   76:	  007A	B8 55 F9			CJNE	R0,#FPOUTSTR,START3
   77:	  007D	75 42 31			MOV	LCDBUFF+2,#'1'
   78:	  0080	75 4F 56			MOV	LCDBUFF+LCDBUFFSIZE-1,#'V'
   79:	  0083	74 40				MOV	A,#40h
   80:	  0085	31 0B				ACALL	LCDSETADR
   81:	  0087	7F 10				MOV	R7,#10h
   82:	  0089	78 40				MOV	R0,#LCDBUFF
   83:	  008B	31 10				ACALL	LCDPRINTSTR
   84:
   85:	  008D	7D 10				MOV	R5,#10h
   86:	  008F	7E 00				MOV	R6,#00h
   87:	  0091	7F 00				MOV	R7,#00h
   88:	  0093	DF FE		START4:		DJNZ	R7,START4
   89:	  0095	DE FC				DJNZ	R6,START4
   90:	  0097	DD FA				DJNZ	R5,START4
   91:	  0099	01 16				AJMP	START1
   92:
   93:				;------------------------------------------------------------------
   94:				;AD Converter.
   95:				;IN:	A holds channel (0 to 7).
   96:				;OUT:	R5:R4 Holds 16 Bit result
   97:				;-----------------------------------------------------
   98:	  009B	44 18		ADCONVERT:	ORL	A,#18h				;START, SINGLE ENDED
   99:	  009D	23				RL	A

ASEM-51 V1.3                                         Copyright (c) 2002 by W.W. Heinz                                         PAGE 3



 Line  I  Addr  Code            Source

  100:	  009E	23				RL	A
  101:	  009F	23				RL	A
  102:	  00A0	C2 90				CLR	P1.0				;CS	LOW
  103:						;Clock in start bit, 3 channel select bits, Single/Diff bit
  104:						;and 2 bits to init sampling
  105:	  00A2	7F 07				MOV	R7,#07h
  106:	  00A4	33		ADCONVERT1:	RLC	A
  107:	  00A5	92 92				MOV	P1.2,C				;DIN
  108:	  00A7	C2 91				CLR	P1.1				;CLK	LOW
  109:	  00A9	D2 91				SETB	P1.1				;CLK	HIGH
  110:	  00AB	DF F7				DJNZ	R7,ADCONVERT1
  111:	  00AD	D2 92				SETB	P1.2				;DIN	HIGH
  112:						;Clock out 1 null bit and 4 data bits
  113:	  00AF	E4				CLR	A
  114:	  00B0	7F 05				MOV	R7,#05h
  115:	  00B2	A2 93		ADCONVERT2:	MOV	C,P1.3				;DOUT
  116:	  00B4	33				RLC	A
  117:	  00B5	C2 91				CLR	P1.1				;CLK	LOW
  118:	  00B7	D2 91				SETB	P1.1				;CLK	HIGH
  119:	  00B9	DF F7				DJNZ	R7,ADCONVERT2
  120:	  00BB	FD				MOV	R5,A
  121:						;Clock out 8 data bits
  122:	  00BC	7F 08				MOV	R7,#08h
  123:	  00BE	E4				CLR	A
  124:	  00BF	A2 93		ADCONVERT3:	MOV	C,P1.3				;DOUT
  125:	  00C1	33				RLC	A
  126:	  00C2	C2 91				CLR	P1.1				;CLK	LOW
  127:	  00C4	D2 91				SETB	P1.1				;CLK	HIGH
  128:	  00C6	DF F7				DJNZ	R7,ADCONVERT3
  129:	  00C8	FC				MOV	R4,A
  130:	  00C9	D2 90				SETB	P1.0				;CS	HIGH
  131:	  00CB	22				RET
  132:
  133:				;------------------------------------------------------------------
  134:				;LCD Output.
  135:				;------------------------------------------------------------------
  136:	  00CC	C0 07		LCDDELAY:	PUSH	07h
  137:	  00CE	7F 00				MOV	R7,#00h
  138:	  00D0	DF FE				DJNZ	R7,$
  139:	  00D2	D0 07				POP	07h
  140:	  00D4	22				RET
  141:
  142:				;A contains nibble, ACC.4 contains RS
  143:	  00D5	D2 E5		LCDNIBOUT:	SETB	ACC.5				;E
  144:	  00D7	F5 A0				MOV	P2,A
  145:	  00D9	C2 A5				CLR	P2.5				;Negative edge on E
  146:	  00DB	22				RET
  147:
  148:				;A contains byte
  149:	  00DC	C0 E0		LCDCMDOUT:	PUSH	ACC
  150:	  00DE	C4				SWAP	A				;High nibble first
  151:	  00DF	54 0F				ANL	A,#0Fh
  152:	  00E1	11 D5				ACALL	LCDNIBOUT
  153:	  00E3	D0 E0				POP	ACC
  154:	  00E5	54 0F				ANL	A,#0Fh
  155:	  00E7	11 D5				ACALL	LCDNIBOUT

ASEM-51 V1.3                                         Copyright (c) 2002 by W.W. Heinz                                         PAGE 4



 Line  I  Addr  Code            Source

  156:	  00E9	11 CC				ACALL	LCDDELAY			;Wait for BF to clear
  157:	  00EB	22				RET
  158:
  159:				;A contains byte
  160:	  00EC	C0 E0		LCDCHROUT:	PUSH	ACC
  161:	  00EE	C4				SWAP	A				;High nibble first
  162:	  00EF	54 0F				ANL	A,#0Fh
  163:	  00F1	D2 E4				SETB	ACC.4				;RS
  164:	  00F3	11 D5				ACALL	LCDNIBOUT
  165:	  00F5	D0 E0				POP	ACC
  166:	  00F7	54 0F				ANL	A,#0Fh
  167:	  00F9	D2 E4				SETB	ACC.4				;RS
  168:	  00FB	11 D5				ACALL	LCDNIBOUT
  169:	  00FD	11 CC				ACALL	LCDDELAY			;Wait for BF to clear
  170:	  00FF	22				RET
  171:
  172:	  0100	74 01		LCDCLEAR:	MOV	A,#00000001b
  173:	  0102	11 DC				ACALL	LCDCMDOUT
  174:	  0104	7F 00				MOV	R7,#00h
  175:	  0106	11 CC		LCDCLEAR1:	ACALL	LCDDELAY
  176:	  0108	DF FC				DJNZ	R7,LCDCLEAR1
  177:	  010A	22				RET
  178:
  179:				;A contais address
  180:	  010B	44 80		LCDSETADR:	ORL	A,#10000000b
  181:	  010D	11 DC				ACALL	LCDCMDOUT
  182:	  010F	22				RET
  183:
  184:				;R0 points to string, R7 holds number of characters
  185:	  0110	E6		LCDPRINTSTR:	MOV	A,@R0
  186:	  0111	11 EC				ACALL	LCDCHROUT
  187:	  0113	08				INC	R0
  188:	  0114	DF FA				DJNZ	R7,LCDPRINTSTR
  189:	  0116	22				RET
  190:
  191:	  0117	E4		PRNTCDPTRLCD:	CLR	A
  192:	  0118	93				MOVC	A,@A+DPTR
  193:	  0119	60 05				JZ	PRNTCDPTRLCD1
  194:	  011B	11 EC				ACALL	LCDCHROUT
  195:	  011D	A3				INC	DPTR
  196:	  011E	80 F7				SJMP	PRNTCDPTRLCD
  197:	  0120	22		PRNTCDPTRLCD1:	RET
  198:
  199:	  0121	74 03		LCDINIT:	MOV	A,#00000011b			;Function set
  200:	  0123	11 D5				ACALL	LCDNIBOUT
  201:	  0125	11 CC				ACALL	LCDDELAY			;Wait for BF to clear
  202:	  0127	74 28				MOV	A,#00101000b
  203:	  0129	11 DC				ACALL	LCDCMDOUT
  204:	  012B	74 28				MOV	A,#00101000b
  205:	  012D	11 DC				ACALL	LCDCMDOUT
  206:	  012F	74 0C				MOV	A,#00001100b			;Display ON/OFF
  207:	  0131	11 DC				ACALL	LCDCMDOUT
  208:	  0133	31 00				ACALL	LCDCLEAR			;Clear
  209:	  0135	74 06				MOV	A,#00000110b			;Cursor direction
  210:	  0137	11 DC				ACALL	LCDCMDOUT
  211:	  0139	22				RET

ASEM-51 V1.3                                         Copyright (c) 2002 by W.W. Heinz                                         PAGE 5



 Line  I  Addr  Code            Source

  212:
  213:	  013A	78 40		LCDCLEARBUFF:	MOV	R0,#LCDBUFF
  214:	  013C	7F 10				MOV	R7,#10h
  215:	  013E	74 20				MOV	A,#20H
  216:	  0140	F6		LCDCLEARBUFF1:	MOV	@R0,A
  217:	  0141	08				INC	R0
  218:	  0142	DF FC				DJNZ	R7,LCDCLEARBUFF1
  219:	  0144	22				RET
  220:
  221:				;------------------------------------------------------------------
  222:				;Binary to decimal converter
  223:				;Converts R7:R6:R5:R4 to decimal pointed to by R0
  224:				;Returns with number of digits in A
  225:				;------------------------------------------------------------------
  226:	  0145	C0 00		BIN2DEC:	PUSH	00h
  227:	  0147	90 01 9B			MOV	DPTR,#BINDEC
  228:	  014A	7A 0A				MOV	R2,#0Ah
  229:	  014C	7B 2F		BIN2DEC1:	MOV	R3,#2Fh
  230:	  014E	0B		BIN2DEC2:	INC	R3
  231:	  014F	31 6E				ACALL	SUBIT
  232:	  0151	50 FB				JNC	BIN2DEC2
  233:	  0153	31 87				ACALL	ADDIT
  234:	  0155	EB				MOV	A,R3
  235:	  0156	F6				MOV	@R0,A
  236:	  0157	08				INC	R0
  237:	  0158	A3				INC	DPTR
  238:	  0159	A3				INC	DPTR
  239:	  015A	A3				INC	DPTR
  240:	  015B	A3				INC	DPTR
  241:	  015C	DA EE				DJNZ	R2,BIN2DEC1
  242:	  015E	D0 00				POP	00h
  243:						;Remove leading zeroes
  244:	  0160	7A 09				MOV	R2,#09h
  245:	  0162	E6		BIN2DEC3:	MOV	A,@R0
  246:	  0163	B4 30 05			CJNE	A,#30h,BIN2DEC4
  247:	  0166	76 20				MOV	@R0,#20h
  248:	  0168	08				INC	R0
  249:	  0169	DA F7				DJNZ	R2,BIN2DEC3
  250:	  016B	0A		BIN2DEC4:	INC	R2
  251:	  016C	EA				MOV	A,R2
  252:	  016D	22				RET
  253:
  254:	  016E	E4		SUBIT:		CLR	A
  255:	  016F	93				MOVC	A,@A+DPTR
  256:	  0170	CC				XCH	A,R4
  257:	  0171	C3				CLR	C
  258:	  0172	9C				SUBB	A,R4
  259:	  0173	FC				MOV	R4,A
  260:	  0174	74 01				MOV	A,#01h
  261:	  0176	93				MOVC	A,@A+DPTR
  262:	  0177	CD				XCH	A,R5
  263:	  0178	9D				SUBB	A,R5
  264:	  0179	FD				MOV	R5,A
  265:	  017A	74 02				MOV	A,#02h
  266:	  017C	93				MOVC	A,@A+DPTR
  267:	  017D	CE				XCH	A,R6

ASEM-51 V1.3                                         Copyright (c) 2002 by W.W. Heinz                                         PAGE 6



 Line  I  Addr  Code            Source

  268:	  017E	9E				SUBB	A,R6
  269:	  017F	FE				MOV	R6,A
  270:	  0180	74 03				MOV	A,#03h
  271:	  0182	93				MOVC	A,@A+DPTR
  272:	  0183	CF				XCH	A,R7
  273:	  0184	9F				SUBB	A,R7
  274:	  0185	FF				MOV	R7,A
  275:	  0186	22				RET
  276:
  277:	  0187	E4		ADDIT:		CLR	A
  278:	  0188	93				MOVC	A,@A+DPTR
  279:	  0189	2C				ADD	A,R4
  280:	  018A	FC				MOV	R4,A
  281:	  018B	74 01				MOV	A,#01h
  282:	  018D	93				MOVC	A,@A+DPTR
  283:	  018E	3D				ADDC	A,R5
  284:	  018F	FD				MOV	R5,A
  285:	  0190	74 02				MOV	A,#02h
  286:	  0192	93				MOVC	A,@A+DPTR
  287:	  0193	3E				ADDC	A,R6
  288:	  0194	FE				MOV	R6,A
  289:	  0195	74 03				MOV	A,#03h
  290:	  0197	93				MOVC	A,@A+DPTR
  291:	  0198	3F				ADDC	A,R7
  292:	  0199	FF				MOV	R7,A
  293:	  019A	22				RET
  294:
  295:	  019B	00 CA 9A 3B	BINDEC:		DB	000h,0CAh,09Ah,03Bh		;1000000000
  296:	  019F	00 E1 F5 05			DB	000h,0E1h,0F5h,005h		; 100000000
  297:	  01A3	80 96 98 00			DB	080h,096h,098h,000h		;  10000000
  298:	  01A7	40 42 0F 00			DB	040h,042h,0Fh,0000h		;   1000000
  299:	  01AB	A0 86 01 00			DB	0A0h,086h,001h,000h		;    100000
  300:	  01AF	10 27 00 00			DB	010h,027h,000h,000h		;     10000
  301:	  01B3	E8 03 00 00			DB	0E8h,003h,000h,000h		;      1000
  302:	  01B7	64 00 00 00			DB	064h,000h,000h,000h		;       100
  303:	  01BB	0A 00 00 00			DB	00Ah,000h,000h,000h		;        10
  304:	  01BF	01 00 00 00			DB	001h,000h,000h,000h		;         1
  305:
  306:	  01C3	7E 00 13 00	FP5MUL:		DB	7Eh,00h,13h,00h,21h,12h		;5.0/4095= 0.0012210012
	  01C7	21 12
  307:	  01C9	7E 00 59 80	FP24MUL:	DB	7Eh,00h,59h,80h,60h,58h		;24.0/4095=0.0058608059
	  01CD	60 58
  308:
  309:		N      1000			ORG	1000h
  310:
  311:				$include	(FP52INT.a51)
  312: 1			; This is a complete BCD floating point package for the 8051 micro-
  313: 1			; controller. It provides 8 digits of accuracy with exponents that
  314: 1			; range from +127 to -127. The mantissa is in packed BCD, while the
  315: 1			; exponent is expressed in pseudo-twos complement. A ZERO exponent
  316: 1			; is used to express the number ZERO. An exponent value of 80H or
  317: 1			; greater than means the exponent is positive, i.e. 80H = E 0,
  318: 1			; 81H = E+1, 82H = E+2 and so on. If the exponent is 7FH or less,
  319: 1			; the exponent is negative, 7FH = E-1, 7EH = E-2, and so on.
  320: 1			; ALL NUMBERS ARE ASSUMED TO BE NORMALIZED and all results are
  321: 1			; normalized after calculation. A normalized mantissa is >=.10 and

ASEM-51 V1.3                                         Copyright (c) 2002 by W.W. Heinz                                         PAGE 7



 Line  I  Addr  Code            Source

  322: 1			; <=.99999999.
  323: 1			;
  324: 1			; The numbers in memory assumed to be stored as follows:
  325: 1			;
  326: 1			; EXPONENT OF ARGUMENT 2   =   VALUE OF ARG_STACK+FP_NUMBER_SIZE
  327: 1			; SIGN OF ARGUMENT 2       =   VALUE OF ARG_STACK+FP_NUMBER_SIZE-1
  328: 1			; DIGIT 78 OF ARGUMENT 2   =   VALUE OF ARG_STACK+FP_NUMBER_SIZE-2
  329: 1			; DIGIT 56 OF ARGUMENT 2   =   VALUE OF ARG_STACK+FP_NUMBER_SIZE-3
  330: 1			; DIGIT 34 OF ARGUMENT 2   =   VALUE OF ARG_STACK+FP_NUMBER_SIZE-4
  331: 1			; DIGIT 12 OF ARGUMENT 2   =   VALUE OF ARG_STACK+FP_NUMBER_SIZE-5
  332: 1			;
  333: 1			; EXPONENT OF ARGUMENT 1   =   VALUE OF ARG_STACK
  334: 1			; SIGN OF ARGUMENT 1       =   VALUE OF ARG_STACK-1
  335: 1			; DIGIT 78 OF ARGUMENT 1   =   VALUE OF ARG_STACK-2
  336: 1			; DIGIT 56 OF ARGUMENT 1   =   VALUE OF ARG_STACK-3
  337: 1			; DIGIT 34 OF ARGUMENT 1   =   VALUE OF ARG_STACK-4
  338: 1			; DIGIT 12 OF ARGUMENT 1   =   VALUE OF ARG_STACK-5
  339: 1			;
  340: 1			; The operations are performed thusly:
  341: 1			;
  342: 1			; ARG_STACK+FP_NUMBER_SIZE = ARG_STACK+FP_NUMBER_SIZE # ARG_STACK
  343: 1			;
  344: 1			; Which is ARGUMENT 2 = ARGUMENT 2 # ARGUMENT 1
  345: 1			;
  346: 1			; Where # can be ADD, SUBTRACT, MULTIPLY OR DIVIDE.
  347: 1			;
  348: 1			; Note that the stack gets popped after an operation.
  349: 1			;
  350: 1			; The FP_COMP instruction POPS the ARG_STACK TWICE and returns status.
  351: 1			;
  352: 1			;**********************************************************************
  353: 1			;
  354: 1			;**********************************************************************
  355: 1			;
  356: 1			; STATUS ON RETURN - After performing an operation (+, -, *, /)
  357: 1			;                    the accumulator contains the following status
  358: 1			;
  359: 1			; ACCUMULATOR - BIT 0 - FLOATING POINT UNDERFLOW OCCURED
  360: 1			;
  361: 1			;             - BIT 1 - FLOATING POINT OVERFLOW OCCURED
  362: 1			;
  363: 1			;             - BIT 2 - RESULT WAS ZER0
  364: 1			;
  365: 1			;             - BIT 3 - DIVIDE BY ZERO ATTEMPTED
  366: 1			;
  367: 1			;             - BIT 4 - NOT USED, 0 RETURNED
  368: 1			;
  369: 1			;             - BIT 5 - NOT USED, 0 RETURNED
  370: 1			;
  371: 1			;             - BIT 6 - NOT USED, 0 RETURNED
  372: 1			;
  373: 1			;             - BIT 7 - NOT USED, 0 RETURNED
  374: 1			;
  375: 1			; NOTE: When underflow occures, a ZERO result is returned.
  376: 1			;       When overflow or divide by zero occures, a result of
  377: 1			;       .99999999 E+127 is returned and it is up to the user

ASEM-51 V1.3                                         Copyright (c) 2002 by W.W. Heinz                                         PAGE 8



 Line  I  Addr  Code            Source

  378: 1			;       to handle these conditions as needed in the program.
  379: 1			;
  380: 1			; NOTE: The Compare instruction returns F0 = 0 if ARG 1 = ARG 2
  381: 1			;       and returns a CARRY FLAG = 1 if ARG 1 is > ARG 2
  382: 1			;
  383: 1			;***********************************************************************
  384: 1			;
  385: 1
  386: 1			;$NOTABS                  ;expand tabs
  387: 1
  388: 1
  389: 1			CMP MACRO REGISTER,CONSTANT
  390: 1			CJNE	REGISTER,CONSTANT,$+3
  391: 1			ENDM
  392: 1			;***********************************************************************
  393: 1			;
  394: 1			; The following values MUST be provided by the user
  395: 1			;
  396: 1			;***********************************************************************
  397: 1			;
  398: 1			;
  399: 1			;***********************************************************************
  400: 1			;
  401: 1			; The following equates are used internally
  402: 1			;
  403: 1			;***********************************************************************
  404: 1			;
  405: 1	N      0006	FP_NUMBER_SIZE		EQU	6
  406: 1	N      0004	DIGIT			EQU	4
  407: 1	N      0000	R0B0			EQU	0
  408: 1	N      0001	R1B0			EQU	1
  409: 1	N      0000	UNDERFLOW		EQU	0
  410: 1	N      0001	OVERFLOW		EQU	1
  411: 1	N      0002	ZERO			EQU	2
  412: 1	N      0003	ZERO_DIVIDE		EQU	3
  413: 1			;
  414: 1			;***********************************************************************
  415: 1				;**************************************************************
  416: 1				;
  417: 1				; The following internal locations are used by the math pack
  418: 1				; ordering is important and the FP_DIGITS must be bit
  419: 1				; addressable
  420: 1				;
  421: 1				;***************************************************************
  422: 1				;
  423: 1	N      0025	FP_TEMP			EQU	FP_STATUS+1			;29 NOT USED
  424: 1	N      0026	FP_CARRY		EQU	FP_STATUS+2			;2A USED FOR BITS
  425: 1	N      0027	FP_DIG12		EQU	FP_CARRY+1			;2B
  426: 1	N      0028	FP_DIG34		EQU	FP_CARRY+2			;2C
  427: 1	N      0029	FP_DIG56		EQU	FP_CARRY+3			;2D
  428: 1	N      002A	FP_DIG78		EQU	FP_CARRY+4			;2E
  429: 1	N      002B	FP_SIGN			EQU	FP_CARRY+5			;2F
  430: 1	N      002C	FP_EXP			EQU	FP_CARRY+6			;30
  431: 1	B	 58	MSIGN			BIT	FP_SIGN.0			;2F.0
  432: 1	B	 30	XSIGN			BIT	FP_CARRY.0			;2A.0
  433: 1	B	 31	FOUND_RADIX		BIT	FP_CARRY.1			;2A.1

ASEM-51 V1.3                                         Copyright (c) 2002 by W.W. Heinz                                         PAGE 9



 Line  I  Addr  Code            Source

  434: 1	B	 32	FIRST_RADIX		BIT	FP_CARRY.2			;2A.2
  435: 1	B	 33	DONE_LOAD		BIT	FP_CARRY.3			;2A.3
  436: 1	N      0027	FP_NIB1			EQU	FP_DIG12			;2B
  437: 1	N      0028	FP_NIB2			EQU	FP_NIB1+1			;2C
  438: 1	N      0029	FP_NIB3			EQU	FP_NIB1+2			;2D
  439: 1	N      002A	FP_NIB4			EQU	FP_NIB1+3			;2E
  440: 1	N      002B	FP_NIB5			EQU	FP_NIB1+4			;2F
  441: 1	N      002C	FP_NIB6			EQU	FP_NIB1+5			;30
  442: 1	N      002D	FP_NIB7			EQU	FP_NIB1+6			;31
  443: 1	N      002E	FP_NIB8			EQU	FP_NIB1+7			;32
  444: 1	N      002F	FP_ACCX			EQU	FP_NIB1+8			;33
  445: 1	N      0030	FP_ACCC			EQU	FP_NIB1+9			;34
  446: 1	N      0031	FP_ACC1			EQU	FP_NIB1+10			;35
  447: 1	N      0032	FP_ACC2			EQU	FP_NIB1+11			;36
  448: 1	N      0033	FP_ACC3			EQU	FP_NIB1+12			;37
  449: 1	N      0034	FP_ACC4			EQU	FP_NIB1+13			;38
  450: 1	N      0035	FP_ACC5			EQU	FP_NIB1+14			;39
  451: 1	N      0036	FP_ACC6			EQU	FP_NIB1+15			;3A
  452: 1	N      0037	FP_ACC7			EQU	FP_NIB1+16			;3B
  453: 1	N      0038	FP_ACC8			EQU	FP_NIB1+17			;3C
  454: 1	N      0039	FP_ACCS			EQU	FP_NIB1+18			;3D
  455: 1
  456: 1
  457: 1  1000	22		PRTERR:			RET
  458: 1  1001	22		BADPRM:			RET
  459: 1
  460: 1				;
  461: 1				;
  462: 1  1002			FLOATING_SUB:
  463: 1				;
  464: 1  1002	A8 22					MOV	R0,ARG_STACK
  465: 1  1004	18					DEC	R0				;POINT TO SIGN
  466: 1  1005	E6					MOV	A,@R0				;READ SIGN
  467: 1  1006	B2 E0					CPL	ACC.0
  468: 1  1008	F6					MOV	@R0,A
  469: 1				;
  470: 1				;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
  471: 1				;
  472: 1  1009			FLOATING_ADD:
  473: 1				;
  474: 1				;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
  475: 1				;
  476: 1				;
  477: 1  1009	51 C7					ACALL 	MDES1				;R7=TOS EXP, R6=TOS-1 EXP, R4=TOS SI
       1			GN
  478: 1											;R3=TOS-1 SIGN, OPERATION IS R1 # R0
  479: 1				;
  480: 1  100B	EF					MOV	A,R7				;GET TOS EXPONENT
  481: 1  100C	60 0D					JZ	POP_AND_EXIT			;IF TOS=0 THEN POP AND EXIT
  482: 1  100E	BE 00 12				CJNE	R6,#0,LOAD1			;CLEAR CARRY EXIT IF ZERO
  483: 1				;
  484: 1				;**************************************************************
  485: 1				;
  486: 1  1011			SWAP_AND_EXIT:							; Swap external args and return
  487: 1				;
  488: 1				;**************************************************************

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 10



 Line  I  Addr  Code            Source

  489: 1				;
  490: 1  1011	51 BE					ACALL	LOAD_POINTERS
  491: 1  1013	7F 06					MOV	R7,#FP_NUMBER_SIZE
  492: 1				;
  493: 1  1015	E6		SE1:			MOV	A,@R0				;SWAP THE ARGUMENTS
  494: 1  1016	F7					MOV	@R1,A
  495: 1  1017	18					DEC	R0
  496: 1  1018	19					DEC	R1
  497: 1  1019	DF FA					DJNZ	R7,SE1
  498: 1				;
  499: 1  101B			POP_AND_EXIT:
  500: 1				;
  501: 1  101B	E5 22					MOV	A,ARG_STACK			;POP THE STACK
  502: 1  101D	24 06					ADD	A,#FP_NUMBER_SIZE
  503: 1  101F	F5 22					MOV	ARG_STACK,A
  504: 1  1021	E4					CLR	A
  505: 1  1022	22					RET
  506: 1				;
  507: 1				;
  508: 1  1023	9E		LOAD1:			SUBB	A,R6				;A = ARG 1 EXP - ARG 2 EXP
  509: 1  1024	8F 2C					MOV	FP_EXP,R7			;SAVE EXPONENT AND SIGN
  510: 1  1026	8C 2B					MOV	FP_SIGN,R4
  511: 1  1028	50 09					JNC	LOAD2				;ARG1 EXPONENT IS LARGER OR SAME
  512: 1  102A	8E 2C					MOV	FP_EXP,R6
  513: 1  102C	8B 2B					MOV	FP_SIGN,R3
  514: 1  102E	F4					CPL	A
  515: 1  102F	04					INC	A				;COMPENSATE FOR EXP DELTA
  516: 1  1030	C8					XCH	A,R0				;FORCE R0 TO POINT AT THE LARGEST
  517: 1  1031	C9					XCH	A,R1				;EXPONENT
  518: 1  1032	C8					XCH	A,R0
  519: 1				;
  520: 1  1033	FF		LOAD2:			MOV	R7,A				;SAVE THE EXPONENT DELTA IN R7
  521: 1  1034	C2 0B					CLR	ADD_IN
  522: 1  1036	BD 00 02				CJNE	R5,#0,LOAD3
  523: 1  1039	D2 0B					SETB	ADD_IN
  524: 1				;
  525: 1				; Load the R1 mantissa
  526: 1				;
  527: 1  103B	51 D8		LOAD3:			ACALL	LOADR1_MANTISSA			;LOAD THE SMALLEST NUMBER
  528: 1				;
  529: 1				; Now align the number to the delta exponent
  530: 1				; R4 points to the string of the last digits lost
  531: 1				;
  532: 1						CMP	R7,#DIGIT+DIGIT+3
  533+ 2  103D	BF 0B 00	CJNE	R7,#DIGIT+DIGIT+3,$+3
  534: 1  1040	40 02					JC	LOAD4
  535: 1  1042	7F 0A					MOV	R7,#DIGIT+DIGIT+2
  536: 1				;
  537: 1  1044	75 26 00	LOAD4:			MOV	FP_CARRY,#00			;CLEAR THE CARRY
  538: 1  1047	51 1B					ACALL	RIGHT				;SHIFT THE NUMBER
  539: 1				;
  540: 1				; Set up for addition and subtraction
  541: 1				;
  542: 1  1049	7F 04					MOV	R7,#DIGIT			;LOOP COUNT
  543: 1  104B	79 2A					MOV	R1,#FP_DIG78
  544: 1  104D	74 9E					MOV	A,#9EH

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 11



 Line  I  Addr  Code            Source

  545: 1  104F	C3					CLR	C
  546: 1  1050	9C					SUBB	A,R4
  547: 1  1051	D4					DA	A
  548: 1  1052	CC					XCH	A,R4
  549: 1  1053	70 01					JNZ	LOAD5
  550: 1  1055	FC					MOV	R4,A
  551: 1  1056			LOAD5:			CMP	A,#50H				;TEST FOR SUBTRACTION
  552+ 2  1056	B4 50 00	CJNE	A,#50H,$+3
  553: 1  1059	30 0B 18				JNB	ADD_IN,SUBLP			;DO SUBTRACTION IF NO ADD_IN
  554: 1  105C	B3					CPL	C				;FLIP CARRY FOR ADDITION
  555: 1  105D	11 6B					ACALL	ADDLP				;DO ADDITION
  556: 1				;
  557: 1  105F	50 08					JNC	ADD_R
  558: 1  1061	05 26					INC	FP_CARRY
  559: 1  1063	7F 01					MOV	R7,#1
  560: 1  1065	51 1B					ACALL	RIGHT
  561: 1  1067	31 D2					ACALL	INC_FP_EXP			;SHIFT AND BUMP EXPONENT
  562: 1				;
  563: 1  1069	21 C3		ADD_R:			AJMP	STORE_ALIGN_TEST_AND_EXIT
  564: 1				;
  565: 1  106B	E6		ADDLP:			MOV	A,@R0
  566: 1  106C	37					ADDC	A,@R1
  567: 1  106D	D4					DA	A
  568: 1  106E	F7					MOV	@R1,A
  569: 1  106F	18					DEC	R0
  570: 1  1070	19					DEC	R1
  571: 1  1071	DF F8					DJNZ	R7,ADDLP			;LOOP UNTIL DONE
  572: 1  1073	22					RET
  573: 1				;
  574: 1				;
  575: 1  1074	E6		SUBLP:			MOV	A,@R0				;NOW DO SUBTRACTION
  576: 1  1075	FE					MOV	R6,A
  577: 1  1076	E4					CLR	A
  578: 1  1077	34 99					ADDC	A,#99H
  579: 1  1079	97					SUBB	A,@R1
  580: 1  107A	2E					ADD	A,R6
  581: 1  107B	D4					DA	A
  582: 1  107C	F7					MOV	@R1,A
  583: 1  107D	18					DEC	R0
  584: 1  107E	19					DEC	R1
  585: 1  107F	DF F3					DJNZ	R7,SUBLP
  586: 1  1081	40 11					JC	FSUB6
  587: 1				;
  588: 1				;
  589: 1				; Need to complement the result and sign because the floating
  590: 1				; point accumulator mantissa was larger than the external
  591: 1				; memory and their signs were equal.
  592: 1				;
  593: 1  1083	B2 58					CPL	FP_SIGN.0
  594: 1  1085	79 2A					MOV	R1,#FP_DIG78
  595: 1  1087	7F 04					MOV	R7,#DIGIT			;LOOP COUNT
  596: 1				;
  597: 1  1089	74 9A		FSUB5:			MOV	A,#9AH
  598: 1  108B	97					SUBB	A,@R1
  599: 1  108C	24 00					ADD	A,#0
  600: 1  108E	D4					DA	A

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 12



 Line  I  Addr  Code            Source

  601: 1  108F	F7					MOV	@R1,A
  602: 1  1090	19					DEC	R1
  603: 1  1091	B3					CPL	C
  604: 1  1092	DF F5					DJNZ	R7,FSUB5			;LOOP
  605: 1				;
  606: 1				; Now see how many zeros their are
  607: 1				;
  608: 1  1094	78 27		FSUB6:			MOV	R0,#FP_DIG12
  609: 1  1096	7F 00					MOV	R7,#0
  610: 1				;
  611: 1  1098	E6		FSUB7:			MOV	A,@R0
  612: 1  1099	70 08					JNZ	FSUB8
  613: 1  109B	0F					INC	R7
  614: 1  109C	0F					INC	R7
  615: 1  109D	08					INC	R0
  616: 1  109E	B8 2B F7				CJNE	R0,#FP_SIGN,FSUB7
  617: 1  10A1	41 0B					AJMP	ZERO_AND_EXIT
  618: 1				;
  619: 1  10A3			FSUB8:			CMP	A,#10H
  620+ 2  10A3	B4 10 00	CJNE	A,#10H,$+3
  621: 1  10A6	50 01					JNC	FSUB9
  622: 1  10A8	0F					INC	R7
  623: 1				;
  624: 1				; Now R7 has the number of leading zeros in the FP ACC
  625: 1				;
  626: 1  10A9	E5 2C		FSUB9:			MOV	A,FP_EXP			;GET THE OLD EXPONENT
  627: 1  10AB	C3					CLR	C
  628: 1  10AC	9F					SUBB	A,R7				;SUBTRACT FROM THE NUMBER OF ZEROS
  629: 1  10AD	60 0B					JZ	FSUB10
  630: 1  10AF	40 09					JC	FSUB10
  631: 1				;
  632: 1  10B1	F5 2C					MOV	FP_EXP,A			;SAVE THE NEW EXPONENT
  633: 1				;
  634: 1  10B3	51 55					ACALL	LEFT1				;SHIFT THE FP ACC
  635: 1  10B5	75 26 00				MOV	FP_CARRY,#0
  636: 1  10B8	21 C3					AJMP	STORE_ALIGN_TEST_AND_EXIT
  637: 1				;
  638: 1  10BA	41 05		FSUB10:			AJMP	UNDERFLOW_AND_EXIT
  639: 1				;
  640: 1				;***************************************************************
  641: 1				;
  642: 1  10BC			FLOATING_COMP:	; Compare two floating point numbers
  643: 1					; used for relational operations and is faster
  644: 1					; than subtraction. ON RETURN, The carry is set
  645: 1					; if ARG1 is > ARG2, else carry is not set
  646: 1					; if ARG1 = ARG2, F0 gets set
  647: 1				;
  648: 1				;***************************************************************
  649: 1				;
  650: 1  10BC	51 C7					ACALL	MDES1				;SET UP THE REGISTERS
  651: 1  10BE	E5 22					MOV	A,ARG_STACK
  652: 1  10C0	24 0C					ADD	A,#FP_NUMBER_SIZE+FP_NUMBER_SIZE
  653: 1  10C2	F5 22					MOV	ARG_STACK,A			;POP THE STACK TWICE, CLEAR THE CARR
       1			Y
  654: 1  10C4	EE					MOV	A,R6				;CHECK OUT EXPONENTS
  655: 1  10C5	C2 D5					CLR	F0

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 13



 Line  I  Addr  Code            Source

  656: 1  10C7	C3		        		CLR     C
  657: 1  10C8	9F					SUBB	A,R7
  658: 1  10C9	60 0A					JZ	EXPONENTS_EQUAL
  659: 1  10CB	40 03					JC	ARG1_EXP_IS_LARGER
  660: 1				;
  661: 1				; Now the ARG2 EXPONENT is > ARG1 EXPONENT
  662: 1				;
  663: 1  10CD			SIGNS_DIFFERENT:
  664: 1				;
  665: 1  10CD	EB					MOV	A,R3				;SEE IF SIGN OF ARG2 IS POSITIVE
  666: 1  10CE	80 01					SJMP	ARG1_EXP_IS_LARGER1
  667: 1				;
  668: 1  10D0			ARG1_EXP_IS_LARGER:
  669: 1				;
  670: 1  10D0	EC					MOV	A,R4				;GET THE SIGN OF ARG1 EXPONENT
  671: 1  10D1	60 01		ARG1_EXP_IS_LARGER1:	JZ	ARG1_EXP_IS_LARGER2
  672: 1  10D3	B3					CPL	C
  673: 1  10D4	22		ARG1_EXP_IS_LARGER2:	RET
  674: 1				;
  675: 1  10D5			EXPONENTS_EQUAL:
  676: 1				;
  677: 1				; First, test the sign, then the mantissa
  678: 1				;
  679: 1  10D5	BD 00 F5				CJNE	R5,#0,SIGNS_DIFFERENT
  680: 1				;
  681: 1  10D8			BOTH_PLUS:
  682: 1				;
  683: 1  10D8	7F 04					MOV	R7,#DIGIT			;POINT AT MS DIGIT
  684: 1  10DA	18					DEC	R0
  685: 1  10DB	18					DEC	R0
  686: 1  10DC	18					DEC	R0
  687: 1  10DD	19					DEC	R1
  688: 1  10DE	19					DEC	R1
  689: 1  10DF	19					DEC	R1
  690: 1				;
  691: 1				; Now do the compare
  692: 1				;
  693: 1  10E0	E6		CLOOP:			MOV	A,@R0
  694: 1  10E1	FE					MOV	R6,A
  695: 1  10E2	E7					MOV	A,@R1
  696: 1  10E3	9E					SUBB	A,R6
  697: 1  10E4	70 EA					JNZ	ARG1_EXP_IS_LARGER
  698: 1  10E6	08					INC	R0
  699: 1  10E7	09					INC	R1
  700: 1  10E8	DF F6					DJNZ	R7,CLOOP
  701: 1				;
  702: 1				; If here, the numbers are the same, the carry is cleared
  703: 1				;
  704: 1  10EA	D2 D5					SETB	F0
  705: 1  10EC	22					RET					;EXIT WITH EQUAL
  706: 1				;
  707: 1			;MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
  708: 1			;
  709: 1  10ED			FLOATING_MUL:							; Floating point multiply
  710: 1			;
  711: 1			;MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 14



 Line  I  Addr  Code            Source

  712: 1			;
  713: 1  10ED	51 C5					ACALL	MUL_DIV_EXP_AND_SIGN
  714: 1				;
  715: 1				; check for zero exponents
  716: 1				;
  717: 1  10EF	BE 00 02				CJNE	R6,#00,FMUL1			;ARG 2 EXP ZERO?
  718: 1  10F2	41 0B		FMUL0:			AJMP	ZERO_AND_EXIT
  719: 1				;
  720: 1				; calculate the exponent
  721: 1				;
  722: 1  10F4	8D 2B		FMUL1:			MOV	FP_SIGN,R5			;SAVE THE SIGN, IN CASE OF FAILURE
  723: 1				;
  724: 1  10F6	EF					MOV	A,R7
  725: 1  10F7	60 F9					JZ	FMUL0
  726: 1  10F9	2E					ADD	A,R6				;ADD THE EXPONENTS
  727: 1  10FA	20 E7 05				JB	ACC.7,FMUL_OVER
  728: 1  10FD	10 D7 06				JBC	CY,FMUL2			;SEE IF CARRY IS SET
  729: 1				;
  730: 1  1100	41 05					AJMP	UNDERFLOW_AND_EXIT
  731: 1				;
  732: 1  1102			FMUL_OVER:
  733: 1				;
  734: 1  1102	50 02					JNC	FMUL2				;OK IF SET
  735: 1				;
  736: 1  1104	21 F4		FOV:			AJMP	OVERFLOW_AND_EXIT
  737: 1				;
  738: 1  1106	94 81		FMUL2:			SUBB	A,#129				;SUBTRACT THE EXPONENT BIAS
  739: 1  1108	FE					MOV	R6,A				;SAVE IT FOR LATER
  740: 1				;
  741: 1				; Unpack and load R0
  742: 1				;
  743: 1  1109	31 DE					ACALL	UNPACK_R0
  744: 1				;
  745: 1				; Now set up for loop multiply
  746: 1				;
  747: 1  110B	7B 04					MOV	R3,#DIGIT
  748: 1  110D	AC 01					MOV	R4,R1B0
  749: 1				;
  750: 1				;
  751: 1				; Now, do the multiply and accumulate the product
  752: 1				;
  753: 1  110F	8C 01		FMUL3:			MOV	R1B0,R4
  754: 1  1111	E7					MOV	A,@R1
  755: 1  1112	FA					MOV	R2,A
  756: 1  1113	51 8B					ACALL	MUL_NIBBLE
  757: 1				;
  758: 1  1115	EA					MOV	A,R2
  759: 1  1116	C4					SWAP	A
  760: 1  1117	51 8B					ACALL	MUL_NIBBLE
  761: 1  1119	1C					DEC	R4
  762: 1  111A	DB F3					DJNZ	R3,FMUL3
  763: 1				;
  764: 1				; Now, pack and restore the sign
  765: 1				;
  766: 1  111C	8E 2C					MOV	FP_EXP,R6
  767: 1  111E	8D 2B					MOV	FP_SIGN,R5

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 15



 Line  I  Addr  Code            Source

  768: 1  1120	21 83					AJMP	PACK				;FINISH IT OFF
  769: 1				;
  770: 1				;DDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDD
  771: 1				;
  772: 1  1122			FLOATING_DIV:
  773: 1				;
  774: 1				;DDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDD
  775: 1				;
  776: 1  1122	51 C7					ACALL	MDES1
  777: 1				;
  778: 1				; Check the exponents
  779: 1				;
  780: 1  1124	8D 2B					MOV	FP_SIGN,R5			;SAVE THE SIGN
  781: 1  1126	BF 00 06				CJNE	R7,#0,DIV0			;CLEARS THE CARRY
  782: 1  1129	31 F4					ACALL	OVERFLOW_AND_EXIT
  783: 1  112B	E4					CLR	A
  784: 1  112C	D2 E3					SETB	ACC.ZERO_DIVIDE
  785: 1  112E	22					RET
  786: 1				;
  787: 1  112F	EE		DIV0:			MOV	A,R6				;GET EXPONENT
  788: 1  1130	60 C0					JZ	FMUL1-2				;EXIT IF ZERO
  789: 1  1132	9F					SUBB	A,R7				;DELTA EXPONENT
  790: 1  1133	20 E7 04				JB	ACC.7,D_UNDER
  791: 1  1136	50 04					JNC	DIV3
  792: 1  1138	41 05					AJMP	UNDERFLOW_AND_EXIT
  793: 1				;
  794: 1  113A	50 C8		D_UNDER:		JNC	FOV
  795: 1				;
  796: 1  113C	24 81		DIV3:			ADD	A,#129				;CORRECTLY BIAS THE EXPONENT
  797: 1  113E	F5 2C					MOV	FP_EXP,A			;SAVE THE EXPONENT
  798: 1  1140	51 D8					ACALL	LOADR1_MANTISSA			;LOAD THE DIVIDED
  799: 1				;
  800: 1  1142	7A 30					MOV	R2,#FP_ACCC			;SAVE LOCATION
  801: 1  1144	AB 00					MOV	R3,R0B0				;SAVE POINTER IN R3
  802: 1  1146	75 26 00				MOV	FP_CARRY,#0			;ZERO CARRY BYTE
  803: 1				;
  804: 1  1149	7D FF		DIV4:			MOV	R5,#0FFH			;LOOP COUNT
  805: 1  114B	D3					SETB	C
  806: 1				;
  807: 1  114C	8B 00		DIV5:			MOV	R0B0,R3				;RESTORE THE EXTERNAL POINTER
  808: 1  114E	79 2A					MOV	R1,#FP_DIG78			;SET UP INTERNAL POINTER
  809: 1  1150	7F 04					MOV	R7,#DIGIT			;LOOP COUNT
  810: 1  1152	50 17					JNC	DIV7				;EXIT IF NO CARRY
  811: 1				;
  812: 1  1154	E6		DIV6:			MOV	A,@R0				;DO ACCUMLATION
  813: 1  1155	FE					MOV	R6,A
  814: 1  1156	E4					CLR	A
  815: 1  1157	34 99					ADDC	A,#99H
  816: 1  1159	9E					SUBB	A,R6
  817: 1  115A	27					ADD	A,@R1
  818: 1  115B	D4					DA	A
  819: 1  115C	F7					MOV	@R1,A
  820: 1  115D	18					DEC	R0
  821: 1  115E	19					DEC	R1
  822: 1  115F	DF F3					DJNZ	R7,DIV6				;LOOP
  823: 1				;

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 16



 Line  I  Addr  Code            Source

  824: 1  1161	0D					INC	R5				;SUBTRACT COUNTER
  825: 1  1162	40 E8					JC	DIV5				;KEEP LOOPING IF CARRY
  826: 1  1164	E7					MOV	A,@R1				;GET CARRY
  827: 1  1165	94 01					SUBB	A,#1				;CARRY IS CLEARED
  828: 1  1167	F7					MOV	@R1,A				;SAVE CARRY DIGIT
  829: 1  1168	B3					CPL	C
  830: 1  1169	80 E1					SJMP	DIV5				;LOOP
  831: 1				;
  832: 1				; Restore the result if carry was found
  833: 1				;
  834: 1  116B	11 6B		DIV7:			ACALL	ADDLP				;ADD NUMBER BACK
  835: 1  116D	77 00					MOV	@R1,#0				;CLEAR CARRY
  836: 1  116F	8A 00					MOV	R0B0,R2				;GET SAVE COUNTER
  837: 1  1171	A6 05					MOV	@R0,5				;SAVE COUNT BYTE
  838: 1				;
  839: 1  1173	0A					INC	R2				;ADJUST SAVE COUNTER
  840: 1  1174	7F 01					MOV	R7,#1				;BUMP DIVIDEND
  841: 1  1176	51 53					ACALL	LEFT
  842: 1  1178	BA 3A CE				CJNE	R2,#FP_ACC8+2,DIV4
  843: 1				;
  844: 1  117B	D5 2C 02				DJNZ	FP_EXP,DIV8
  845: 1  117E	41 05					AJMP	UNDERFLOW_AND_EXIT
  846: 1				;
  847: 1  1180	75 26 00	DIV8:			MOV	FP_CARRY,#0
  848: 1				;
  849: 1				;***************************************************************
  850: 1				;
  851: 1  1183			PACK:	; Pack the mantissa
  852: 1				;
  853: 1				;***************************************************************
  854: 1				;
  855: 1				; First, set up the pointers
  856: 1				;
  857: 1  1183	78 30					MOV	R0,#FP_ACCC
  858: 1  1185	E6					MOV	A,@R0				;GET FP_ACCC
  859: 1  1186	FE					MOV	R6,A				;SAVE FOR ZERO COUNT
  860: 1  1187	60 03					JZ	PACK0				;JUMP OVER IF ZERO
  861: 1  1189	31 D2					ACALL	INC_FP_EXP			;BUMP THE EXPONENT
  862: 1  118B	18					DEC	R0
  863: 1				;
  864: 1  118C	08		PACK0:			INC	R0				;POINT AT FP_ACC1
  865: 1				;
  866: 1  118D	74 08		PACK1:			MOV	A,#8				;ADJUST NIBBLE POINTER
  867: 1  118F	F9					MOV	R1,A
  868: 1  1190	28					ADD	A,R0
  869: 1  1191	F8					MOV	R0,A
  870: 1						CMP	@R0,#5				;SEE IF ADJUSTING NEEDED
  871+ 2  1192	B6 05 00	CJNE	@R0,#5,$+3
  872: 1  1195	40 13					JC	PACK3+1
  873: 1				;
  874: 1  1197	D3		PACK2:			SETB	C
  875: 1  1198	E4					CLR	A
  876: 1  1199	18					DEC	R0
  877: 1  119A	36					ADDC	A,@R0
  878: 1  119B	D4					DA	A
  879: 1  119C	D6					XCHD	A,@R0				;SAVE THE VALUE

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 17



 Line  I  Addr  Code            Source

  880: 1  119D	30 E4 09				JNB	ACC.4,PACK3
  881: 1  11A0	D9 F5					DJNZ	R1,PACK2
  882: 1				;
  883: 1  11A2	18					DEC	R0
  884: 1  11A3	76 01					MOV	@R0,#1
  885: 1  11A5	31 D2					ACALL	INC_FP_EXP
  886: 1  11A7	80 06					SJMP	PACK4
  887: 1				;
  888: 1  11A9	19		PACK3:			DEC	R1
  889: 1  11AA	E9					MOV	A,R1
  890: 1  11AB	C3					CLR	C
  891: 1  11AC	C8					XCH	A,R0
  892: 1  11AD	98					SUBB	A,R0
  893: 1  11AE	F8					MOV	R0,A
  894: 1				;
  895: 1  11AF	79 27		PACK4:			MOV	R1,#FP_DIG12
  896: 1				;
  897: 1				; Now, pack
  898: 1				;
  899: 1  11B1	E6		PLOOP:			MOV	A,@R0
  900: 1  11B2	C4					SWAP	A				;FLIP THE DIGITS
  901: 1  11B3	08					INC	R0
  902: 1  11B4	D6					XCHD	A,@R0
  903: 1  11B5	42 06					ORL	6,A				;ACCUMULATE THE OR'ED DIGITS
  904: 1  11B7	F7					MOV	@R1,A
  905: 1  11B8	08					INC	R0
  906: 1  11B9	09					INC	R1
  907: 1  11BA	B9 2B F4				CJNE	R1,#FP_SIGN,PLOOP
  908: 1  11BD	EE					MOV	A,R6
  909: 1  11BE	70 03					JNZ	STORE_ALIGN_TEST_AND_EXIT
  910: 1  11C0	75 2C 00				MOV	FP_EXP,#0			;ZERO EXPONENT
  911: 1				;
  912: 1				;**************************************************************
  913: 1				;
  914: 1  11C3			STORE_ALIGN_TEST_AND_EXIT:					;Save the number align carry and exi
       1			t
  915: 1				;
  916: 1				;**************************************************************
  917: 1				;
  918: 1  11C3	51 BE					ACALL	LOAD_POINTERS
  919: 1  11C5	89 22					MOV	ARG_STACK,R1			;SET UP THE NEW STACK
  920: 1  11C7	78 2C					MOV	R0,#FP_EXP
  921: 1				;
  922: 1				; Now load the numbers
  923: 1				;
  924: 1  11C9	E6		STORE2:			MOV	A,@R0
  925: 1  11CA	F7					MOV	@R1,A				;SAVE THE NUMBER
  926: 1  11CB	18					DEC	R0
  927: 1  11CC	19					DEC	R1
  928: 1  11CD	B8 26 F9				CJNE	R0,#FP_CARRY,STORE2
  929: 1				;
  930: 1  11D0	E4					CLR	A				;NO ERRORS
  931: 1				;
  932: 1  11D1	22		PRET:			RET					;EXIT
  933: 1				;
  934: 1  11D2			INC_FP_EXP:

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 18



 Line  I  Addr  Code            Source

  935: 1				;
  936: 1  11D2	05 2C					INC	FP_EXP
  937: 1  11D4	E5 2C					MOV	A,FP_EXP
  938: 1  11D6	70 F9					JNZ	PRET				;EXIT IF NOT ZERO
  939: 1  11D8	D0 E0					POP	ACC				;WASTE THE CALLING STACK
  940: 1  11DA	D0 E0					POP	ACC
  941: 1  11DC	21 F4					AJMP	OVERFLOW_AND_EXIT
  942: 1				;
  943: 1			;***********************************************************************
  944: 1			;
  945: 1  11DE			UNPACK_R0:	; Unpack BCD digits and load into nibble locations
  946: 1			;
  947: 1			;***********************************************************************
  948: 1				;
  949: 1  11DE	C0 01					PUSH	R1B0
  950: 1  11E0	79 2E					MOV	R1,#FP_NIB8
  951: 1				;
  952: 1  11E2	E6		ULOOP:			MOV	A,@R0
  953: 1  11E3	54 0F					ANL	A,#0FH
  954: 1  11E5	F7					MOV	@R1,A				;SAVE THE NIBBLE
  955: 1  11E6	E6					MOV	A,@R0
  956: 1  11E7	C4					SWAP	A
  957: 1  11E8	54 0F					ANL	A,#0FH
  958: 1  11EA	19					DEC	R1
  959: 1  11EB	F7					MOV	@R1,A				;SAVE THE NIBBLE AGAIN
  960: 1  11EC	18					DEC	R0
  961: 1  11ED	19					DEC	R1
  962: 1  11EE	B9 26 F1				CJNE	R1,#FP_NIB1-1,ULOOP
  963: 1				;
  964: 1  11F1	D0 01					POP	R1B0
  965: 1				;
  966: 1  11F3	22		LOAD7:			RET
  967: 1				;
  968: 1				;**************************************************************
  969: 1				;
  970: 1  11F4			OVERFLOW_AND_EXIT:	;LOAD 99999999 E+127,  SET OV BIT, AND EXIT
  971: 1				;
  972: 1				;**************************************************************
  973: 1				;
  974: 1  11F4	78 2A					MOV	R0,#FP_DIG78
  975: 1  11F6	74 99					MOV	A,#99H
  976: 1				;
  977: 1  11F8	F6		OVE1:			MOV	@R0,A
  978: 1  11F9	18					DEC	R0
  979: 1  11FA	B8 26 FB				CJNE	R0,#FP_CARRY,OVE1
  980: 1				;
  981: 1  11FD	75 2C FF				MOV	FP_EXP,#0FFH
  982: 1  1200	31 C3					ACALL	STORE_ALIGN_TEST_AND_EXIT
  983: 1				;
  984: 1  1202	D2 E1					SETB	ACC.OVERFLOW
  985: 1  1204	22					RET
  986: 1				;
  987: 1				;**************************************************************
  988: 1				;
  989: 1  1205			UNDERFLOW_AND_EXIT:	;LOAD 0, SET UF BIT, AND EXIT
  990: 1				;

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 19



 Line  I  Addr  Code            Source

  991: 1				;**************************************************************
  992: 1				;
  993: 1  1205	51 0B					ACALL	ZERO_AND_EXIT
  994: 1  1207	E4					CLR		A
  995: 1  1208	D2 E0					SETB	ACC.UNDERFLOW
  996: 1  120A	22					RET
  997: 1				;
  998: 1				;**************************************************************
  999: 1				;
 1000: 1  120B			ZERO_AND_EXIT:		;LOAD 0, SET ZERO BIT, AND EXIT
 1001: 1				;
 1002: 1				;**************************************************************
 1003: 1				;
 1004: 1  120B	51 12					ACALL	FP_CLEAR
 1005: 1  120D	31 C3					ACALL	STORE_ALIGN_TEST_AND_EXIT
 1006: 1  120F	D2 E2					SETB	ACC.ZERO
 1007: 1  1211	22					RET					;EXIT
 1008: 1				;
 1009: 1				;**************************************************************
 1010: 1				;
 1011: 1  1212			FP_CLEAR:
 1012: 1				;
 1013: 1				; Clear internal storage
 1014: 1				;
 1015: 1				;**************************************************************
 1016: 1				;
 1017: 1  1212	E4					CLR	A
 1018: 1  1213	78 39					MOV	R0,#FP_ACC8+1
 1019: 1				;
 1020: 1  1215	F6		FPC1:			MOV	@R0,A
 1021: 1  1216	18					DEC	R0
 1022: 1  1217	B8 25 FB				CJNE	R0,#FP_TEMP,FPC1
 1023: 1  121A	22					RET
 1024: 1				;
 1025: 1				;**************************************************************
 1026: 1				;
 1027: 1  121B			RIGHT:	; Shift ACCUMULATOR RIGHT the number of nibbles in R7
 1028: 1				; Save the shifted values in R4 if SAVE_ROUND is set
 1029: 1				;
 1030: 1				;**************************************************************
 1031: 1				;
 1032: 1  121B	7C 00					MOV	R4,#0				;IN CASE OF NO SHIFT
 1033: 1				;
 1034: 1  121D	C3		RIGHT1:			CLR	C
 1035: 1  121E	EF					MOV	A,R7				;GET THE DIGITS TO SHIFT
 1036: 1  121F	60 22					JZ	RIGHT5-1			;EXIT IF ZERO
 1037: 1  1221	94 02					SUBB	A,#2				;TWO TO DO?
 1038: 1  1223	50 1F					JNC	RIGHT5				;SHIFT TWO NIBBLES
 1039: 1				;
 1040: 1				; Swap one nibble then exit
 1041: 1				;
 1042: 1  1225	C0 00		RIGHT3:			PUSH	R0B0				;SAVE POINTER REGISTER
 1043: 1  1227	C0 01					PUSH	R1B0
 1044: 1				;
 1045: 1  1229	79 2A					MOV	R1,#FP_DIG78			;LOAD THE POINTERS
 1046: 1  122B	78 29					MOV	R0,#FP_DIG56

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 20



 Line  I  Addr  Code            Source

 1047: 1  122D	EC					MOV	A,R4				;GET THE OVERFLOW REGISTER
 1048: 1  122E	D7					XCHD	A,@R1				;GET DIGIT 8
 1049: 1  122F	C4					SWAP	A				;FLIP FOR LOAD
 1050: 1  1230	FC					MOV	R4,A
 1051: 1				;
 1052: 1  1231	E7		RIGHTL:			MOV	A,@R1				;GET THE LOW ORDER BYTE
 1053: 1  1232	D6					XCHD	A,@R0				;SWAP NIBBLES
 1054: 1  1233	C4					SWAP	A				;FLIP FOR STORE
 1055: 1  1234	F7					MOV	@R1,A				;SAVE THE DIGITS
 1056: 1  1235	18					DEC	R0				;BUMP THE POINTERS
 1057: 1  1236	19					DEC	R1
 1058: 1  1237	B9 26 F7				CJNE	R1,#FP_DIG12-1,RIGHTL	;LOOP
 1059: 1				;
 1060: 1  123A	E7					MOV	A,@R1				;ACC = CH8
 1061: 1  123B	C4					SWAP	A				;ACC = 8CH
 1062: 1  123C	54 0F					ANL	A,#0FH				;ACC = 0CH
 1063: 1  123E	F7					MOV	@R1,A				;CARRY DONE
 1064: 1  123F	D0 01					POP	R1B0				;EXIT
 1065: 1  1241	D0 00					POP	R0B0				;RESTORE REGISTER
 1066: 1  1243	22					RET
 1067: 1				;
 1068: 1  1244	FF		RIGHT5:			MOV	R7,A				;SAVE THE NEW SHIFT NUMBER
 1069: 1  1245	E4					CLR	A
 1070: 1  1246	C5 26					XCH	A,FP_CARRY			;SWAP THE NIBBLES
 1071: 1  1248	C5 27					XCH	A,FP_DIG12
 1072: 1  124A	C5 28					XCH	A,FP_DIG34
 1073: 1  124C	C5 29					XCH	A,FP_DIG56
 1074: 1  124E	C5 2A					XCH	A,FP_DIG78
 1075: 1  1250	FC					MOV	R4,A				;SAVE THE LAST DIGIT SHIFTED
 1076: 1  1251	80 CB					SJMP	RIGHT1+1
 1077: 1				;
 1078: 1				;***************************************************************
 1079: 1				;
 1080: 1  1253			LEFT:	; Shift ACCUMULATOR LEFT the number of nibbles in R7
 1081: 1				;
 1082: 1				;***************************************************************
 1083: 1				;
 1084: 1  1253	7C 00					MOV	R4,#00H				;CLEAR FOR SOME ENTRYS
 1085: 1				;
 1086: 1  1255	C3		LEFT1:			CLR	C
 1087: 1  1256	EF					MOV	A,R7				;GET SHIFT VALUE
 1088: 1  1257	60 22					JZ	LEFT5-1				;EXIT IF ZERO
 1089: 1  1259	94 02					SUBB	A,#2				;SEE HOW MANY BYTES TO SHIFT
 1090: 1  125B	50 1F					JNC	LEFT5
 1091: 1				;
 1092: 1  125D	C0 00		LEFT3:			PUSH	R0B0				;SAVE POINTER
 1093: 1  125F	C0 01					PUSH	R1B0
 1094: 1  1261	78 26					MOV	R0,#FP_CARRY
 1095: 1  1263	79 27					MOV	R1,#FP_DIG12
 1096: 1				;
 1097: 1  1265	E6					MOV	A,@R0				;ACC=CHCL
 1098: 1  1266	C4					SWAP	A				;ACC = CLCH
 1099: 1  1267	F6					MOV	@R0,A				;ACC = CLCH, @R0 = CLCH
 1100: 1				;
 1101: 1  1268	E7		LEFTL:			MOV	A,@R1				;DIG 12
 1102: 1  1269	C4					SWAP	A				;DIG 21

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 21



 Line  I  Addr  Code            Source

 1103: 1  126A	D6					XCHD	A,@R0
 1104: 1  126B	F7					MOV	@R1,A				;SAVE IT
 1105: 1  126C	08					INC	R0				;BUMP POINTERS
 1106: 1  126D	09					INC	R1
 1107: 1  126E	B8 2A F7				CJNE	R0,#FP_DIG78,LEFTL
 1108: 1				;
 1109: 1  1271	EC					MOV	A,R4
 1110: 1  1272	C4					SWAP	A
 1111: 1  1273	D6					XCHD	A,@R0
 1112: 1  1274	54 F0					ANL	A,#0F0H
 1113: 1  1276	FC					MOV	R4,A
 1114: 1				;
 1115: 1  1277	D0 01					POP	R1B0
 1116: 1  1279	D0 00					POP	R0B0				;RESTORE
 1117: 1  127B	22					RET					;DONE
 1118: 1				;
 1119: 1  127C	FF		LEFT5:			MOV	R7,A				;RESTORE COUNT
 1120: 1  127D	E4					CLR	A
 1121: 1  127E	CC					XCH	A,R4				;GET THE RESTORATION BYTE
 1122: 1  127F	C5 2A					XCH	A,FP_DIG78			;DO THE SWAP
 1123: 1  1281	C5 29					XCH	A,FP_DIG56
 1124: 1  1283	C5 28					XCH	A,FP_DIG34
 1125: 1  1285	C5 27					XCH	A,FP_DIG12
 1126: 1  1287	C5 26					XCH	A,FP_CARRY
 1127: 1  1289	80 CB					SJMP	LEFT1+1
 1128: 1				;
 1129: 1  128B			MUL_NIBBLE:
 1130: 1				;
 1131: 1				; Multiply the nibble in R7 by the FP_NIB locations
 1132: 1				; accumulate the product in FP_ACC
 1133: 1				;
 1134: 1				; Set up the pointers for multiplication
 1135: 1				;
 1136: 1  128B	54 0F					ANL	A,#0FH				;STRIP OFF MS NIBBLE
 1137: 1  128D	FF					MOV	R7,A
 1138: 1  128E	78 38					MOV	R0,#FP_ACC8
 1139: 1  1290	79 2E					MOV	R1,#FP_NIB8
 1140: 1  1292	E4					CLR	A
 1141: 1  1293	F5 2F					MOV	FP_ACCX,A
 1142: 1				;
 1143: 1  1295	18		MNLOOP:			DEC	R0				;BUMP POINTER TO PROPAGATE CARRY
 1144: 1  1296	26					ADD	A,@R0				;ATTEMPT TO FORCE CARRY
 1145: 1  1297	D4					DA	A				;BCD ADJUST
 1146: 1  1298	30 E4 03				JNB	ACC.4,MNL0			;DON'T ADJUST IF NO NEED
 1147: 1  129B	18					DEC	R0				;PROPAGATE CARRY TO THE NEXT DIGIT
 1148: 1  129C	06					INC	@R0				;DO THE ADJUSTING
 1149: 1  129D	08					INC	R0				;RESTORE R0
 1150: 1				;
 1151: 1  129E	D6		MNL0:			XCHD	A,@R0				;RESTORE INITIAL NUMBER
 1152: 1  129F	8F F0					MOV	B,R7				;GET THE NUBBLE TO MULTIPLY
 1153: 1  12A1	E7					MOV	A,@R1				;GET THE OTHER NIBBLE
 1154: 1  12A2	A4					MUL	AB					;DO THE MULTIPLY
 1155: 1  12A3	75 F0 0A				MOV	B,#10				;NOW BCD ADJUST
 1156: 1  12A6	84					DIV	AB
 1157: 1  12A7	C5 F0					XCH	A,B				;GET THE REMAINDER
 1158: 1  12A9	26					ADD	A,@R0				;PROPAGATE THE PARTIAL PRODUCTS

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 22



 Line  I  Addr  Code            Source

 1159: 1  12AA	D4					DA	A				;BCD ADJUST
 1160: 1  12AB	30 E4 02				JNB	ACC.4,MNL1			;PROPAGATE PARTIAL PRODUCT CARRY
 1161: 1  12AE	05 F0					INC	B
 1162: 1				;
 1163: 1  12B0	08		MNL1:			INC	R0
 1164: 1  12B1	D6					XCHD	A,@R0				;SAVE THE NEW PRODUCT
 1165: 1  12B2	18					DEC	R0
 1166: 1  12B3	E5 F0					MOV	A,B				;GET BACK THE QUOTIENT
 1167: 1  12B5	19					DEC	R1
 1168: 1  12B6	B9 26 DC				CJNE	R1,#FP_NIB1-1,MNLOOP
 1169: 1				;
 1170: 1  12B9	25 2F					ADD	A,FP_ACCX			;GET THE OVERFLOW
 1171: 1  12BB	D4					DA	A				;ADJUST
 1172: 1  12BC	F6					MOV	@R0,A				;SAVE IT
 1173: 1  12BD	22					RET					;EXIT
 1174: 1				;
 1175: 1				;***************************************************************
 1176: 1				;
 1177: 1  12BE			LOAD_POINTERS:	; Load the ARG_STACK into R0 and bump R1
 1178: 1				;
 1179: 1				;***************************************************************
 1180: 1				;
 1181: 1  12BE	A8 22					MOV	R0,ARG_STACK
 1182: 1  12C0	74 06					MOV	A,#FP_NUMBER_SIZE
 1183: 1  12C2	28					ADD	A,R0
 1184: 1  12C3	F9					MOV	R1,A
 1185: 1  12C4	22					RET
 1186: 1				;
 1187: 1				;***************************************************************
 1188: 1				;
 1189: 1  12C5			MUL_DIV_EXP_AND_SIGN:
 1190: 1				;
 1191: 1				; Load the sign into R7, R6. R5 gets the sign for
 1192: 1				; multiply and divide.
 1193: 1				;
 1194: 1				;***************************************************************
 1195: 1				;
 1196: 1  12C5	51 12					ACALL	FP_CLEAR			;CLEAR INTERNAL MEMORY
 1197: 1				;
 1198: 1  12C7	51 BE		MDES1:			ACALL	LOAD_POINTERS			;LOAD REGISTERS
 1199: 1  12C9	E6					MOV	A,@R0				;ARG 1 EXP
 1200: 1  12CA	FF					MOV	R7,A				;SAVED IN R7
 1201: 1  12CB	E7					MOV	A,@R1				;ARG 2 EXP
 1202: 1  12CC	FE					MOV	R6,A				;SAVED IN R6
 1203: 1  12CD	18					DEC	R0				;BUMP POINTERS TO SIGN
 1204: 1  12CE	19					DEC	R1
 1205: 1  12CF	E6					MOV	A,@R0				;GET THE SIGN
 1206: 1  12D0	FC					MOV	R4,A				;SIGN OF ARG1
 1207: 1  12D1	E7					MOV	A,@R1				;GET SIGN OF NEXT ARG
 1208: 1  12D2	FB					MOV	R3,A				;SIGN OF ARG2
 1209: 1  12D3	6C					XRL	A,R4				;ACC GETS THE NEW SIGN
 1210: 1  12D4	FD					MOV	R5,A				;R5 GETS THE NEW SIGN
 1211: 1				;
 1212: 1				; Bump the pointers to point at the LS digit
 1213: 1				;
 1214: 1  12D5	18					DEC	R0

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 23



 Line  I  Addr  Code            Source

 1215: 1  12D6	19					DEC	R1
 1216: 1				;
 1217: 1  12D7	22					RET
 1218: 1				;
 1219: 1				;***************************************************************
 1220: 1				;
 1221: 1  12D8			LOADR1_MANTISSA:
 1222: 1				;
 1223: 1				; Load the mantissa of R0 into FP_Digits
 1224: 1				;
 1225: 1				;***************************************************************
 1226: 1				;
 1227: 1  12D8	C0 00					PUSH	R0B0				;SAVE REGISTER 1
 1228: 1  12DA	78 2A					MOV	R0,#FP_DIG78			;SET UP THE POINTER
 1229: 1				;
 1230: 1  12DC	E7		LOADR1:			MOV	A,@R1
 1231: 1  12DD	F6					MOV	@R0,A
 1232: 1  12DE	19					DEC	R1
 1233: 1  12DF	18					DEC	R0
 1234: 1  12E0	B8 26 F9				CJNE	R0,#FP_CARRY,LOADR1
 1235: 1				;
 1236: 1  12E3	D0 00					POP	R0B0
 1237: 1  12E5	22					RET
 1238: 1				;
 1239: 1				;***************************************************************
 1240: 1				;
 1241: 1  12E6			HEXSCAN:	; Scan a string to determine if it is a hex number
 1242: 1					; set carry if hex, else carry = 0
 1243: 1				;
 1244: 1				;***************************************************************
 1245: 1				;
 1246: 1  12E6	71 A8					ACALL	GET_R1_CHARACTER
 1247: 1				;
 1248: 1  12E8	E7		HEXSC1:			MOV	A,@R1				;GET THE CHARACTER
 1249: 1  12E9	B1 71					ACALL	DIGIT_CHECK			;SEE IF A DIGIT
 1250: 1  12EB	40 0E					JC	HS1				;CONTINUE IF A DIGIT
 1251: 1  12ED	51 FE					ACALL	HEX_CHECK			;SEE IF HEX
 1252: 1  12EF	40 0A					JC	HS1
 1253: 1				;
 1254: 1  12F1	C2 E5					CLR	ACC.5				;NO LOWER CASE
 1255: 1  12F3	B4 48 03				CJNE	A,#'H',HEXDON
 1256: 1  12F6	D3					SETB	C
 1257: 1  12F7	80 01					SJMP	HEXDO1				;NUMBER IS VALID HEX, MAYBE
 1258: 1				;
 1259: 1  12F9	C3		HEXDON:			CLR	C
 1260: 1				;
 1261: 1  12FA	22		HEXDO1:			RET
 1262: 1				;
 1263: 1  12FB	09		HS1:			INC	R1				;BUMP TO NEXT CHARACTER
 1264: 1  12FC	80 EA					SJMP	HEXSC1				;LOOP
 1265: 1				;
 1266: 1  12FE			HEX_CHECK:	;CHECK FOR A VALID ASCII HEX, SET CARRY IF FOUND
 1267: 1				;
 1268: 1  12FE	C2 E5					CLR	ACC.5				;WASTE LOWER CASE
 1269: 1						CMP	A,#'F'+1			;SEE IF F OR LESS
 1270+ 2  1300	B4 47 00	CJNE	A,#'F'+1,$+3

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 24



 Line  I  Addr  Code            Source

 1271: 1  1303	40 01					JC	HC1
 1272: 1  1305	22					RET
 1273: 1				;
 1274: 1  1306			HC1:			CMP	A,#'A'				;SEE IF A OR GREATER
 1275+ 2  1306	B4 41 00	CJNE	A,#'A',$+3
 1276: 1  1309	B3					CPL	C
 1277: 1  130A	22					RET
 1278: 1				;
 1279: 1				;***************************************************************
 1280: 1				;
 1281: 1  130B			FLOATING_POINT_INPUT:	; Input a floating point number pointed to by R0
 1282: 1				;
 1283: 1				;***************************************************************
 1284: 1				;
 1285: 1  130B	51 12					ACALL	FP_CLEAR			;CLEAR EVERYTHING
 1286: 1  130D	71 A8					ACALL	GET_R1_CHARACTER
 1287: 1  130F	71 AE					ACALL	PLUS_MINUS_TEST
 1288: 1  1311	92 58					MOV	MSIGN,C				;SAVE THE MANTISSA SIGN
 1289: 1				;
 1290: 1				; Now, set up for input loop
 1291: 1				;
 1292: 1  1313	78 30					MOV	R0,#FP_ACCC
 1293: 1  1315	7E 7F					MOV	R6,#7FH				;BASE EXPONENT
 1294: 1  1317	D2 D5					SETB	F0				;SET INITIAL FLAG
 1295: 1				;
 1296: 1  1319	B1 6F		INLOOP:			ACALL	GET_DIGIT_CHECK
 1297: 1  131B	50 07					JNC	GTEST				;IF NOT A CHARACTER, WHAT IS IT?
 1298: 1  131D	54 0F					ANL	A,#0FH				;STRIP ASCII
 1299: 1  131F	71 81					ACALL	STDIG				;STORE THE DIGITS
 1300: 1				;
 1301: 1  1321	09		INLPIK:			INC	R1				;BUMP POINTER FOR LOOP
 1302: 1  1322	80 F5					SJMP	INLOOP				;LOOP FOR INPUT
 1303: 1				;
 1304: 1  1324	B4 2E 0C	GTEST:			CJNE	A,#'.',GT1			;SEE IF A RADIX
 1305: 1  1327	20 31 63				JB	FOUND_RADIX,INERR
 1306: 1  132A	D2 31					SETB	FOUND_RADIX
 1307: 1  132C	B8 30 F2				CJNE	R0,#FP_ACCC,INLPIK
 1308: 1  132F	D2 32					SETB	FIRST_RADIX			;SET IF FIRST RADIX
 1309: 1  1331	80 EE					SJMP	INLPIK				;GET ADDITIONAL DIGITS
 1310: 1				;
 1311: 1  1333	20 D5 57	GT1:			JB	F0,INERR			;ERROR IF NOT CLEARED
 1312: 1  1336	B4 65 02				CJNE	A,#'e',GT11			;CHECK FOR LOWER CASE
 1313: 1  1339	80 03					SJMP	GT12
 1314: 1  133B	B4 45 33	GT11:			CJNE	A,#'E',FINISH_UP
 1315: 1  133E	71 A7		GT12:			ACALL	INC_AND_GET_R1_CHARACTER
 1316: 1  1340	71 AE					ACALL	PLUS_MINUS_TEST
 1317: 1  1342	92 30					MOV	XSIGN,C				;SAVE SIGN STATUS
 1318: 1  1344	B1 6F					ACALL	GET_DIGIT_CHECK
 1319: 1  1346	50 45					JNC	INERR
 1320: 1				;
 1321: 1  1348	54 0F					ANL	A,#0FH				;STRIP ASCII BIAS OFF THE CHARACTER
 1322: 1  134A	FD					MOV	R5,A				;SAVE THE CHARACTER IN R5
 1323: 1				;
 1324: 1  134B	09		GT2:			INC	R1
 1325: 1  134C	B1 6F					ACALL	GET_DIGIT_CHECK
 1326: 1  134E	50 0D					JNC	FINISH1

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 25



 Line  I  Addr  Code            Source

 1327: 1  1350	54 0F					ANL	A,#0FH				;STRIP OFF BIAS
 1328: 1  1352	CD					XCH	A,R5				;GET THE LAST DIGIT
 1329: 1  1353	75 F0 0A				MOV	B,#10				;MULTIPLY BY TEN
 1330: 1  1356	A4					MUL	AB
 1331: 1  1357	2D					ADD	A,R5				;ADD TO ORIGINAL VALUE
 1332: 1  1358	FD					MOV	R5,A				;SAVE IN R5
 1333: 1  1359	50 F0					JNC	GT2					;LOOP IF NO CARRY
 1334: 1  135B	7D FF					MOV	R5,#0FFH			;FORCE AN ERROR
 1335: 1				;
 1336: 1  135D	ED		FINISH1:		MOV	A,R5				;GET THE SIGN
 1337: 1  135E	30 30 09				JNB	XSIGN,POSNUM			;SEE IF EXPONENT IS POS OR NEG
 1338: 1  1361	C3					CLR	C
 1339: 1  1362	9E					SUBB	A,R6
 1340: 1  1363	F4					CPL	A
 1341: 1  1364	04					INC	A
 1342: 1  1365	40 09					JC	FINISH2
 1343: 1  1367	74 01					MOV	A,#01H
 1344: 1  1369	22					RET
 1345: 1				;
 1346: 1  136A	2E		POSNUM:			ADD	A,R6				;ADD TO EXPONENT
 1347: 1  136B	50 03					JNC	FINISH2
 1348: 1				;
 1349: 1  136D	74 02		POSNM1:			MOV	A,#02H
 1350: 1  136F	22					RET
 1351: 1				;
 1352: 1  1370	CE		FINISH2:		XCH	A,R6				;SAVE THE EXPONENT
 1353: 1				;
 1354: 1  1371			FINISH_UP:
 1355: 1				;
 1356: 1  1371	8E 2C					MOV	FP_EXP,R6			;SAVE EXPONENT
 1357: 1  1373	B8 30 02				CJNE	R0,#FP_ACCC,FINISH_UP1
 1358: 1  1376	51 12					ACALL	FP_CLEAR			;CLEAR THE MEMORY IF 0
 1359: 1  1378	E5 22		FINISH_UP1:		MOV	A,ARG_STACK			;GET THE ARG STACK
 1360: 1  137A	C3					CLR	C
 1361: 1  137B	94 0C					SUBB	A,#FP_NUMBER_SIZE+FP_NUMBER_SIZE
 1362: 1  137D	F5 22					MOV	ARG_STACK,A			;ADJUST FOR STORE
 1363: 1  137F	21 83					AJMP	PACK
 1364: 1				;
 1365: 1  1381	C2 D5		STDIG:			CLR	F0				;CLEAR INITIAL DESIGNATOR
 1366: 1  1383	70 0B					JNZ	STDIG1				;CONTINUE IF NOT ZERO
 1367: 1  1385	B8 30 08				CJNE	R0,#FP_ACCC,STDIG1
 1368: 1  1388	30 32 04				JNB	FIRST_RADIX,RET_X
 1369: 1				;
 1370: 1  138B	DE 02		DECX:			DJNZ	R6,RET_X
 1371: 1				;
 1372: 1  138D	74 FF		INERR:			MOV	A,#0FFH
 1373: 1				;
 1374: 1  138F	22		RET_X:			RET
 1375: 1				;
 1376: 1  1390	20 33 02	STDIG1:			JB	DONE_LOAD,FRTEST
 1377: 1  1393	C2 32					CLR	FIRST_RADIX
 1378: 1				;
 1379: 1  1395	20 32 F3	FRTEST:			JB	FIRST_RADIX,DECX
 1380: 1				;
 1381: 1  1398	20 31 01	FDTEST:			JB	FOUND_RADIX,FDT1
 1382: 1  139B	0E					INC	R6

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 26



 Line  I  Addr  Code            Source

 1383: 1				;
 1384: 1  139C	20 33 F0	FDT1:			JB	DONE_LOAD,RET_X
 1385: 1  139F	B8 39 02				CJNE	R0,#FP_ACC8+1,FDT2
 1386: 1  13A2	D2 33					SETB	DONE_LOAD
 1387: 1				;
 1388: 1  13A4	F6		FDT2:			MOV	@R0,A				;SAVE THE STRIPPED ACCUMULATOR
 1389: 1  13A5	08					INC	R0				;BUMP THE POINTER
 1390: 1  13A6	22					RET					;EXIT
 1391: 1				;
 1392: 1				;***************************************************************
 1393: 1				;
 1394: 1				; I/O utilities
 1395: 1				;
 1396: 1				;***************************************************************
 1397: 1				;
 1398: 1  13A7			INC_AND_GET_R1_CHARACTER:
 1399: 1				;
 1400: 1  13A7	09					INC	R1
 1401: 1				;
 1402: 1  13A8			GET_R1_CHARACTER:
 1403: 1				;
 1404: 1  13A8	E7					MOV	A,@R1				;GET THE CHARACTER
 1405: 1  13A9	B4 20 0C				CJNE	A,#' ',PMT1			;SEE IF A SPACE
 1406: 1				;
 1407: 1				; Kill spaces
 1408: 1				;
 1409: 1  13AC	80 F9					SJMP	INC_AND_GET_R1_CHARACTER
 1410: 1				;
 1411: 1  13AE			PLUS_MINUS_TEST:
 1412: 1				;
 1413: 1  13AE	B4 2B 02				CJNE	A,#'+',PMT0
 1414: 1  13B1	80 04					SJMP	PMT3
 1415: 1  13B3	B4 2D 02	PMT0:			CJNE	A,#'-',PMT1
 1416: 1				;
 1417: 1  13B6	D3		PMT2:			SETB	C
 1418: 1				;
 1419: 1  13B7	09		PMT3:			INC	R1
 1420: 1				;
 1421: 1  13B8	22		PMT1:			RET
 1422: 1				;
 1423: 1				;***************************************************************
 1424: 1				;
 1425: 1  13B9			FLOATING_POINT_OUTPUT:	; Output the number, format is in location 25
 1426: 1				;
 1427: 1				; IF FORMAT = 00 - FREE FLOATING
 1428: 1				;           = FX - EXPONENTIAL (X IS THE NUMBER OF SIG DIGITS)
 1429: 1				;           = NX - N = NUM BEFORE RADIX, X = NUM AFTER RADIX
 1430: 1				;                  N + X = 8 MAX
 1431: 1				;
 1432: 1				;***************************************************************
 1433: 1				;
 1434: 1  13B9	51 C7					ACALL	MDES1				;GET THE NUMBER TO OUTPUT, R0 IS POI
       1			NTER
 1435: 1  13BB	11 1B					ACALL	POP_AND_EXIT			;OUTPUT POPS THE STACK
 1436: 1  13BD	EF					MOV	A,R7
 1437: 1  13BE	FE					MOV	R6,A				;PUT THE EXPONENT IN R6

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 27



 Line  I  Addr  Code            Source

 1438: 1  13BF	31 DE					ACALL	UNPACK_R0			;UNPACK THE NUMBER
 1439: 1  13C1	78 27					MOV	R0,#FP_NIB1			;POINT AT THE NUMBER
 1440: 1  13C3	E5 23					MOV	A,FORMAT			;GET THE FORMAT
 1441: 1  13C5	FB					MOV	R3,A				;SAVE IN CASE OF EXP FORMAT
 1442: 1  13C6	60 49					JZ	FREE				;FREE FLOATING?
 1443: 1						CMP	A,#0F0H				;SEE IF EXPONENTIAL
 1444+ 2  13C8	B4 F0 00	CJNE	A,#0F0H,$+3
 1445: 1  13CB	50 73					JNC	EXPOUT
 1446: 1				;
 1447: 1				; If here, must be integer USING format
 1448: 1				;
 1449: 1  13CD	EE					MOV	A,R6				;GET THE EXPONENT
 1450: 1  13CE	70 02					JNZ	FPO1
 1451: 1  13D0	7E 80					MOV	R6,#80H
 1452: 1  13D2	EB		FPO1:			MOV	A,R3				;GET THE FORMAT
 1453: 1  13D3	C4					SWAP	A				;SPLIT INTEGER AND FRACTION
 1454: 1  13D4	54 0F					ANL	A,#0FH
 1455: 1  13D6	FA					MOV	R2,A				;SAVE INTEGER
 1456: 1  13D7	91 A6					ACALL	NUM_LT				;GET THE NUMBER OF INTEGERS
 1457: 1  13D9	CA					XCH	A,R2				;FLIP FOR SUBB
 1458: 1  13DA	C3					CLR	C
 1459: 1  13DB	9A					SUBB	A,R2
 1460: 1  13DC	FF					MOV	R7,A
 1461: 1  13DD	50 06					JNC	FPO2
 1462: 1  13DF	7D 3F					MOV	R5,#'?'				;OUTPUT A QUESTION MARK
 1463: 1  13E1	91 DB					ACALL	SOUT1				;NUMBER IS TOO LARGE FOR FORMAT
 1464: 1  13E3	81 11					AJMP	FREE
 1465: 1  13E5	BA 00 07	FPO2:			CJNE	R2,#00,USING0			;SEE IF ZERO
 1466: 1  13E8	1F					DEC	R7
 1467: 1  13E9	91 C8					ACALL	SS7
 1468: 1  13EB	91 D5					ACALL	ZOUT				;OUTPUT A ZERO
 1469: 1  13ED	80 06					SJMP	USING1
 1470: 1				;
 1471: 1  13EF	91 C8		USING0:			ACALL	SS7				;OUTPUT SPACES, IF NEED TO
 1472: 1  13F1	EA					MOV	A,R2				;OUTPUT DIGITS
 1473: 1  13F2	FF					MOV	R7,A
 1474: 1  13F3	91 8A					ACALL	OUTR0
 1475: 1				;
 1476: 1  13F5	EB		USING1:			MOV	A,R3
 1477: 1  13F6	54 0F					ANL	A,#0FH				;GET THE NUMBER RIGHT OF DP
 1478: 1  13F8	FA					MOV	R2,A				;SAVE IT
 1479: 1  13F9	60 BD					JZ	PMT1				;EXIT IF ZERO
 1480: 1  13FB	91 D1					ACALL	ROUT				;OUTPUT DP
 1481: 1  13FD	91 AF					ACALL	NUM_RT
 1482: 1  13FF	B5 02 03				CJNE	A,2,USINGX			;COMPARE A TO R2
 1483: 1				;
 1484: 1  1402	EA		USINGY:			MOV	A,R2
 1485: 1  1403	81 BF					AJMP	Z7R7
 1486: 1				;
 1487: 1  1405	50 FB		USINGX:			JNC	USINGY
 1488: 1				;
 1489: 1  1407	CA		USING2:			XCH	A,R2
 1490: 1  1408	C3					CLR	C
 1491: 1  1409	9A					SUBB	A,R2
 1492: 1  140A	CA					XCH	A,R2
 1493: 1  140B	91 BF					ACALL	Z7R7				;OUTPUT ZEROS IF NEED TO

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 28



 Line  I  Addr  Code            Source

 1494: 1  140D	EA					MOV	A,R2
 1495: 1  140E	FF					MOV	R7,A
 1496: 1  140F	81 8A					AJMP	OUTR0
 1497: 1				;
 1498: 1				; First, force exponential output, if need to
 1499: 1				;
 1500: 1  1411	EE		FREE:			MOV	A,R6				;GET THE EXPONENT
 1501: 1  1412	70 04					JNZ	FREE1				;IF ZERO, PRINT IT
 1502: 1  1414	91 D9					ACALL	SOUT
 1503: 1  1416	81 D5					AJMP	ZOUT
 1504: 1				;
 1505: 1  1418	7B F0		FREE1:			MOV	R3,#0F0H			;IN CASE EXP NEEDED
 1506: 1  141A	74 77					MOV	A,#80H-DIGIT-DIGIT-1
 1507: 1  141C	2E					ADD	A,R6
 1508: 1  141D	40 21					JC	EXPOUT
 1509: 1  141F	94 F7					SUBB	A,#0F7H
 1510: 1  1421	40 1D					JC	EXPOUT
 1511: 1				;
 1512: 1				; Now, just print the number
 1513: 1				;
 1514: 1  1423	91 CA					ACALL	SINOUT				;PRINT THE SIGN OF THE NUMBER
 1515: 1  1425	91 A6					ACALL	NUM_LT				;GET THE NUMBER LEFT OF DP
 1516: 1  1427	B4 08 02				CJNE	A,#8,FREE4
 1517: 1  142A	81 8A					AJMP	OUTR0
 1518: 1				;
 1519: 1  142C	91 8A		FREE4:			ACALL	OUTR0
 1520: 1  142E	91 9C					ACALL	ZTEST				;TEST FOR TRAILING ZEROS
 1521: 1  1430	60 57					JZ	U_RET				;DONE IF ALL TRAILING ZEROS
 1522: 1  1432	91 D1					ACALL	ROUT				;OUTPUT RADIX
 1523: 1				;
 1524: 1  1434	7F 01		FREE2:			MOV	R7,#1				;OUTPUT ONE DIGIT
 1525: 1  1436	91 8A					ACALL	OUTR0
 1526: 1  1438	70 4F					JNZ	U_RET
 1527: 1  143A	91 9C					ACALL	ZTEST
 1528: 1  143C	60 4B					JZ	U_RET
 1529: 1  143E	80 F4					SJMP	FREE2				;LOOP
 1530: 1				;
 1531: 1  1440	91 CA		EXPOUT:			ACALL	SINOUT				;PRINT THE SIGN
 1532: 1  1442	7F 01					MOV	R7,#1				;OUTPUT ONE CHARACTER
 1533: 1  1444	91 8A					ACALL	OUTR0
 1534: 1  1446	91 D1					ACALL	ROUT				;OUTPUT RADIX
 1535: 1  1448	EB					MOV	A,R3				;GET FORMAT
 1536: 1  1449	54 0F					ANL	A,#0FH				;STRIP INDICATOR
 1537: 1  144B	60 06					JZ	EXPOTX
 1538: 1				;
 1539: 1  144D	FF					MOV	R7,A				;OUTPUT THE NUMBER OF DIGITS
 1540: 1  144E	1F					DEC	R7				;ADJUST BECAUSE ONE CHAR ALREADY OUT
 1541: 1  144F	91 8A					ACALL	OUTR0
 1542: 1  1451	80 02					SJMP	EXPOT4
 1543: 1				;
 1544: 1  1453	91 34		EXPOTX:			ACALL	FREE2				;OUTPUT UNTIL TRAILING ZEROS
 1545: 1				;
 1546: 1  1455	91 D9		EXPOT4:			ACALL	SOUT				;OUTPUT A SPACE
 1547: 1  1457	7D 45					MOV	R5,#'E'
 1548: 1  1459	91 DB					ACALL	SOUT1				;OUTPUT AN E
 1549: 1  145B	EE					MOV	A,R6				;GET THE EXPONENT

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 29



 Line  I  Addr  Code            Source

 1550: 1  145C	60 04					JZ	XOUT0				;EXIT IF ZERO
 1551: 1  145E	14					DEC	A				;ADJUST FOR THE DIGIT ALREADY OUTPUT
 1552: 1  145F	B4 80 05				CJNE	A,#80H,XOUT2			;SEE WHAT IT IS
 1553: 1				;
 1554: 1  1462	91 D9		XOUT0:			ACALL	SOUT
 1555: 1  1464	E4					CLR	A
 1556: 1  1465	80 0C					SJMP	XOUT4
 1557: 1				;
 1558: 1  1467	40 06		XOUT2:			JC	XOUT3				;NEGATIVE EXPONENT
 1559: 1  1469	7D 2B					MOV	R5,#'+'				;OUTPUT A PLUS SIGN
 1560: 1  146B	91 DB					ACALL	SOUT1
 1561: 1  146D	80 04					SJMP	XOUT4
 1562: 1				;
 1563: 1  146F	91 CD		XOUT3:			ACALL	MOUT
 1564: 1  1471	F4					CPL	A				;FLIP BITS
 1565: 1  1472	04					INC	A				;BUMP
 1566: 1				;
 1567: 1  1473	C2 E7		XOUT4:			CLR	ACC.7
 1568: 1  1475	F8					MOV	R0,A
 1569: 1  1476	7A 00					MOV	R2,#0
 1570: 1  1478	79 66					MOV	R1,#LOW CONVT			;CONVERSION LOCATION
 1571: 1  147A	7B 00					MOV	R3,#HIGH CONVT
 1572: 1  147C	B1 01					ACALL	CONVERT_BINARY_TO_ASCII_STRING
 1573: 1  147E	78 66					MOV	R0,#LOW CONVT			;NOW, OUTPUT EXPONENT
 1574: 1				;
 1575: 1  1480	E6		EXPOT5:			MOV	A,@R0				;GET THE CHARACTER
 1576: 1  1481	FD					MOV	R5,A				;OUTPUT IT
 1577: 1  1482	91 DB					ACALL	SOUT1
 1578: 1  1484	08					INC	R0				;BUMP THE POINTER
 1579: 1  1485	E8					MOV	A,R0				;GET THE POINTER
 1580: 1  1486	B5 01 F7				CJNE	A,R1B0,EXPOT5			;LOOP
 1581: 1				;
 1582: 1  1489	22		U_RET:			RET					;EXIT
 1583: 1				;
 1584: 1  148A			OUTR0:	; Output the characters pointed to by R0, also bias ascii
 1585: 1				;
 1586: 1  148A	EF					MOV	A,R7				;GET THE COUNTER
 1587: 1  148B	60 0E					JZ	OUTR				;EXIT IF DONE
 1588: 1  148D	E6					MOV	A,@R0				;GET THE NUMBER
 1589: 1  148E	44 30					ORL	A,#30H				;ASCII BIAS
 1590: 1  1490	08					INC	R0				;BUMP POINTER AND COUNTER
 1591: 1  1491	1F					DEC	R7
 1592: 1  1492	FD					MOV	R5,A				;PUT CHARACTER IN OUTPUT REGISTER
 1593: 1  1493	91 DB					ACALL	SOUT1				;OUTPUT THE CHARACTER
 1594: 1  1495	E4					CLR	A				;JUST FOR TEST
 1595: 1  1496	B8 2F F1				CJNE	R0,#FP_NIB8+1,OUTR0
 1596: 1  1499	74 55					MOV	A,#55H				;KNOW WHERE EXIT OCCURED
 1597: 1				;
 1598: 1  149B	22		OUTR:			RET
 1599: 1				;
 1600: 1  149C	A9 00		ZTEST:			MOV	R1,R0B0				;GET POINTER REGISTER
 1601: 1				;
 1602: 1  149E	E7		ZT0:			MOV	A,@R1				;GET THE VALUE
 1603: 1  149F	70 04					JNZ	ZT1
 1604: 1  14A1	09					INC	R1				;BUMP POINTER
 1605: 1  14A2	B9 2F F9				CJNE	R1,#FP_NIB8+1,ZT0

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 30



 Line  I  Addr  Code            Source

 1606: 1				;
 1607: 1  14A5	22		ZT1:			RET
 1608: 1				;
 1609: 1  14A6	EE		NUM_LT:			MOV	A,R6				;GET EXPONENT
 1610: 1  14A7	C3					CLR	C				;GET READY FOR SUBB
 1611: 1  14A8	94 80					SUBB	A,#80H				;SUB EXPONENT BIAS
 1612: 1  14AA	50 01					JNC	NL1				;OK IF NO CARRY
 1613: 1  14AC	E4					CLR	A				;NO DIGITS LEFT
 1614: 1				;
 1615: 1  14AD	FF		NL1:			MOV	R7,A				;SAVE THE COUNT
 1616: 1  14AE	22					RET
 1617: 1				;
 1618: 1  14AF	C3		NUM_RT:			CLR	C				;SUBB AGAIN
 1619: 1  14B0	74 80					MOV	A,#80H				;EXPONENT BIAS
 1620: 1  14B2	9E					SUBB	A,R6				;GET THE BIASED EXPONENT
 1621: 1  14B3	50 01					JNC	NR1
 1622: 1  14B5	E4					CLR	A
 1623: 1				;
 1624: 1  14B6	22		NR1:			RET					;EXIT
 1625: 1				;
 1626: 1  14B7	EF		SPACE7:			MOV	A,R7				;GET THE NUMBER OF SPACES
 1627: 1  14B8	60 FC					JZ	NR1				;EXIT IF ZERO
 1628: 1  14BA	91 D9					ACALL	SOUT				;OUTPUT A SPACE
 1629: 1  14BC	1F					DEC	R7				;BUMP COUNTER
 1630: 1  14BD	80 F8					SJMP	SPACE7				;LOOP
 1631: 1				;
 1632: 1  14BF	FF		Z7R7:			MOV	R7,A
 1633: 1				;
 1634: 1  14C0	EF		ZERO7:			MOV	A,R7				;GET COUNTER
 1635: 1  14C1	60 F3					JZ	NR1				;EXIT IF ZERO
 1636: 1  14C3	91 D5					ACALL	ZOUT				;OUTPUT A ZERO
 1637: 1  14C5	1F					DEC	R7				;BUMP COUNTER
 1638: 1  14C6	80 F8					SJMP	ZERO7				;LOOP
 1639: 1				;
 1640: 1  14C8	91 B7		SS7:			ACALL	SPACE7
 1641: 1				;
 1642: 1  14CA	EC		SINOUT:			MOV	A,R4				;GET THE SIGN
 1643: 1  14CB	60 0C					JZ	SOUT				;OUTPUT A SPACE IF ZERO
 1644: 1				;
 1645: 1  14CD	7D 2D		MOUT:			MOV	R5,#'-'
 1646: 1  14CF	80 0A					SJMP	SOUT1				;OUTPUT A MINUS IF NOT
 1647: 1				;
 1648: 1  14D1	7D 2E		ROUT:			MOV	R5,#'.'				;OUTPUT A RADIX
 1649: 1  14D3	80 06					SJMP	SOUT1
 1650: 1				;
 1651: 1  14D5	7D 30		ZOUT:			MOV	R5,#'0'				;OUTPUT A ZERO
 1652: 1  14D7	80 02					SJMP	SOUT1
 1653: 1				;
 1654: 1  14D9	7D 20		SOUT:			MOV	R5,#' '				;OUTPUT A SPACE
 1655: 1				;
 1656: 1  14DB	A1 7C		SOUT1:			AJMP	R5OUT
 1657: 1				;
 1658: 1				;
 1659: 1  14DD	75 F0 0A	MULNUM10:		MOV	B,#10
 1660: 1				;
 1661: 1				;***************************************************************

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 31



 Line  I  Addr  Code            Source

 1662: 1				;
 1663: 1  14E0			MULNUM:	; Take the next digit in the acc (masked to 0FH)
 1664: 1				; accumulate in R3:R1
 1665: 1				;
 1666: 1				;***************************************************************
 1667: 1				;
 1668: 1  14E0	C0 E0					PUSH	ACC				;SAVE ACC
 1669: 1  14E2	C0 F0					PUSH	B				;SAVE MULTIPLIER
 1670: 1  14E4	E9					MOV	A,R1				;PUT LOW ORDER BITS IN ACC
 1671: 1  14E5	A4					MUL	AB				;DO THE MULTIPLY
 1672: 1  14E6	F9					MOV	R1,A				;PUT THE RESULT BACK
 1673: 1  14E7	EB					MOV	A,R3				;GET THE HIGH ORDER BYTE
 1674: 1  14E8	AB F0					MOV	R3,B				;SAVE THE OVERFLOW
 1675: 1  14EA	D0 F0					POP	B				;GET THE MULTIPLIER
 1676: 1  14EC	A4					MUL	AB				;DO IT
 1677: 1  14ED	A2 D2					MOV	C,OV				;SAVE OVERFLOW IN F0
 1678: 1  14EF	92 D5					MOV	F0,C
 1679: 1  14F1	2B					ADD	A,R3				;ADD OVERFLOW TO HIGH RESULT
 1680: 1  14F2	FB					MOV	R3,A				;PUT IT BACK
 1681: 1  14F3	D0 E0					POP	ACC				;GET THE ORIGINAL ACC BACK
 1682: 1  14F5	72 D5					ORL	C,F0				;OR CARRY AND OVERFLOW
 1683: 1  14F7	40 07					JC	MULX				;NO GOOD IF THE CARRY IS SET
 1684: 1				;
 1685: 1  14F9	54 0F		MUL11:			ANL	A,#0FH				;MASK OFF HIGH ORDER BITS
 1686: 1  14FB	29					ADD	A,R1				;NOW ADD THE ACC
 1687: 1  14FC	F9					MOV	R1,A				;PUT IT BACK
 1688: 1  14FD	E4					CLR	A				;PROPAGATE THE CARRY
 1689: 1  14FE	3B					ADDC	A,R3
 1690: 1  14FF	FB					MOV	R3,A				;PUT IT BACK
 1691: 1				;
 1692: 1  1500	22		MULX:			RET					;EXIT WITH OR WITHOUT CARRY
 1693: 1				;
 1694: 1				;***************************************************************
 1695: 1				;
 1696: 1  1501			CONVERT_BINARY_TO_ASCII_STRING:
 1697: 1				;
 1698: 1				;R1 contains the address of the string
 1699: 1				;R0 contains the value to convert
 1700: 1				;DPTR, R7, R6, and ACC gets clobbered
 1701: 1				;
 1702: 1				;***************************************************************
 1703: 1				;
 1704: 1  1501	E4					CLR	A				;NO LEADING ZEROS
 1705: 1  1502	90 27 10				MOV	DPTR,#10000			;SUBTRACT 10000
 1706: 1  1505	B1 1E					ACALL	RSUB				;DO THE SUBTRACTION
 1707: 1  1507	90 03 E8				MOV	DPTR,#1000			;NOW 1000
 1708: 1  150A	B1 1E					ACALL	RSUB
 1709: 1  150C	90 00 64				MOV	DPTR,#100			;NOW 100
 1710: 1  150F	B1 1E					ACALL	RSUB
 1711: 1  1511	90 00 0A				MOV	DPTR,#10			;NOW 10
 1712: 1  1514	B1 1E					ACALL	RSUB
 1713: 1  1516	90 00 01				MOV	DPTR,#1				;NOW 1
 1714: 1  1519	B1 1E					ACALL	RSUB
 1715: 1  151B	60 20					JZ	RSUB2				;JUMP OVER RET
 1716: 1				;
 1717: 1  151D	22		RSUB_R:			RET

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 32



 Line  I  Addr  Code            Source

 1718: 1				;
 1719: 1  151E	7E FF		RSUB:			MOV	R6,#-1				;SET UP THE COUNTER
 1720: 1				;
 1721: 1  1520	0E		RSUB1:			INC	R6				;BUMP THE COUNTER
 1722: 1  1521	CA					XCH	A,R2				;DO A FAST COMPARE
 1723: 1						CMP	A,DPH
 1724+ 2  1522	B5 83 00	CJNE	A,DPH,$+3
 1725: 1  1525	CA					XCH	A,R2
 1726: 1  1526	40 12					JC	FAST_DONE
 1727: 1  1528	C8					XCH	A,R0				;GET LOW BYTE
 1728: 1  1529	95 82					SUBB	A,DPL				;SUBTRACT, CARRY IS CLEARED
 1729: 1  152B	C8					XCH	A,R0				;PUT IT BACK
 1730: 1  152C	CA					XCH	A,R2				;GET THE HIGH BYTE
 1731: 1  152D	95 83					SUBB	A,DPH				;ADD THE HIGH BYTE
 1732: 1  152F	CA					XCH	A,R2				;PUT IT BACK
 1733: 1  1530	50 EE					JNC	RSUB1				;LOOP UNTIL CARRY
 1734: 1				;
 1735: 1  1532	C8					XCH	A,R0
 1736: 1  1533	25 82					ADD	A,DPL				;RESTORE R2:R0
 1737: 1  1535	C8					XCH	A,R0
 1738: 1  1536	CA					XCH	A,R2
 1739: 1  1537	35 83					ADDC	A,DPH
 1740: 1  1539	CA					XCH	A,R2
 1741: 1				;
 1742: 1  153A			FAST_DONE:
 1743: 1				;
 1744: 1  153A	4E					ORL	A,R6				;OR THE COUNT VALUE
 1745: 1  153B	60 E0					JZ	RSUB_R				;RETURN IF ZERO
 1746: 1				;
 1747: 1  153D	74 30		RSUB2:			MOV	A,#'0'				;GET THE ASCII BIAS
 1748: 1  153F	2E					ADD	A,R6				;ADD THE COUNT
 1749: 1				;
 1750: 1  1540	F7		RSUB4:			MOV	@R1,A				;PLACE THE VALUE IN MEMORY
 1751: 1  1541	09					INC	R1
 1752: 1				;
 1753: 1  1542	22					RET					;EXIT
 1754: 1				;
 1755: 1				;***************************************************************
 1756: 1				;
 1757: 1  1543			HEXOUT:	; Output the hex number in R3:R1, supress leading zeros, if set
 1758: 1				;
 1759: 1				;***************************************************************
 1760: 1				;
 1761: 1  1543	91 D9					ACALL	SOUT				;OUTPUT A SPACE
 1762: 1  1545	A2 0E					MOV	C,ZSURP				;GET ZERO SUPPRESSION BIT
 1763: 1  1547	92 0B					MOV	ADD_IN,C
 1764: 1  1549	EB					MOV	A,R3				;GET HIGH NIBBLE AND PRINT IT
 1765: 1  154A	B1 66					ACALL	HOUTHI
 1766: 1  154C	EB					MOV	A,R3
 1767: 1  154D	B1 67					ACALL	HOUTLO
 1768: 1				;
 1769: 1  154F	C2 0B		HEX2X:			CLR	ADD_IN				;DON'T SUPPRESS ZEROS
 1770: 1  1551	E9					MOV	A,R1				;GET LOW NIBBLE AND PRINT IT
 1771: 1  1552	B1 66					ACALL	HOUTHI
 1772: 1  1554	E9					MOV	A,R1
 1773: 1  1555	B1 67					ACALL	HOUTLO

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 33



 Line  I  Addr  Code            Source

 1774: 1  1557	7D 48					MOV	R5,#'H'				;OUTPUT H TO INDICATE HEX MODE
 1775: 1				;
 1776: 1  1559	81 DB		SOUT_1:			AJMP	SOUT1
 1777: 1				;
 1778: 1  155B	C2 0B		HOUT1:			CLR	ADD_IN				;PRINTED SOMETHING, SO CLEAR ADD_IN
 1779: 1  155D	24 90					ADD	A,#90H				;CONVERT TO ASCII
 1780: 1  155F	D4					DA	A
 1781: 1  1560	34 40					ADDC	A,#40H
 1782: 1  1562	D4					DA	A				;GOT IT HERE
 1783: 1  1563	FD					MOV	R5,A				;OUTPUT THE BYTE
 1784: 1  1564	80 F3					SJMP	SOUT_1
 1785: 1				;
 1786: 1  1566	C4		HOUTHI:			SWAP	A				;SWAP TO OUTPUT HIGH NIBBLE
 1787: 1				;
 1788: 1  1567	54 0F		HOUTLO:			ANL	A,#0FH				;STRIP
 1789: 1  1569	70 F0					JNZ	HOUT1				;PRINT IF NOT ZERO
 1790: 1  156B	30 0B ED				JNB	ADD_IN,HOUT1			;OUTPUT A ZERO IF NOT SUPRESSED
 1791: 1  156E	22					RET
 1792: 1				;
 1793: 1				;
 1794: 1  156F			GET_DIGIT_CHECK:	; Get a character, then check for digit
 1795: 1				;
 1796: 1  156F	71 A8					ACALL	GET_R1_CHARACTER
 1797: 1				;
 1798: 1  1571			DIGIT_CHECK:	;CHECK FOR A VALID ASCII DIGIT, SET CARRY IF FOUND
 1799: 1				;
 1800: 1						CMP	A,#'9'+1			;SEE IF ASCII 9 OR LESS
 1801+ 2  1571	B4 3A 00	CJNE	A,#'9'+1,$+3
 1802: 1  1574	40 01					JC	DC1
 1803: 1  1576	22					RET
 1804: 1				;
 1805: 1  1577			DC1:			CMP	A,#'0'				;SEE IF ASCII 0 OR GREATER
 1806+ 2  1577	B4 30 00	CJNE	A,#'0',$+3
 1807: 1  157A	B3					CPL	C
 1808: 1  157B	22					RET
 1809: 1				;
 1810: 1
 1811: 1  157C	C0 00		R5OUT:			PUSH	00h
 1812: 1  157E	C0 E0					PUSH	ACC				; me
 1813: 1  1580	ED					MOV	A,R5				; me
 1814: 1  1581	A8 54					MOV	R0,FPOUTPTR
 1815: 1  1583	F6					MOV	@R0,A
 1816: 1  1584	05 54					INC	FPOUTPTR
 1817: 1			;			ACALL	TXBYTE				; me
 1818: 1  1586	D0 E0					POP	ACC				; me
 1819: 1  1588	D0 00					POP	00h
 1820: 1  158A	22					RET					; me
 1821: 1
 1822: 1  158B	01 01		SQ_ERR:			JMP	BADPRM				; me
 1823: 1
 1824: 1			; Pop the ARG STACK and check for overflow
 1825: 1  158D			INC_ASTKA:
 1826: 1  158D	74 06					MOV	A,#FP_NUMBER_SIZE		;number to pop
 1827: 1  158F	80 16					SJMP	SETREG1
 1828: 1
 1829: 1			;Push ARG STACK and check for underflow

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 34



 Line  I  Addr  Code            Source

 1830: 1  1591			DEC_ASTKA:
 1831: 1  1591	74 FA					MOV	A,#-FP_NUMBER_SIZE
 1832: 1  1593	25 22					ADD	A,ARG_STACK
 1833: 1						CMP	A,#0
 1834+ 2  1595	B4 00 00	CJNE	A,#0,$+3
 1835: 1  1598	40 28					JC	E4YY
 1836: 1  159A	F5 22					MOV	ARG_STACK,A
 1837: 1  159C	F9					MOV	R1,A
 1838: 1  159D	22		SRT:			RET
 1839: 1
 1840: 1  159E	B1 8D		POPAS:			ACALL	INC_ASTKA
 1841: 1  15A0	A1 B9					AJMP	VARCOP				;COPY THE VARIABLE
 1842: 1
 1843: 1  15A2	B1 91		PUSHAS:			ACALL	DEC_ASTKA
 1844: 1  15A4	A1 B9					AJMP	VARCOP
 1845: 1
 1846: 1  15A6	E4		SETREG:			CLR	A				;DON'T POP ANYTHING
 1847: 1  15A7	A8 22		SETREG1:		MOV	R0,ARG_STACK
 1848: 1  15A9	28					ADD	A,R0
 1849: 1  15AA	40 16					JC	E4YY
 1850: 1  15AC	F5 22					MOV	ARG_STACK,A
 1851: 1  15AE	E6					MOV	A,@R0
 1852: 1  15AF	22		A_D:			RET
 1853: 1
 1854: 1			;Routine to copy bottom arg on stack to address in R1.
 1855: 1  15B0	B1 A6		MOVAS:  		ACALL   SETREG				;SET UP R0
 1856: 1  15B2	E6		M_C:			MOV	A,@R0				;READ THE VALUE
 1857: 1  15B3	F7					MOV	@R1,A				;SAVE IT
 1858: 1  15B4	08		        		INC     R0
 1859: 1  15B5	09		        		INC     R1
 1860: 1  15B6	DC FA		        		DJNZ    R4,M_C  	        	;LOOP
 1861: 1  15B8	22					RET					;EXIT
 1862: 1
 1863: 1
 1864: 1			; VARCOP - Copy a variable from R0 to R1
 1865: 1  15B9	7C 06		VARCOP:			MOV	R4,#FP_NUMBER_SIZE		;LOAD THE LOOP COUNTER
 1866: 1  15BB	E6		V_C:			MOV	A,@R0				;READ THE VALUE
 1867: 1  15BC	F7					MOV	@R1,A				;SAVE IT
 1868: 1  15BD	18					DEC	R0
 1869: 1  15BE	19					DEC	R1
 1870: 1  15BF	DC FA					DJNZ	R4,V_C				;LOOP
 1871: 1  15C1	22					RET					;EXIT
 1872: 1			;
 1873: 1  15C2	90 15 FD	E4YY:			MOV	DPTR,#EXA
 1874: 1  15C5	01 00					JMP	PRTERR				; me
 1875: 1
 1876: 1				; integer operator - INT
 1877: 1  15C7	B1 A6		AINT:			ACALL	SETREG				;SET UP THE REGISTERS, CLEAR CARRY
 1878: 1  15C9	94 81					SUBB	A,#129				;SUBTRACT EXPONENT BIAS
 1879: 1  15CB	50 07					JNC	AI1				;JUMP IF ACC > 81H
 1880: 1				;
 1881: 1				; Force the number to be a zero
 1882: 1				;
 1883: 1  15CD	B1 8D					ACALL	INC_ASTKA			;BUMP THE STACK
 1884: 1				;
 1885: 1  15CF	90 16 05	P_Z:			MOV	DPTR,#ZRO			;PUT ZERO ON THE STACK

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 35



 Line  I  Addr  Code            Source

 1886: 1  15D2	A1 E9					AJMP	PUSHC
 1887: 1				;
 1888: 1  15D4	94 07		AI1:			SUBB	A,#7
 1889: 1  15D6	50 10					JNC	AI3
 1890: 1  15D8	F4					CPL	A
 1891: 1  15D9	04					INC	A
 1892: 1  15DA	FB					MOV	R3,A
 1893: 1  15DB	18					DEC	R0				;POINT AT SIGN
 1894: 1				;
 1895: 1  15DC	18		AI2:			DEC	R0				;NOW AT LSB'S
 1896: 1  15DD	E6					MOV	A,@R0				;READ BYTE
 1897: 1  15DE	54 F0					ANL	A,#0F0H				;STRIP NIBBLE
 1898: 1  15E0	F6					MOV	@R0,A				;WRITE BYTE
 1899: 1  15E1	DB 01					DJNZ	R3,AI21
 1900: 1  15E3	22					RET
 1901: 1  15E4	E4		AI21:			CLR	A
 1902: 1  15E5	F6					MOV	@R0,A				;CLEAR THE LOCATION
 1903: 1  15E6	DB F4					DJNZ	R3,AI2
 1904: 1  15E8	22		AI3:			RET					;EXIT
 1905: 1				;
 1906: 1				; PUSHC - Push constant pointed by DPTR on to the arg stack
 1907: 1  15E9	B1 91		PUSHC:			ACALL	DEC_ASTKA
 1908: 1  15EB	7B 06					MOV	R3,#FP_number_SIZe		;LOOP COUNTER
 1909: 1  15ED	E4		PCL:			CLR	A				;SET UP A
 1910: 1  15EE	93					MOVC	A,@A+DPTR			;LOAD IT
 1911: 1  15EF	F7					MOV	@R1,A				;SAVE IT
 1912: 1  15F0	A3					INC	DPTR				;BUMP POINTERS
 1913: 1  15F1	19					DEC	R1
 1914: 1  15F2	DB F9					DJNZ	R3,PCL				;LOOP
 1915: 1  15F4	22					RET					;EXIT
 1916: 1			;
 1917: 1
 1918: 1  15F5	F5 99		TXBYTE:			MOV	SBUF,A
 1919: 1  15F7	30 99 FD				JNB	SCON.1,$
 1920: 1  15FA	C2 99					CLR	SCON.1
 1921: 1  15FC	22					RET
 1922: 1
 1923: 1  15FD	41 2D 53 54	EXA:			DB	'A-STACK',0
       1  1601	41 43 4B 00
 1924: 1  1605	00 00 00	ZRO:			DB	0,0,0
 1925: 1  1608	00 00 00				DB	0,0,0				;0.0000000
 1926:
 1927:						END





                     register banks used:  ---

                     no errors




ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 36





	       L I S T   O F   S Y M B O L S
	       =============================


SYMBOL				  TYPE     VALUE	LINE
------------------------------------------------------------
??ASEM_51			  NUMBER    8051
??VERSION			  NUMBER    0130
AC				  BIT	      D6
ACC				  DATA	      E0
ADCONVERT			  CODE	    009B	  98
ADCONVERT1			  CODE	    00A4	 106
ADCONVERT2			  CODE	    00B2	 115
ADCONVERT3			  CODE	    00BF	 124
ADDIT				  CODE	    0187	 277
ADDLP				  CODE	    106B	 565
ADD_IN				  BIT	      0B	   6
ADD_R				  CODE	    1069	 563
AI1				  CODE	    15D4	1888
AI2				  CODE	    15DC	1895
AI21				  CODE	    15E4	1901
AI3				  CODE	    15E8	1904
AINT				  CODE	    15C7	1877
ARG1_EXP_IS_LARGER		  CODE	    10D0	 668
ARG1_EXP_IS_LARGER1		  CODE	    10D1	 671
ARG1_EXP_IS_LARGER2		  CODE	    10D4	 673
ARG_STACK			  NUMBER    0022	   8
A_D				  CODE	    15AF	1852
B				  DATA	      F0
BADPRM				  CODE	    1001	 458
BIN2DEC				  CODE	    0145	 226
BIN2DEC1			  CODE	    014C	 229
BIN2DEC2			  CODE	    014E	 230
BIN2DEC3			  CODE	    0162	 245
BIN2DEC4			  CODE	    016B	 250
BINDEC				  CODE	    019B	 295
BOTH_PLUS			  CODE	    10D8	 681
CLOOP				  CODE	    10E0	 693
CMP				  MACRO	        	 389
CONVERT_BINARY_TO_ASCII_STRING	  CODE	    1501	1696
CONVT				  NUMBER    0066	  11
CR				  NUMBER    0050	  12
CY				  BIT	      D7
DC1				  CODE	    1577	1805
DECX				  CODE	    138B	1370
DEC_ASTKA			  CODE	    1591	1830
DIGIT				  NUMBER    0004	 406
DIGIT_CHECK			  CODE	    1571	1798
DIV0				  CODE	    112F	 787
DIV3				  CODE	    113C	 796
DIV4				  CODE	    1149	 804
DIV5				  CODE	    114C	 807
DIV6				  CODE	    1154	 812
DIV7				  CODE	    116B	 834
DIV8				  CODE	    1180	 847
DONE_LOAD			  BIT	      33	 435

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 37



SYMBOL				  TYPE     VALUE	LINE
------------------------------------------------------------
DPH				  DATA	      83
DPL				  DATA	      82
D_UNDER				  CODE	    113A	 794
E4YY				  CODE	    15C2	1873
EA				  BIT	      AF
ES				  BIT	      AC
ET0				  BIT	      A9
ET1				  BIT	      AB
EX0				  BIT	      A8
EX1				  BIT	      AA
EXA				  CODE	    15FD	1923
EXPONENTS_EQUAL			  CODE	    10D5	 675
EXPOT4				  CODE	    1455	1546
EXPOT5				  CODE	    1480	1575
EXPOTX				  CODE	    1453	1544
EXPOUT				  CODE	    1440	1531
EXTI0				  CODE	    0003
EXTI1				  CODE	    0013
F0				  BIT	      D5
FAST_DONE			  CODE	    153A	1742
FDT1				  CODE	    139C	1384
FDT2				  CODE	    13A4	1388
FDTEST				  CODE	    1398	1381
FINISH1				  CODE	    135D	1336
FINISH2				  CODE	    1370	1352
FINISH_UP			  CODE	    1371	1354
FINISH_UP1			  CODE	    1378	1359
FIRST_RADIX			  BIT	      32	 434
FLOATING_ADD			  CODE	    1009	 472
FLOATING_COMP			  CODE	    10BC	 642
FLOATING_DIV			  CODE	    1122	 772
FLOATING_MUL			  CODE	    10ED	 709
FLOATING_POINT_INPUT		  CODE	    130B	1281
FLOATING_POINT_OUTPUT		  CODE	    13B9	1425
FLOATING_SUB			  CODE	    1002	 462
FMUL0				  CODE	    10F2	 718
FMUL1				  CODE	    10F4	 722
FMUL2				  CODE	    1106	 738
FMUL3				  CODE	    110F	 753
FMUL_OVER			  CODE	    1102	 732
FORMAT				  NUMBER    0023	   9
FOUND_RADIX			  BIT	      31	 433
FOV				  CODE	    1104	 736
FP24MUL				  CODE	    01C9	 307
FP5MUL				  CODE	    01C3	 306
FPC1				  CODE	    1215	1020
FPO1				  CODE	    13D2	1452
FPO2				  CODE	    13E5	1465
FPOUTPTR			  NUMBER    0054	  13
FPOUTSTR			  NUMBER    0055	  14
FP_ACC1				  NUMBER    0031	 446
FP_ACC2				  NUMBER    0032	 447
FP_ACC3				  NUMBER    0033	 448
FP_ACC4				  NUMBER    0034	 449
FP_ACC5				  NUMBER    0035	 450
FP_ACC6				  NUMBER    0036	 451

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 38



SYMBOL				  TYPE     VALUE	LINE
------------------------------------------------------------
FP_ACC7				  NUMBER    0037	 452
FP_ACC8				  NUMBER    0038	 453
FP_ACCC				  NUMBER    0030	 445
FP_ACCS				  NUMBER    0039	 454
FP_ACCX				  NUMBER    002F	 444
FP_CARRY			  NUMBER    0026	 424
FP_CLEAR			  CODE	    1212	1011
FP_DIG12			  NUMBER    0027	 425
FP_DIG34			  NUMBER    0028	 426
FP_DIG56			  NUMBER    0029	 427
FP_DIG78			  NUMBER    002A	 428
FP_EXP				  NUMBER    002C	 430
FP_NIB1				  NUMBER    0027	 436
FP_NIB2				  NUMBER    0028	 437
FP_NIB3				  NUMBER    0029	 438
FP_NIB4				  NUMBER    002A	 439
FP_NIB5				  NUMBER    002B	 440
FP_NIB6				  NUMBER    002C	 441
FP_NIB7				  NUMBER    002D	 442
FP_NIB8				  NUMBER    002E	 443
FP_NUMBER_SIZE			  NUMBER    0006	 405
FP_SIGN				  NUMBER    002B	 429
FP_STATUS			  NUMBER    0024	  10
FP_TEMP				  NUMBER    0025	 423
FREE				  CODE	    1411	1500
FREE1				  CODE	    1418	1505
FREE2				  CODE	    1434	1524
FREE4				  CODE	    142C	1519
FRTEST				  CODE	    1395	1379
FSUB10				  CODE	    10BA	 638
FSUB5				  CODE	    1089	 597
FSUB6				  CODE	    1094	 608
FSUB7				  CODE	    1098	 611
FSUB8				  CODE	    10A3	 619
FSUB9				  CODE	    10A9	 626
GET_DIGIT_CHECK			  CODE	    156F	1794
GET_R1_CHARACTER		  CODE	    13A8	1402
GT1				  CODE	    1333	1311
GT11				  CODE	    133B	1314
GT12				  CODE	    133E	1315
GT2				  CODE	    134B	1324
GTEST				  CODE	    1324	1304
HC1				  CODE	    1306	1274
HEX2X				  CODE	    154F	1769
HEXDO1				  CODE	    12FA	1261
HEXDON				  CODE	    12F9	1259
HEXOUT				  CODE	    1543	1757
HEXSC1				  CODE	    12E8	1248
HEXSCAN				  CODE	    12E6	1241
HEX_CHECK			  CODE	    12FE	1266
HOUT1				  CODE	    155B	1778
HOUTHI				  CODE	    1566	1786
HOUTLO				  CODE	    1567	1788
HS1				  CODE	    12FB	1263
IE				  DATA	      A8
IE0				  BIT	      89

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 39



SYMBOL				  TYPE     VALUE	LINE
------------------------------------------------------------
IE1				  BIT	      8B
INC_AND_GET_R1_CHARACTER	  CODE	    13A7	1398
INC_ASTKA			  CODE	    158D	1825
INC_FP_EXP			  CODE	    11D2	 934
INERR				  CODE	    138D	1372
INLOOP				  CODE	    1319	1296
INLPIK				  CODE	    1321	1301
INT0				  BIT	      B2
INT1				  BIT	      B3
INTGRC				  BIT	      09	   5
IP				  DATA	      B8
IT0				  BIT	      88
IT1				  BIT	      8A
LCDBUFF				  NUMBER    0040	   2
LCDBUFFSIZE			  NUMBER    0010	   3
LCDCHROUT			  CODE	    00EC	 160
LCDCLEAR			  CODE	    0100	 172
LCDCLEAR1			  CODE	    0106	 175
LCDCLEARBUFF			  CODE	    013A	 213
LCDCLEARBUFF1			  CODE	    0140	 216
LCDCMDOUT			  CODE	    00DC	 149
LCDDELAY			  CODE	    00CC	 136
LCDINIT				  CODE	    0121	 199
LCDNIBOUT			  CODE	    00D5	 143
LCDPRINTSTR			  CODE	    0110	 185
LCDSETADR			  CODE	    010B	 180
LEFT				  CODE	    1253	1080
LEFT1				  CODE	    1255	1086
LEFT3				  CODE	    125D	1092
LEFT5				  CODE	    127C	1119
LEFTL				  CODE	    1268	1101
LOAD1				  CODE	    1023	 508
LOAD2				  CODE	    1033	 520
LOAD3				  CODE	    103B	 527
LOAD4				  CODE	    1044	 537
LOAD5				  CODE	    1056	 551
LOAD7				  CODE	    11F3	 966
LOADR1				  CODE	    12DC	1230
LOADR1_MANTISSA			  CODE	    12D8	1221
LOAD_POINTERS			  CODE	    12BE	1177
MDES1				  CODE	    12C7	1198
MNL0				  CODE	    129E	1151
MNL1				  CODE	    12B0	1163
MNLOOP				  CODE	    1295	1143
MOUT				  CODE	    14CD	1645
MOVAS				  CODE	    15B0	1855
MSIGN				  BIT	      58	 431
MUL11				  CODE	    14F9	1685
MULNUM				  CODE	    14E0	1663
MULNUM10			  CODE	    14DD	1659
MULX				  CODE	    1500	1692
MUL_DIV_EXP_AND_SIGN		  CODE	    12C5	1189
MUL_NIBBLE			  CODE	    128B	1129
M_C				  CODE	    15B2	1856
NL1				  CODE	    14AD	1615
NR1				  CODE	    14B6	1624

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 40



SYMBOL				  TYPE     VALUE	LINE
------------------------------------------------------------
NUM_LT				  CODE	    14A6	1609
NUM_RT				  CODE	    14AF	1618
OUTR				  CODE	    149B	1598
OUTR0				  CODE	    148A	1584
OV				  BIT	      D2
OVE1				  CODE	    11F8	 977
OVERFLOW			  NUMBER    0001	 410
OVERFLOW_AND_EXIT		  CODE	    11F4	 970
P				  BIT	      D0
P0				  DATA	      80
P1				  DATA	      90
P2				  DATA	      A0
P3				  DATA	      B0
PACK				  CODE	    1183	 851
PACK0				  CODE	    118C	 864
PACK1				  CODE	    118D	 866
PACK2				  CODE	    1197	 874
PACK3				  CODE	    11A9	 888
PACK4				  CODE	    11AF	 895
PCL				  CODE	    15ED	1909
PCON				  DATA	      87
PLOOP				  CODE	    11B1	 899
PLUS_MINUS_TEST			  CODE	    13AE	1411
PMT0				  CODE	    13B3	1415
PMT1				  CODE	    13B8	1421
PMT2				  CODE	    13B6	1417
PMT3				  CODE	    13B7	1419
POPAS				  CODE	    159E	1840
POP_AND_EXIT			  CODE	    101B	 499
POSNM1				  CODE	    136D	1349
POSNUM				  CODE	    136A	1346
PRET				  CODE	    11D1	 932
PRNTCDPTRLCD			  CODE	    0117	 191
PRNTCDPTRLCD1			  CODE	    0120	 197
PRTERR				  CODE	    1000	 457
PS				  BIT	      BC
PSW				  DATA	      D0
PT0				  BIT	      B9
PT1				  BIT	      BB
PUSHAS				  CODE	    15A2	1843
PUSHC				  CODE	    15E9	1907
PX0				  BIT	      B8
PX1				  BIT	      BA
P_Z				  CODE	    15CF	1885
R0B0				  NUMBER    0000	 407
R1B0				  NUMBER    0001	 408
R5OUT				  CODE	    157C	1811
RB8				  BIT	      9A
RD				  BIT	      B7
REN				  BIT	      9C
RESET				  CODE	    0000
RET_X				  CODE	    138F	1374
RI				  BIT	      98
RIGHT				  CODE	    121B	1027
RIGHT1				  CODE	    121D	1034
RIGHT3				  CODE	    1225	1042

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 41



SYMBOL				  TYPE     VALUE	LINE
------------------------------------------------------------
RIGHT5				  CODE	    1244	1068
RIGHTL				  CODE	    1231	1052
ROUT				  CODE	    14D1	1648
RS0				  BIT	      D3
RS1				  BIT	      D4
RSUB				  CODE	    151E	1719
RSUB1				  CODE	    1520	1721
RSUB2				  CODE	    153D	1747
RSUB4				  CODE	    1540	1750
RSUB_R				  CODE	    151D	1717
RXD				  BIT	      B0
SBUF				  DATA	      99
SCON				  DATA	      98
SE1				  CODE	    1015	 493
SETREG				  CODE	    15A6	1846
SETREG1				  CODE	    15A7	1847
SIGNS_DIFFERENT			  CODE	    10CD	 663
SINOUT				  CODE	    14CA	1642
SINT				  CODE	    0023
SM0				  BIT	      9F
SM1				  BIT	      9E
SM2				  BIT	      9D
SOUT				  CODE	    14D9	1654
SOUT1				  CODE	    14DB	1656
SOUT_1				  CODE	    1559	1776
SP				  DATA	      81
SPACE7				  CODE	    14B7	1626
SQ_ERR				  CODE	    158B	1822
SRT				  CODE	    159D	1838
SS7				  CODE	    14C8	1640
START				  CODE	    0003	  20
START1				  CODE	    0016	  27
START2				  CODE	    003B	  43
START3				  CODE	    0076	  72
START4				  CODE	    0093	  88
STDIG				  CODE	    1381	1365
STDIG1				  CODE	    1390	1376
STORE2				  CODE	    11C9	 924
STORE_ALIGN_TEST_AND_EXIT	  CODE	    11C3	 914
SUBIT				  CODE	    016E	 254
SUBLP				  CODE	    1074	 575
SWAP_AND_EXIT			  CODE	    1011	 486
T0				  BIT	      B4
T1				  BIT	      B5
TB8				  BIT	      9B
TCON				  DATA	      88
TF0				  BIT	      8D
TF1				  BIT	      8F
TH0				  DATA	      8C
TH1				  DATA	      8D
TI				  BIT	      99
TIMER0				  CODE	    000B
TIMER1				  CODE	    001B
TL0				  DATA	      8A
TL1				  DATA	      8B
TMOD				  DATA	      89

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 42



SYMBOL				  TYPE     VALUE	LINE
------------------------------------------------------------
TR0				  BIT	      8C
TR1				  BIT	      8E
TXBYTE				  CODE	    15F5	1918
TXD				  BIT	      B1
ULOOP				  CODE	    11E2	 952
UNDERFLOW			  NUMBER    0000	 409
UNDERFLOW_AND_EXIT		  CODE	    1205	 989
UNPACK_R0			  CODE	    11DE	 945
USING0				  CODE	    13EF	1471
USING1				  CODE	    13F5	1476
USING2				  CODE	    1407	1489
USINGX				  CODE	    1405	1487
USINGY				  CODE	    1402	1484
U_RET				  CODE	    1489	1582
VARCOP				  CODE	    15B9	1865
V_C				  CODE	    15BB	1866
WR				  BIT	      B6
XOUT0				  CODE	    1462	1554
XOUT2				  CODE	    1467	1558
XOUT3				  CODE	    146F	1563
XOUT4				  CODE	    1473	1567
XSIGN				  BIT	      30	 432
Z7R7				  CODE	    14BF	1632
ZERO				  NUMBER    0002	 411
ZERO7				  CODE	    14C0	1634
ZERO_AND_EXIT			  CODE	    120B	1000
ZERO_DIVIDE			  NUMBER    0003	 412
ZOUT				  CODE	    14D5	1651
ZRO				  CODE	    1605	1924
ZSURP				  BIT	      0E	   7
ZT0				  CODE	    149E	1602
ZT1				  CODE	    14A5	1607
ZTEST				  CODE	    149C	1600
